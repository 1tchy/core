# Language zh-CN translations for master.xml package.
# Automatically generated, 2008.
#
msgid ""
msgstr ""
"Project-Id-Version: master.xml\n"
"Report-Msgid-Bugs-To: http://bugs.kde.org\n"
"POT-Creation-Date: 2008-12-20 22:08+0000\n"
"PO-Revision-Date: 2009-02-10 15:58+0800\n"
"Last-Translator: Sean Wu <alartin@gmail.com>\n"
"Language-Team: none\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#. Tag: title
#: ee.xml:4
#, no-c-format
msgid "Java EE integration"
msgstr "Java EE整合"

#. Tag: para
#: ee.xml:6
#, no-c-format
msgid "Web Beans is fully integrated into the Java EE environment. Web Beans have access to Java EE resources and JPA persistence contexts. They may be used in Unified EL expressions in JSF and JSP pages. They may even be injected into some objects, such as Servlets and Message-Driven Beans, which are not Web Beans."
msgstr "Web Beans被完全地整合进了Java EE环境里。Web Beans 能够访问Java EE资源和JPA持久化上下文。它们可以在JSF和JSP页面中的统一表达式语言使用。它们甚至可以被注入到一些对象中，例如Servlet和消息驱动Bean，而这些对象都不是Web Bean。"

#. Tag: title
#: ee.xml:12
#, no-c-format
msgid "Injecting Java EE resources into a Web Bean"
msgstr "将Java EE资源注入到一个Web Bean中"

#. Tag: para
#: ee.xml:14
#, no-c-format
msgid "All simple and enterprise Web Beans may take advantage of Java EE dependency injection using <literal>@Resource</literal>, <literal>@EJB</literal> and <literal>@PersistenceContext</literal>. We've already seen a couple of examples of this, though we didn't pay much attention at the time:"
msgstr "所有简单的和企业的Web Beans都可以通过<literal>@Resource</literal>, <literal>@EJB</literal>和<literal>@PersistenceContext</literal>来使用Java EE的依赖注入。我们已经看过很多例子了，虽然我们没有在这上面耗费精力："

#. Tag: programlisting
#: ee.xml:19
#, no-c-format
msgid ""
"<![CDATA[@Transactional @Interceptor\n"
"public class TransactionInterceptor {\n"
"\n"
"    @Resource Transaction transaction;\n"
"\n"
"    @AroundInvoke public Object manageTransaction(InvocationContext ctx) { ... }\n"
"    \n"
"}]]>"
msgstr ""
"<![CDATA[@Transactional @Interceptor\n"
"public class TransactionInterceptor {\n"
"\n"
"    @Resource Transaction transaction;\n"
"\n"
"    @AroundInvoke public Object manageTransaction(InvocationContext ctx) { ... }\n"
"    \n"
"}]]>"

#. Tag: programlisting
#: ee.xml:21
#, no-c-format
msgid ""
"<![CDATA[@SessionScoped\n"
"public class Login {\n"
"\n"
"    @Current Credentials credentials;\n"
"    @PersistenceContext EntityManager userDatabase;\n"
"    \n"
"    ...\n"
"\n"
"}]]>"
msgstr ""
"<![CDATA[@SessionScoped\n"
"public class Login {\n"
"\n"
"    @Current Credentials credentials;\n"
"    @PersistenceContext EntityManager userDatabase;\n"
"    \n"
"    ...\n"
"\n"
"}]]>"

#. Tag: para
#: ee.xml:23
#, no-c-format
msgid "The Java EE <literal>@PostConstruct</literal> and <literal>@PreDestroy</literal> callbacks are also supported for all simple and enterprise Web Beans. The <literal>@PostConstruct</literal> method is called after <emphasis>all</emphasis> injection has been performed."
msgstr "所有的简单的和企业的Web Beans都支持Java EE的<literal>@PostConstruct</literal>和<literal>@PreDestroy</literal>回调。<literal>@PostConstruct</literal>方法在<emphasis>所有的</emphasis> 注入完成后被调用。"

#. Tag: para
#: ee.xml:28
#, no-c-format
msgid "There is one restriction to be aware of here: <literal>@PersistenceContext(type=EXTENDED)</literal> is not supported for simple Web Beans."
msgstr "这里需要注意的一个限制是：简单的Web Beans不支持 <literal>@PersistenceContext(type=EXTENDED)</literal>"

#. Tag: title
#: ee.xml:35
#, no-c-format
msgid "Calling a Web Bean from a Servlet"
msgstr "从Servlet调用一个Web Bean"

#. Tag: para
#: ee.xml:37
#, no-c-format
msgid "It's easy to use a Web Bean from a Servlet in Java EE 6. Simply inject the Web Bean using Web Beans field or initializer method injection."
msgstr "在Java EE 6中，从一个Servlet中调用一个Web Bean非常容易，只须使用Web Beans域注入一个Web Bean或者将初始方法注入即可。"

#. Tag: programlisting
#: ee.xml:40
#, no-c-format
msgid ""
"public class Login extends HttpServlet {\n"
"\n"
"    @Current Credentials credentials;\n"
"    @Current Login login;\n"
"\n"
"    @Override\n"
"    public void service(HttpServletRequest request, HttpServletResponse response)\n"
"        throws ServletException, IOException {\n"
"        credentials.setUsername( request.getAttribute(\"username\") ):\n"
"        credentials.setPassword( request.getAttribute(\"password\") ):\n"
"        login.login();\n"
"        if ( login.isLoggedIn() ) {\n"
"            response.sendRedirect(\"/home.jsp\");\n"
"        }\n"
"        else {\n"
"            response.sendRedirect(\"/loginError.jsp\");\n"
"        }\n"
"    }\n"
"            \n"
"}"
msgstr ""
"public class Login extends HttpServlet {\n"
"\n"
"    @Current Credentials credentials;\n"
"    @Current Login login;\n"
"\n"
"    @Override\n"
"    public void service(HttpServletRequest request, HttpServletResponse response)\n"
"        throws ServletException, IOException {\n"
"        credentials.setUsername( request.getAttribute(\"username\") ):\n"
"        credentials.setPassword( request.getAttribute(\"password\") ):\n"
"        login.login();\n"
"        if ( login.isLoggedIn() ) {\n"
"            response.sendRedirect(\"/home.jsp\");\n"
"        }\n"
"        else {\n"
"            response.sendRedirect(\"/loginError.jsp\");\n"
"        }\n"
"    }\n"
"            \n"
"}"

#. Tag: para
#: ee.xml:42
#, no-c-format
msgid "The Web Beans client proxy takes care of routing method invocations from the Servlet to the correct instances of <literal>Credentials</literal> and <literal>Login</literal> for the current request and HTTP session."
msgstr "Web Beans客户端代理将Servlet中的方法调用路由到当前请求和HTTP会话中相应的<literal>Credentials</literal> 和 <literal>Login</literal> 实例。"

#. Tag: title
#: ee.xml:49
#, no-c-format
msgid "Calling a Web Bean from a Message-Driven Bean"
msgstr "从消息驱动Bean中调用一个Web Bean"

#. Tag: para
#: ee.xml:51
#, no-c-format
msgid "Web Beans injection applies to all EJBs, even when they aren't under the control of the Web Bean manager (if they were obtained by direct JNDI lookup, or injection using <literal>@EJB</literal>, for example. In particular, you can use Web Beans injection in Message-Driven Beans, which are not considered Web Beans because you can't inject them."
msgstr "Web Beans注入可以应用于所有的EJB，甚至这些EJB不在Web Bean管理器的控制之下也可以（如果它们可以直接从JNDI查找或者使用<literal>@EJB</literal>注入）。消息驱动Bean不能成为Web Beans，因为你无法注入它们，但你仍然可以将Web Beans注入到消息驱动Bean中。"

#. Tag: para
#: ee.xml:57
#, no-c-format
msgid "You can even use Web Beans interceptor bindings for Message-Driven Beans."
msgstr "你甚至可以将Web Beans拦截器绑定到消息驱动Bean上。"

#. Tag: programlisting
#: ee.xml:59
#, no-c-format
msgid ""
"@Transactional @MessageDriven\n"
"public class ProcessOrder implements MessageListener {\n"
"\n"
"    @Current Inventory inventory;\n"
"    @PersistenceContext EntityManager em;\n"
"\n"
"    public void onMessage(Message message) {\n"
"        ...\n"
"    }\n"
"            \n"
"}"
msgstr ""
"@Transactional @MessageDriven\n"
"public class ProcessOrder implements MessageListener {\n"
"\n"
"    @Current Inventory inventory;\n"
"    @PersistenceContext EntityManager em;\n"
"\n"
"    public void onMessage(Message message) {\n"
"        ...\n"
"    }\n"
"            \n"
"}"

#. Tag: para
#: ee.xml:61
#, no-c-format
msgid "Thus, receiving messages is super-easy in a Web Beans environment. But beware that there is no session or conversation context available when a message is delivered to a Message-Driven Bean. Only <literal>@RequestScoped</literal> and <literal>@ApplicationScoped</literal> Web Beans are available."
msgstr "这样，在一个Web Beans环境中接受消息就相当简单了。但是需要注意的是，当一个消息发送到一个消息驱动Bean的时候，此时没有会话，我们无法获得对话上下文。我们只能获得 <literal>@RequestScoped</literal> 和 <literal>@ApplicationScoped</literal> 注释的Web Beans。"

#. Tag: para
#: ee.xml:66
#, no-c-format
msgid "It's also easy to send messages using Web Beans."
msgstr "使用Web Beans发送消息也相当简单。"

#. Tag: title
#: ee.xml:71
#, no-c-format
msgid "JMS endpoints"
msgstr "JMS端点"

#. Tag: para
#: ee.xml:73
#, no-c-format
msgid "Sending messages using JMS can be quite complex, because of the number of different objects you need to deal with. For queues we have <literal>Queue</literal>, <literal>QueueConnectionFactory</literal>, <literal>QueueConnection</literal>, <literal>QueueSession</literal> and <literal>QueueSender</literal>. For topics we have <literal>Topic</literal>, <literal>TopicConnectionFactory</literal>, <literal>TopicConnection</literal>, <literal>TopicSession</literal> and <literal>TopicPublisher</literal>. Each of these objects has its own lifecycle and threading model that we need to worry about."
msgstr "使用JMS发送消息有点复杂，因为你需要处理很多不同的对象。对于队列（Queue），我们有<literal>Queue</literal>, <literal>QueueConnectionFactory</literal>, <literal>QueueConnection</literal>, <literal>QueueSession</literal> 和 <literal>QueueSender</literal>。对于主题（Topic）有<literal>Topic</literal>, <literal>TopicConnectionFactory</literal>, <literal>TopicConnection</literal>, <literal>TopicSession</literal> 和 <literal>TopicPublisher</literal>。这些对象每个都有自己的生命周期和线程模型，我们都需要考虑这些问题。"

#. Tag: para
#: ee.xml:82
#, no-c-format
msgid "Web Beans takes care of all this for us. All we need to do is declare the queue or topic in <literal>web-beans.xml</literal>, specifying an associated binding type and connection factory."
msgstr "Web Beans为我们处理所有这些问题。我们只须在 <literal>web-beans.xml</literal>声明队列或者主题，指定一个关联的绑定类型和连接工厂即可。"

#. Tag: programlisting
#: ee.xml:86
#, no-c-format
msgid ""
"<![CDATA[<Queue>\n"
"    <destination>java:comp/env/jms/OrderQueue</destination>\n"
"    <connectionFactory>java:comp/env/jms/QueueConnectionFactory</connectionFactory>\n"
"    <myapp:OrderProcessor/>    \n"
"</Queue>]]>"
msgstr ""
"<![CDATA[<Queue>\n"
"    <destination>java:comp/env/jms/OrderQueue</destination>\n"
"    <connectionFactory>java:comp/env/jms/QueueConnectionFactory</connectionFactory>\n"
"    <myapp:OrderProcessor/>    \n"
"</Queue>]]>"

#. Tag: programlisting
#: ee.xml:88
#, no-c-format
msgid ""
"<![CDATA[<Topic>\n"
"    <destination>java:comp/env/jms/StockPrices</destination>\n"
"    <connectionFactory>java:comp/env/jms/TopicConnectionFactory</connectionFactory>\n"
"    <myapp:StockPrices/>    \n"
"</Topic>]]>"
msgstr ""
"<![CDATA[<Topic>\n"
"    <destination>java:comp/env/jms/StockPrices</destination>\n"
"    <connectionFactory>java:comp/env/jms/TopicConnectionFactory</connectionFactory>\n"
"    <myapp:StockPrices/>    \n"
"</Topic>]]>"

#. Tag: para
#: ee.xml:90
#, no-c-format
msgid "Now we can just inject the <literal>Queue</literal>, <literal>QueueConnection</literal>, <literal>QueueSession</literal> or <literal>QueueSender</literal> for a queue, or the <literal>Topic</literal>, <literal>TopicConnection</literal>, <literal>TopicSession</literal> or <literal>TopicPublisher</literal> for a topic."
msgstr "现在，对于队列，我们只须注入 <literal>Queue</literal>, <literal>QueueConnection</literal>, <literal>QueueSession</literal> 或者 <literal>QueueSender</literal>；对于主题，我们只须注入<literal>Topic</literal>, <literal>TopicConnection</literal>, <literal>TopicSession</literal> 或者 <literal>TopicPublisher</literal>。"

#. Tag: programlisting
#: ee.xml:96
#, no-c-format
msgid ""
"@OrderProcessor QueueSender orderSender;\n"
"@OrderProcessor QueueSession orderSession;\n"
"\n"
"public void sendMessage() {\n"
"    MapMessage msg = orderSession.createMapMessage();\n"
"    ...\n"
"    orderSender.send(msg);\n"
"}"
msgstr ""
"@OrderProcessor QueueSender orderSender;\n"
"@OrderProcessor QueueSession orderSession;\n"
"\n"
"public void sendMessage() {\n"
"    MapMessage msg = orderSession.createMapMessage();\n"
"    ...\n"
"    orderSender.send(msg);\n"
"}"

#. Tag: programlisting
#: ee.xml:98
#, no-c-format
msgid ""
"@StockPrices TopicPublisher pricePublisher;\n"
"@StockPrices TopicSession priceSession;\n"
"\n"
"public void sendMessage(String price) {\n"
"    pricePublisher.send( priceSession.createTextMessage(price) );\n"
"}"
msgstr ""
"@StockPrices TopicPublisher pricePublisher;\n"
"@StockPrices TopicSession priceSession;\n"
"\n"
"public void sendMessage(String price) {\n"
"    pricePublisher.send( priceSession.createTextMessage(price) );\n"
"}"

#. Tag: para
#: ee.xml:100
#, no-c-format
msgid "The lifecycle of the injected JMS objects is completely controlled by the Web Bean manager."
msgstr "被注入的JMS对象的生命周期完全由Web Bean管理器控制。"

#. Tag: title
#: ee.xml:106
#, no-c-format
msgid "Packaging and deployment"
msgstr "打包和部署"

#. Tag: para
#: ee.xml:108
#, no-c-format
msgid "Web Beans doesn't define any special deployment archive. You can package Web Beans in JARs, EJB-JARs or WARs &#151; any deployment location in the application classpath. However, each archive that contains Web Beans must include a file named <literal>web-beans.xml</literal> in the <literal>META-INF</literal> or <literal>WEB-INF</literal> directory. The file may be empty. Web Beans deployed in archives that do not have a <literal>web-beans.xml</literal> file will not be available for use in the application."
msgstr "Web Beans并没有指定特殊的部署包。你可以以JAR, EJB-JAR或者WAR&#151;形式将Web Beans打包在任何应用类路径中的部署位置上。然而，每个包含Web Beans的包必须在<literal>META-INF</literal> 或者 <literal>WEB-INF</literal>目录下包含一个名为 <literal>web-beans.xml</literal>的配置文件。这个文件可以是空的。没有<literal>web-beans.xml</literal> 配置文件，应用将无法使用Web Beans。"

#. Tag: para
#: ee.xml:116
#, no-c-format
msgid "For Java SE execution, Web Beans may be deployed in any location in which EJBs may be deployed for execution by the embeddable EJB Lite container. Again, each location must contain a <literal>web-beans.xml</literal> file."
msgstr "对于Java SE，Web Beans可以被部署在由嵌入式EJB轻量容器支持的EJB中的任何位置。同样，该位置必须包含 <literal>web-beans.xml</literal> 配置文件。"

