# Language it-IT translations for master.xml package.
# Automatically generated, 2008.
#
msgid ""
msgstr ""
"Project-Id-Version: master.xml\n"
"Report-Msgid-Bugs-To: http://bugs.kde.org\n"
"POT-Creation-Date: 2008-12-19 20:26+0000\n"
"PO-Revision-Date: 2008-12-25 12:11+0100\n"
"Last-Translator: Nicola Benaglia <nico.benaz@gmail.com>\n"
"Language-Team: none\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#. Tag: title
#: intro.xml:4
#, no-c-format
msgid "Getting started with Web Beans"
msgstr "Iniziare con Web Beans"

# Rendere la frase "wondering what kinds of hoops the Web Beans specification will make you jump through!" più italiana.
#. Tag: para
#: intro.xml:6
#, no-c-format
msgid "So you're already keen to get started writing your first Web Bean? Or perhaps you're skeptical, wondering what kinds of hoops the Web Beans specification will make you jump through! The good news is that you've probably already written and used hundreds, perhaps thousands of Web Beans. You might not even remember the first Web Bean you wrote."
msgstr "Non vedi l'ora di iniziare a scrivere il primo Web Beans? O forse sei un pò scettico e ti domandi quali virtuosismi ti farà fare la specifica Web Beans! La buona notizia è che probabilmente hai già scritto e usato centinaia, forse migliaia di Web Beans. Potresti addirittura non ricordare il primo Web Bean scritto."

#. Tag: title
#: intro.xml:13
#, no-c-format
msgid "Your first Web Bean"
msgstr "Il primo Web Bean"

#. Tag: para
#: intro.xml:15
#, no-c-format
msgid "With certain, very special exceptions, every Java class with a constructor that accepts no parameters is a Web Bean. That includes every JavaBean. Furthermore, every EJB 3-style session bean is a Web Bean. Sure, the JavaBeans and EJBs you've been writing every day have not been able to take advantage of the new services defined by the Web Beans specification, but you'll be able to use every one of them as Web Beans &#151; injecting them into other Web Beans, configuring them via the Web Beans XML configuration facility, even adding interceptors and decorators to them &#151; without touching your existing code."
msgstr "Con alcune eccezioni molto particolari, ogni classe Java con un costruttore che non accetta parametri è un Web Bean. Questo include ogni JavaBean. Inoltre, ogni session bean di stile EJB3 è un Web Bean. Sicuramente i JavaBean e gli EJB3 che si sono sempre scritti non erano in grado di sfruttare i nuovi servizi definiti dalla specifica Web Beans, ma si sarà presto in grado di usare ciascuno di essi come Web Bean &#151; iniettandoli in altri Web Beans, configurandoli tramite strumenti di configurazione XML Web Bean, e perfino aggiungendo a loro interceptor e decoratori &#151; senza toccare il codice esistente."

#. Tag: para
#: intro.xml:25
#, no-c-format
msgid "Suppose that we have two existing Java classes, that we've been using for years in various applications. The first class parses a string into a list of sentences:"
msgstr "Si supponga di avere due classi Java esistenti, usate da anni in varie applicazioni. La prima classe esegue il parsing di una stringa in una lista di frasi:"

#. Tag: programlisting
#: intro.xml:29
#, no-c-format
msgid ""
"<![CDATA[public class SentenceParser {\n"
"    public List<String> parse(String text) { ... }\n"
"}]]>"
msgstr ""
"<![CDATA[public class SentenceParser {\n"
"    public List<String> parse(String text) { ... }\n"
"}]]>"

#. Tag: para
#: intro.xml:31
#, no-c-format
msgid "The second existing class is a stateless session bean front-end for an external system that is able to translate sentences from one language to another:"
msgstr "La seconda classe è un session bean stateless front-end per un sistema esterno capace di tradurre le frasi da una lingua ad un altra:"

#. Tag: programlisting
#: intro.xml:35
#, no-c-format
msgid ""
"<![CDATA[@Stateless\n"
"public class SentenceTranslator implements Translator {\n"
"    public String translate(String sentence) { ... }\n"
"}]]>"
msgstr ""
"<![CDATA[@Stateless\n"
"public class SentenceTranslator implements Translator {\n"
"    public String translate(String sentence) { ... }\n"
"}]]>"

#. Tag: para
#: intro.xml:37
#, no-c-format
msgid "Where <literal>Translator</literal> is the local interface:"
msgstr "Dove <literal>Translator</literal> è l'interfaccia locale:"

#. Tag: programlisting
#: intro.xml:39
#, no-c-format
msgid ""
"<![CDATA[@Local\n"
"public interface Translator {\n"
"    public String translate(String sentence);\n"
"}]]>"
msgstr ""
"<![CDATA[@Local\n"
"public interface Translator {\n"
"    public String translate(String sentence);\n"
"}]]>"

#. Tag: para
#: intro.xml:41
#, no-c-format
msgid "Unfortunately, we don't have a preexisting class that translates whole text documents. So let's write a Web Bean that does this job:"
msgstr "Sfortunatamente non ci sono classi preesistenti che traducano l'intero testo dei documenti. Quindi occorre scrivere un Web Bean che faccia questo lavoro:"

#. Tag: programlisting
#: intro.xml:44
#, no-c-format
msgid ""
"<![CDATA[public class TextTranslator {\n"
"    \n"
"    private SentenceParser sentenceParser;\n"
"    private Translator sentenceTranslator;\n"
"    \n"
"    @Initializer\n"
"    TextTranslator(SentenceParser sentenceParser, Translator sentenceTranslator) {\n"
"        this.sentenceParser = sentenceParser;\n"
"        this.sentenceTranslator = sentenceTranslator;\n"
"    }\n"
"    \n"
"    public String translate(String text) {\n"
"        StringBuilder sb = new StringBuilder();\n"
"        for (String sentence: sentenceParser.parse(text)) {\n"
"            sb.append(sentenceTranslator.translate(sentence));\n"
"        }\n"
"        return sb.toString();\n"
"    }\n"
"    \n"
"}]]>"
msgstr ""
"<![CDATA[public class TextTranslator {\n"
"    \n"
"    private SentenceParser sentenceParser;\n"
"    private Translator sentenceTranslator;\n"
"    \n"
"    @Initializer\n"
"    TextTranslator(SentenceParser sentenceParser, Translator sentenceTranslator) {\n"
"        this.sentenceParser = sentenceParser;\n"
"        this.sentenceTranslator = sentenceTranslator;\n"
"    }\n"
"    \n"
"    public String translate(String text) {\n"
"        StringBuilder sb = new StringBuilder();\n"
"        for (String sentence: sentenceParser.parse(text)) {\n"
"            sb.append(sentenceTranslator.translate(sentence));\n"
"        }\n"
"        return sb.toString();\n"
"    }\n"
"    \n"
"}]]>"

#. Tag: para
#: intro.xml:46
#, no-c-format
msgid "We may obtain an instance of <literal>TextTranslator</literal> by injecting it into a Web Bean, Servlet or EJB:"
msgstr "Si può ottenere un'istanza di <literal>TextTranslator</literal> iniettandolo in un Web Bean, Servlet o EJB:"

#. Tag: programlisting
#: intro.xml:49
#, no-c-format
msgid ""
"<![CDATA[@Initializer\n"
"public setTextTranslator(TextTranslator textTranslator) {\n"
"    this.textTranslator = textTranslator;\n"
"}]]>"
msgstr ""
"<![CDATA[@Initializer\n"
"public setTextTranslator(TextTranslator textTranslator) {\n"
"    this.textTranslator = textTranslator;\n"
"}]]>"

#. Tag: para
#: intro.xml:51
#, no-c-format
msgid "Alternatively, we may obtain an instance by directly calling a method of the Web Bean manager:"
msgstr "In alternativa si può ottenere un'istanza chiamando direttamente un metodo del manager Web Bean:"

#. Tag: programlisting
#: intro.xml:54
#, no-c-format
msgid "<![CDATA[TextTranslator tt = manager.getInstanceByType(TextTranslator.class);]]>"
msgstr "<![CDATA[TextTranslator tt = manager.getInstanceByType(TextTranslator.class);]]>"

#. Tag: para
#: intro.xml:56
#, no-c-format
msgid "But wait: <literal>TextTranslator</literal> does not have a constructor with no parameters! Is it still a Web Bean? Well, a class that does not have a constructor with no parameters can still be a Web Bean if it has a constructor annotated <literal>@Initializer</literal>."
msgstr "Ma <literal>TextTranslator</literal> non ha un costruttore con nessun parametro! E' ancora un Web Bean? Una classe che non ha un costruttore senza parametri può essere un Web Bean se il suo costruttore è annotato con <literal>@Initializer</literal>."

#. Tag: para
#: intro.xml:61
#, no-c-format
msgid "As you've guessed, the <literal>@Initializer</literal> annotation has something to do with dependency injection! <literal>@Initializer</literal> may be applied to a constructor or method of a Web Bean, and tells the Web Bean manager to call that constructor or method when instantiating the Web Bean. The Web Bean manager will inject other Web Beans to the parameters of the constructor or method."
msgstr "Come hai indovinato, l'annotazione <literal>@Initializer</literal> ha qualcosa che fare con la dependency injection! <literal>@Initializer</literal> può essere applicato ad un costruttore od un metodo di un Web Bean, e dice al manager Web Bean di chiamare quel costruttore o metodo quando si istanzia il Web Bean. Il manager Web Bean inietterà altri Web Bean nei parametri del costruttore o del metodo."

#. Tag: para
#: intro.xml:68
#, no-c-format
msgid "At system initialization time, the Web Bean manager must validate that exactly one Web Bean exists which satisfies each injection point. In our example, if no implementation of <literal>Translator</literal> available &#151; if the <literal>SentenceTranslator</literal> EJB was not deployed &#151; the Web Bean manager would throw an <literal>UnsatisfiedDependencyException</literal>. If more than one implementation of <literal>Translator</literal> was available, the Web Bean manager would throw an <literal>AmbiguousDependencyException</literal>."
msgstr "In fase di inizializzazione del sistema, il manager Web Bean deve convalidare che esattamente un solo Web Bean esista e soddisfi ciascun punto di iniezione. Nell'esempio, se nessuna implementazione di <literal>Translator</literal> fosse disponibile &#151; se l'EJB <literal>SentenceTranslator</literal> non venisse deployato &#151; il manager Web Bean lancerebbe una <literal>UnsatisfiedDependencyException</literal>. Se più di un'implementazione di <literal>Translator</literal> fosse disponibile, il manager Web Bean lancerebbe una <literal>AmbiguousDependencyException</literal>."

#. Tag: title
#: intro.xml:80
#, no-c-format
msgid "What is a Web Bean?"
msgstr "Cosa è un Web Bean?"

#. Tag: para
#: intro.xml:82
#, no-c-format
msgid "So what, <emphasis>exactly</emphasis>, is a Web Bean?"
msgstr "Ma cosa è <emphasis>esattamente</emphasis> un Web Bean?"

#. Tag: para
#: intro.xml:84
#, no-c-format
msgid "A Web Bean is an application class that contains business logic. A Web Bean may be called directly from Java code, or it may be invoked via Unified EL. A Web Bean may access transactional resources. Dependencies between Web Beans are managed automatically by the Web Bean manager. Most Web Beans are <emphasis>stateful</emphasis> and <emphasis>contextual</emphasis>. The lifecycle of a Web Bean is always managed by the Web Bean manager."
msgstr "Un Web Bean è una classe di un'applicazione che contiene della logica di business. Può essere chiamato direttamente da codice Java, o può essere invocato via Unified EL. Un Web Bean può accedere a risorse transazionali. Le dipendenze tra Web Beans sono gestite automaticamente dal manager Web Bean. La maggior parte dei Web Beans sono <emphasis>stateful</emphasis> e <emphasis>contestuali</emphasis>. Il ciclo di vita di un Web Bean è sempre gestito da un manager Web Bean."

#. Tag: para
#: intro.xml:91
#, no-c-format
msgid "Let's back up a second. What does it really mean to be \"contextual\"? Since Web Beans may be stateful, it matters <emphasis>which</emphasis> bean instance I have. Unlike a stateless component model (for example, stateless session beans) or a singleton component model (such as servlets, or singleton beans), different clients of a Web Bean see the Web Bean in different states. The client-visible state depends upon which instance of the Web Bean the client has a reference to."
msgstr "Torniamo indietro un attimo. Cosa significa veramente essere \"contestuale\"? Poiché Web Beans può essere stateful, è importante <emphasis>quale</emphasis> istanza di bean si ha. Diversamente da un modello a componenti stateless (per esempio, i session bean stateless) o un modello a componenti singleton (come i servlet o i bean singleton) i client di un Web Bean vedono il Web Bean in stati differenti. Lo stato del client visibile dipende dall'istanza del Web Bean alla quale il client ha il riferimento."

#. Tag: para
#: intro.xml:98
#, no-c-format
msgid "However, like a stateless or singleton model, but <emphasis>unlike</emphasis> stateful session beans, the client does not control the lifecycle of the instance by explicitly creating and destroying it. Instead, the <emphasis>scope</emphasis> of the Web Bean determines:"
msgstr "Comunque, in modo simile ad un modello stateless o singleton, ma <emphasis>non come</emphasis> i session bean stateful, il client non ha il controllo sul ciclo di vita dell'istanza, creandola e distruggendola esplicitamente. Invece, lo <emphasis>scope</emphasis> del Web Bean determina:"

#. Tag: para
#: intro.xml:105
#, no-c-format
msgid "the lifecycle of each instance of the Web Bean and"
msgstr "il ciclo di vita di ogni istanza del Web Bean e"

#. Tag: para
#: intro.xml:108
#, no-c-format
msgid "which clients share a reference to a particular instance of the Web Bean."
msgstr "quali client condividono una referenza con una particolare istanza del Web Bean."

#. Tag: para
#: intro.xml:113
#, no-c-format
msgid "For a given thread in a Web Beans application, there may be an <emphasis>active context</emphasis> associated with the scope of the Web Bean. This context may be unique to the thread (for example, if the Web Bean is request scoped), or it may be shared with certain other threads (for example, if the Web Bean is session scoped) or even all other threads (if it is application scoped)."
msgstr "Per un dato thread in un'applicazione Web Beans, ci può essere un <emphasis>contesto attivo</emphasis> associato allo scope del Web Bean. Questo contesto può essere univoco nel thread (per esempio, se il Web Bean è con scope di richesta), o può essere condiviso con alcuni altri thread (per esempio, se il Web Bean è con scope di sessione) od anche tutti gli altri thread (se è scope di applicazione). "

#. Tag: para
#: intro.xml:119
#, no-c-format
msgid "Clients (for example, other Web Beans) executing in the same context will see the same instance of the Web Bean. But clients in a different context will see a different instance."
msgstr "I client (per esempio, altri Web Beans) che sono in esecuzione nello stesso contesto vedranno la stessa istanza del Web Bean. Ma i client in un contesto diverso vedranno un istanza diversa."

#. Tag: para
#: intro.xml:123
#, no-c-format
msgid "One great advantage of the contextual model is that it allows stateful Web Beans to be treated like services! The client need not concern itself with managing the lifecycle of the Web Bean it is using, <emphasis>nor does it even need to know what that lifecyle is.</emphasis> Web Beans interact by passing messages, and the Web Bean implementations define the lifecycle of their own state. The Web Beans are loosely coupled because:"
msgstr "Un grande vantaggio del modello contestuale è che consente ai Web Beans stateful di essere trattati come servizi! Il client non deve preoccuparsi di gestire il ciclo di vita del Web Bean che sta utilizzando, <emphasis>e neppure deve sapere quale sia il ciclo di vita.</emphasis> Web Beans interagisce passando i messaggi, e le implementazioni Web Bean definiscono il ciclo di vita del proprio stato. I Web Beans sono debolmente disaccoppiati (loosely coupled) poiché:"

#. Tag: para
#: intro.xml:132
#, no-c-format
msgid "they interact via well-defined public APIs"
msgstr "interagiscono tramite delle API pubblica ben-definita"

#. Tag: para
#: intro.xml:135
#, no-c-format
msgid "their lifecycles are completely decoupled"
msgstr "il loro ciclo di vita è completamente disaccoppiato"

#. Tag: para
#: intro.xml:139
#, no-c-format
msgid "We can replace one Web Bean with a different Web Bean that implements the same API and has a different lifecycle (a different scope) without affecting the other Web Bean implementation. In fact, Web Beans defines a sophisticated facility for overriding Web Bean implementations at deployment time, as we will see in <xref linkend=\"deploymenttypes\"/>."
msgstr "Si può sostituire un Web Bean con un diverso Web Bean che implementa la stessa API ed ha un diverso ciclo di vita (un diverso scope) senza alterare l'implementazione dell'altro Web Bean. Infatti Web Beans definisce un meccanismo sofisticato per fare l'override delle implementazioni Web Bean al momento del deploy, come visto in <xref linkend=\"deploymenttypes\"/>."

#. Tag: para
#: intro.xml:145
#, no-c-format
msgid "Note that not all clients of a Web Bean are Web Beans. Other objects such as Servlets or Message-Driven Beans &#151; which are by nature not injectable, contextual objects &#151; may also obtain references to Web Beans by injection."
msgstr "Si noti che non tutti i client dei un Web Bean sono Web Bean. Altri oggetti come Servlet o Message-Driven Beans &#151; che sono per natura non iniettabili, oggetti contestuali &#151; possono pure ottenere riferimenti a Web Bean tramite iniezione."

# Tolto "Enough hand-waving."
#. Tag: para
#: intro.xml:149
#, no-c-format
msgid "Enough hand-waving. More formally, according to the spec:"
msgstr "Più formalmente, secondo la specifica:"

#. Tag: para
#: intro.xml:153
#, no-c-format
msgid "A Web Bean comprises:"
msgstr "Un Web Bean comprende:"

#. Tag: para
#: intro.xml:156
#, no-c-format
msgid "A (nonempty) set of API types"
msgstr "Un set (non vuoto) di tipi di API"

#. Tag: para
#: intro.xml:157
#, no-c-format
msgid "A (nonempty) set of binding annotation types"
msgstr "Un set (non vuoto) di tipi di annotazione di binding"

#. Tag: para
#: intro.xml:158
#, no-c-format
msgid "A scope"
msgstr "Uno scope"

#. Tag: para
#: intro.xml:159
#, no-c-format
msgid "A deployment type"
msgstr "Un tipo di deploy"

#. Tag: para
#: intro.xml:160
#, no-c-format
msgid "Optionally, a Web Bean name"
msgstr "Opzionalmente un nome Web Bean"

#. Tag: para
#: intro.xml:161
#, no-c-format
msgid "A set of interceptor binding types"
msgstr "Un set di tipi di interceptor binding"

#. Tag: para
#: intro.xml:162
#, no-c-format
msgid "A Web Bean implementation"
msgstr "Un implementazione Web Bean"

#. Tag: para
#: intro.xml:167
#, no-c-format
msgid "Let's see what some of these terms mean, to the Web Bean developer."
msgstr "Vediamo cosa significano alcuni di questi termini per lo sviluppatore Web Bean."

#. Tag: title
#: intro.xml:170
#, no-c-format
msgid "API types, binding types and dependency injection"
msgstr "Tipi di API, tipi di binding e dependency injection"

#. Tag: para
#: intro.xml:172
#, no-c-format
msgid "Web Beans usually acquire references to other Web Beans via dependency injection. Any injected attribute specifies a \"contract\" that must be satisfied by the Web Bean to be injected. The contract is:"
msgstr "I Web Bean solitamente acquisiscono riferimenti ad altri Web Bean tramite la dependency injection. Ogni attributo iniettato specifica un \"contratto\" che deve essere soddisfatto dal Web Bean per essere iniettato. Il contratto è:"

#. Tag: para
#: intro.xml:177
#, no-c-format
msgid "an API type, together with"
msgstr "un tipo di API, assieme a"

#. Tag: para
#: intro.xml:178
#, no-c-format
msgid "a set of binding types."
msgstr "un set di tipi di binding."

# client-visible semantic  =?
#. Tag: para
#: intro.xml:181
#, no-c-format
msgid "An API is a user-defined class or interface. (If the Web Bean is an EJB session bean, the API type is the <literal>@Local</literal> interface or bean-class local view). A binding type represents some client-visible semantic that is satisfied by some implementations of the API and not by others."
msgstr "Un API è una classe o interfaccia definita dall'utente. (Se il Web Bean è un session bean EJB, il tipo di API è l'interfaccia <literal>@Local</literal> o la vista locale della classe-bean). Un tipo di binding rappresenta un semantica del client che è soddisfatta da certe implementazioni dell'API e non da altre."

#. Tag: para
#: intro.xml:186
#, no-c-format
msgid "Binding types are represented by user-defined annotations that are themselves annotated <literal>@BindingType</literal>. For example, the following injection point has API type <literal>PaymentProcessor</literal> and binding type <literal>@CreditCard</literal>:"
msgstr "I tipi di binding sono rappresentati da annotazioni definite dall'utente che sono loro stesse annotate con <literal>@BindingType</literal>. Per esempio, il seguente punto di iniezione ha un tipo di API <literal>PaymentProcessor</literal> ed un tipo di binding <literal>@CreditCard</literal>:"

#. Tag: programlisting
#: intro.xml:191
#, no-c-format
msgid "<![CDATA[@CreditCard PaymentProcessor paymentProcessor]]>"
msgstr "<![CDATA[@CreditCard PaymentProcessor paymentProcessor]]>"

#. Tag: para
#: intro.xml:193
#, no-c-format
msgid "If no binding type is explicitly specified at an injection point, the default binding type <literal>@Current</literal> is assumed."
msgstr "Se nessun tipo di binding viene specificato in modo esplicito ad un punto di iniezione, il tipo di binding di default si assume essere <literal>@Current</literal>."

#. Tag: para
#: intro.xml:196
#, no-c-format
msgid "For each injection point, the Web Bean manager searches for a Web Bean which satisfies the contract (implements the API, and has all the binding types), and injects that Web Bean."
msgstr "Per ogni punto di iniezione, il manager Web Bean cerca un Web Bean che soddisfi il contratto (che implementi la API, e che abbia tutti i tipi di binding), ed inietta tale Web Bean."

#. Tag: para
#: intro.xml:200
#, no-c-format
msgid "The following Web Bean has the binding type <literal>@CreditCard</literal> and implements the API type <literal>PaymentProcessor</literal>. It could therefore be injected to the example injection point:"
msgstr "Il seguente Web Bean ha il tipo binding <literal>@CreditCard</literal> e implementa il tipo API <literal>PaymentProcessor</literal>. Può quindi essere iniettato nel punto di iniezione d'esempio:"

#. Tag: programlisting
#: intro.xml:204
#, no-c-format
msgid ""
"<![CDATA[@CreditCard\n"
"public class CreditCardPaymentProcessor \n"
"    implements PaymentProcessor { ... }]]>"
msgstr ""
"<![CDATA[@CreditCard\n"
"public class CreditCardPaymentProcessor \n"
"    implements PaymentProcessor { ... }]]>"

#. Tag: para
#: intro.xml:206
#, no-c-format
msgid "If a Web Bean does not explicitly specify a set of binding types, it has exactly one binding type: the default binding type <literal>@Current</literal>."
msgstr "Se un Web Bean non specifica esplicitamente un set di tipi di binding, ha esattamente un solo tipo di binding: il tipo di binding di default <literal>@Current</literal>."

#. Tag: para
#: intro.xml:209
#, no-c-format
msgid "Web Beans defines a sophisticated but intuitive <emphasis>resolution algorithm</emphasis> that helps the container decide what to do if there is more than one Web Bean that satisfies a particular contract. We'll get into the details in <xref linkend=\"injection\"/>."
msgstr "Web Beans definisce un <emphasis>algoritmo di risoluzione</emphasis> sofisticato ma intuitivo che aiuta il container a decidere cosa fare se più di un Web Bean soddisfa un particolare contratto. Vedremo i dettagli in <xref linkend=\"injection\"/>."

#. Tag: title
#: intro.xml:217
#, no-c-format
msgid "Deployment types"
msgstr "Tipi di deploy"

#. Tag: para
#: intro.xml:219
#, no-c-format
msgid "<emphasis>Deployment types</emphasis> let us classify our Web Beans by deployment scenario. A deployment type is an annotation that represents a particular deployment scenario, for example <literal>@Mock</literal>, <literal>@Staging</literal> or <literal>@AustralianTaxLaw</literal>. We apply the annotation to Web Beans which should be deployed in that scenario. A deployment type allows a whole set of Web Beans to be conditionally deployed, with a just single line of configuration."
msgstr "<emphasis>I tipi di deploy</emphasis> consentono di classificare i Web Bean secondo uno scenario di deploy. Un tipo di deploy è un'annotazione che rappresenta un particolare scenario di deploy, per esempio <literal>@Mock</literal>, <literal>@Staging</literal> oppure <literal>@AustralianTaxLaw</literal>. Si applica l'annotazione ai Web Bean che dovrebbero essere deployati in tale scenario. Un tipo di deploy consente ad un intero set di Web Bean di essere deployati in modo condizionato, con una sola linea di configurazione."

#. Tag: para
#: intro.xml:226
#, no-c-format
msgid "Many Web Beans just use the default deployment type <literal>@Production</literal>, in which case no deployment type need be explicitly specified. All three Web Bean in our example have the deployment type <literal>@Production</literal>."
msgstr "Molti Web Bean usano soltanto il tipo di deploy di default <literal>@Production</literal>, ed in questo caso non occorre specificare esplicitamente nessun tipo di deploy. Tutti e tre i Web Bean d'esempio hanno ul tipo di deploy <literal>@Production</literal>. "

#. Tag: para
#: intro.xml:230
#, no-c-format
msgid "In a testing environment, we might want to replace the <literal>SentenceTranslator</literal> Web Bean with a \"mock object\":"
msgstr "In un ambiente di test è possibile sostituire il Web Bean <literal>SentenceTranslator</literal> con un \"oggetto mock\":"

#. Tag: programlisting
#: intro.xml:233
#, no-c-format
msgid ""
"<![CDATA[@Mock\n"
"public class MockSentenceTranslator implements Translator {\n"
"    public String translate(String sentence) {\n"
"        return \"Lorem ipsum dolor sit amet\";\n"
"    }\n"
"}]]>"
msgstr ""
"<![CDATA[@Mock\n"
"public class MockSentenceTranslator implements Translator {\n"
"    public String translate(String sentence) {\n"
"        return \"Lorem ipsum dolor sit amet\";\n"
"    }\n"
"}]]>"

#. Tag: para
#: intro.xml:236
#, no-c-format
msgid "We would enable the deployment type <literal>@Mock</literal> in our testing environment, to indicate that <literal>MockSentenceTranslator</literal> and any other Web Bean annotated <literal>@Mock</literal> should be used."
msgstr "In ambiente di test si dovrebbe abilitare il tipo di deploy <literal>@Mock</literal> per indicare che l'uso di <literal>MockSentenceTranslator</literal> ed ogni altro Web Bean annotato con <literal>@Mock</literal>."

#. Tag: para
#: intro.xml:240
#, no-c-format
msgid "We'll talk more about this unique and powerful feature in <xref linkend=\"deploymenttypes\"/>."
msgstr "Si discuterà questa potente funzionalità con maggior dettaglio in <xref linkend=\"deploymenttypes\"/>.\" "

#. Tag: title
#: intro.xml:246
#, no-c-format
msgid "Scope"
msgstr "Scope"

# arbitrary scope è corretto "scope arbitrari" ?
#. Tag: para
#: intro.xml:248
#, no-c-format
msgid "The <emphasis>scope</emphasis> defines the lifecycle and visibility of instances of the Web Bean. The Web Beans context model is extensible, accommodating arbitrary scopes. However, certain important scopes are built-in to the specification, and provided by the Web Bean manager. A scope is represented by an annotation type."
msgstr "Lo <emphasis>scope</emphasis> definisce il ciclo di vita e la visibilità delle istanze di Web Bean. Il modello di contesto Web Bean è estensibile e facilita gli scope arbitrari. Comunque alcuni importanti scope sono predefiniti all'internodella specifica e vengono forniti dal manager Web Bean. Uno scope è rapresentato da un tipo di annotazione."

#. Tag: para
#: intro.xml:254
#, no-c-format
msgid "For example, any web application may have <emphasis>session scoped</emphasis> Web Beans:"
msgstr "Per esempio un'applicazione web può avere Web Bean con <emphasis>scope di sessione</emphasis>"

#. Tag: programlisting
#: intro.xml:257
#, no-c-format
msgid ""
"<![CDATA[@SessionScoped\n"
"public class ShoppingCart { ... }]]>"
msgstr ""
"<![CDATA[@SessionScoped\n"
"public class ShoppingCart { ... }]]>"

#. Tag: para
#: intro.xml:259
#, no-c-format
msgid "An instance of a session scoped Web Bean is bound to a user session and is shared by all requests that execute in the context of that session."
msgstr "Un'istanza di un Web Bean con scope sessione è legato ad una sessione utente ed è condivisa da tutte le richieste che si eseguono nel contesto di tale sessione."

#. Tag: para
#: intro.xml:262
#, no-c-format
msgid "By default, Web Beans belong to a special scope called the <emphasis>dependent pseudo-scope</emphasis>. Web Beans with this scope are pure dependent objects of the object into which they are injected, and their lifecycle is bound to the lifecycle of that object."
msgstr "Di default i Web Bean appartengono ad uno speciale scope chiamato <emphasis>pseudo-scope dipendente</emphasis>. Web Bean con questo scope sono oggetti puri dipendenti dall'oggetto nel quale vengono iniettati ed il loro ciclo di vita è legato al ciclo di vita di tale oggetto."

#. Tag: para
#: intro.xml:267
#, no-c-format
msgid "We'll talk more about scopes in <xref linkend=\"scopescontexts\"/>."
msgstr "Approfondiremo gli scope in <xref linkend=\"scopescontexts\"/>."

#. Tag: title
#: intro.xml:272
#, no-c-format
msgid "Web Bean names and Unified EL"
msgstr "Nomi Web Bean e Unified EL"

#. Tag: para
#: intro.xml:274
#, no-c-format
msgid "A Web Bean may have a <emphasis>name</emphasis>, allowing it to be used in Unified EL expressions. It's easy to specify the name of a Web Bean:"
msgstr "Un Web Bean può avere un <emphasis>nome</emphasis> che gli consente di essere usato in un'espressione Unified EL. E' facile specificare il nome del Web Bean:"

#. Tag: programlisting
#: intro.xml:278
#, no-c-format
msgid ""
"<![CDATA[@SessionScoped @Named(\"cart\")\n"
"public class ShoppingCart { ... }]]>"
msgstr ""
"<![CDATA[@SessionScoped @Named(\"cart\")\n"
"public class ShoppingCart { ... }]]>"

#. Tag: para
#: intro.xml:280
#, no-c-format
msgid "Now we can easily use the Web Bean in any JSF or JSP page:"
msgstr "Ora si può facilmente utilizzare il Web Bean in ogni pagina JSF o JSP:"

#. Tag: programlisting
#: intro.xml:282
#, no-c-format
msgid ""
"<![CDATA[<h:dataTable value=\"#{cart.lineItems}\" var=\"item\">\n"
"    ....\n"
"</h:dataTable>]]>"
msgstr ""
"<![CDATA[<h:dataTable value=\"#{cart.lineItems}\" var=\"item\">\n"
"    ....\n"
"</h:dataTable>]]>"

#. Tag: para
#: intro.xml:284
#, no-c-format
msgid "It's even easier to just let the name be defaulted by the Web Bean manager:"
msgstr "Si può anche lasciare assegnare al manager Web Bean il nome di default:"

#. Tag: programlisting
#: intro.xml:287
#, no-c-format
msgid ""
"<![CDATA[@SessionScoped @Named\n"
"public class ShoppingCart { ... }]]>"
msgstr ""
"<![CDATA[@SessionScoped @Named\n"
"public class ShoppingCart { ... }]]>"

#. Tag: para
#: intro.xml:289
#, no-c-format
msgid "In this case, the name defaults to <literal>shoppingCart</literal> &#151; the unqualified class name, with the first character changed to lowercase."
msgstr "In questo caso il nome di default è <literal>shoppingCart</literal> &#151; il nome della classe non qualificata, con il primo carattere messo in minuscolo."

#. Tag: title
#: intro.xml:295
#, no-c-format
msgid "Interceptor binding types"
msgstr "Tipi di interceptor binding"

#. Tag: para
#: intro.xml:297
#, no-c-format
msgid "Web Beans supports the interceptor functionality defined by EJB 3, not only for EJB beans, but also for plain Java classes. In addition, Web Beans provides a new approach to binding interceptors to EJB beans and other Web Beans."
msgstr "Web Beans supporta la funzionalità di interceptor definita da EJB 3, non solo per i bean EJB, ma anche per classi Java semplici (plain). In aggiunta, Web Beans fornisce un nuovo approccio al binding di interceptor nei confronti di bean EJB e di altri Web Beans."

#. Tag: para
#: intro.xml:302
#, no-c-format
msgid "It remains possible to directly specify the interceptor class via use of the <literal>@Interceptors</literal> annotation:"
msgstr "Rimane la possibilità di specificare direttamente la classe interceptor tramite l'uso dell'annotazione <literal>@Interceptors</literal>."

#. Tag: programlisting
#: intro.xml:305
#, no-c-format
msgid ""
"<![CDATA[@SessionScoped \n"
"@Interceptors(TransactionInterceptor.class)\n"
"public class ShoppingCart { ... }]]>"
msgstr ""
"<![CDATA[@SessionScoped \n"
"@Interceptors(TransactionInterceptor.class)\n"
"public class ShoppingCart { ... }]]>"

# indirect = ?
#. Tag: para
#: intro.xml:307
#, no-c-format
msgid "However, it is more elegant, and better practice, to indirect the interceptor binding through an <emphasis>interceptor binding type</emphasis>:"
msgstr "Comunque è più elegante ed è considerata una pratica migliore quella di giungere indirettamente ad un interceptor binding tramite un <emphasis>tipo di interceptor binding</emphasis>:"

#. Tag: programlisting
#: intro.xml:311
#, no-c-format
msgid ""
"<![CDATA[@SessionScoped @Transactional\n"
"public class ShoppingCart { ... }]]>"
msgstr ""
"<![CDATA[@SessionScoped @Transactional\n"
"public class ShoppingCart { ... }]]>"

#. Tag: para
#: intro.xml:313
#, no-c-format
msgid "We'll discuss Web Beans interceptors and decorators in <xref linkend=\"interceptors\"/> and <xref linkend=\"decorators\"/>."
msgstr "Si discuteranno gli interceptor e i decoratori di Web BEans in <xref linkend=\"interceptors\"/> e <xref linkend=\"decorators\"/>."

#. Tag: title
#: intro.xml:321
#, no-c-format
msgid "What kinds of objects can be Web Beans?"
msgstr "Quali tipi di oggetti possono essere Web Beans?"

#. Tag: para
#: intro.xml:323
#, no-c-format
msgid "We've already seen that JavaBeans, EJBs and some other Java classes can be Web Beans. But exactly what kinds of objects are Web Beans?"
msgstr "Si è già visto che JavaBeans, EJB ed altri tipi di classi Java possono essere Web Bean. Ma esattamente quali tipi di oggetti sono Web Beans?"

#. Tag: title
#: intro.xml:327
#, no-c-format
msgid "Simple Web Beans"
msgstr "Web Beans Semplici"

#. Tag: para
#: intro.xml:329
#, no-c-format
msgid "The Web Beans specification says that a concrete Java class is a <emphasis>simple</emphasis> Web Bean if:"
msgstr "La specifica Web Beans dice che una classe concreta Java è un Web Bean <emphasis>semplice</emphasis> se:"

#. Tag: para
#: intro.xml:334
#, no-c-format
msgid "it is not an EE container-managed component, like an EJB, a Servlet or a JPA entity,"
msgstr "Non è un componente gestito da un container EE, come EJB, un Servlet o un entity JPA,"

#. Tag: para
#: intro.xml:338
#, no-c-format
msgid "it is not a non-static static inner class,"
msgstr "non è una classe interna statica/non statica,"

#. Tag: para
#: intro.xml:341
#, no-c-format
msgid "it is not a parameterized type, and"
msgstr "non è un tipo parametrizzato, e"

#. Tag: para
#: intro.xml:344
#, no-c-format
msgid "it has a constructor with no parameters, or a constructor annotated <literal>@Initializer</literal>."
msgstr "ha un costruttore senza parametro, o un costruttore annotato con <literal>@Initializer</literal>."

#. Tag: para
#: intro.xml:349
#, no-c-format
msgid "Thus, almost every JavaBean is a simple Web Bean."
msgstr "Quindi quasi ogni JavaBean è un Web Bean semplice."

#. Tag: para
#: intro.xml:351
#, no-c-format
msgid "Every interface implemented directly or indirectly by a simple Web Bean is an API type of the simple Web Bean. The class and its superclasses are also API types."
msgstr "Ogni interfaccia implementata direttamente o indirettamente da un Web Bean semplice è un tipo di API di un Web Bean semplice. La classe e le sue superclassi sono anch'essere tipi di API."

#. Tag: title
#: intro.xml:358
#, no-c-format
msgid "Enterprise Web Beans"
msgstr "Web Bean Enterprise"

#. Tag: para
#: intro.xml:360
#, no-c-format
msgid "The specification says that all EJB 3-style session and singleton beans are <emphasis>enterprise</emphasis> Web Beans. Message driven beans are not Web Beans &#151; since they are not intended to be injected into other objects &#151; but they can take advantage of most of the functionality of Web Beans, including dependency injection and interceptors."
msgstr "La specifica dice che tutti i bean di sessione stile EJB3 e quelli singleton sono Web Bean <emphasis>enterprise</emphasis>. I bean message driven non sono Web Bean &#151; poiché non sono intesi per essere iniettati in altri oggetti &#151; ma possono sfruttare la maggior parte della funzionalità dei Web Bean, inclusi dependency injection e interceptor."

# bean class local view = ?
#. Tag: para
#: intro.xml:366
#, no-c-format
msgid "Every local interface of an enterprise Web Bean that does not have a wildcard type parameter or type variable, and every one of its superinterfaces, is an API type of the enterprise Web Bean. If the EJB bean has a bean class local view, the bean class, and every one of its superclasses, is also an API type."
msgstr "Ogni interfaccia locale di un Web Bean enterprise che non ha un parametro tipo wildcard o variabile tipo, e ciascuna delle sue superinterfacce, è un tipo di API del Web Bean enterprise. Se il bean EJB ha una vista locale di classe bean, la classe bean e ogni sua superclasse è anch'essa un tipo di API."

#. Tag: para
#: intro.xml:372
#, no-c-format
msgid "Stateful session beans should declare a remove method with no parameters or a remove method annotated <literal>@Destructor</literal>. The Web Bean manager calls this method to destroy the stateful session bean instance at the end of its lifecycle. This method is called the <emphasis>destructor</emphasis> method of the enterprise Web Bean."
msgstr "I session bean stateful dovrebbero dichiarare un metodo remoto senza parametri od un metodo annotato con <literal>@Destructor</literal>. Il manager Web Bean chiama questo metodo per distruggere l'istanza del session bean statefull alla fine del suo ciclo di vita. Questo metodo è chiamato metodo <emphasis>distruttore</emphasis> del Web Bean enterprise."

#. Tag: programlisting
#: intro.xml:378
#, no-c-format
msgid ""
"<![CDATA[@Stateful @SessionScoped\n"
"public class ShoppingCart {\n"
"\n"
"    ...\n"
"    \n"
"    @Remove\n"
"    public void destroy() {}\n"
"\n"
"}]]>"
msgstr ""
"<![CDATA[@Stateful @SessionScoped\n"
"public class ShoppingCart {\n"
"\n"
"    ...\n"
"    \n"
"    @Remove\n"
"    public void destroy() {}\n"
"\n"
"}]]>"

#. Tag: para
#: intro.xml:380
#, no-c-format
msgid "So when should we use an enterprise Web Bean instead of a simple Web Bean? Well, whenever we need the advanced enterprise services offered by EJB, such as:"
msgstr "Ma allora quando occorre usare un Web Bean enterprise invece di un Web Bean semplice? Quando occorrono servizi enterprise avanzati offerti da EJB, quali:"

#. Tag: para
#: intro.xml:387
#, no-c-format
msgid "method-level transaction management and security,"
msgstr "gestione delle transazioni a livello di metodo e sicurezza,"

#. Tag: para
#: intro.xml:390
#, no-c-format
msgid "concurrency management,"
msgstr "gestione della concorrenza,"

#. Tag: para
#: intro.xml:393
#, no-c-format
msgid "instance-level passivation for stateful session beans and instance-pooling for stateless session beans,"
msgstr "passivazione a livello di istanza per session bean stateful e pooling di istanze per session bean stateless,"

#. Tag: para
#: intro.xml:397
#, no-c-format
msgid "remote and web service invocation, and"
msgstr "invocazione remota e web service, e"

#. Tag: para
#: intro.xml:400
#, no-c-format
msgid "timers and asynchronous methods,"
msgstr "timer e metodi asincroni,"

#. Tag: para
#: intro.xml:404
#, no-c-format
msgid "we should use an enterprise Web Bean. When we don't need any of these things, a simple Web Bean will serve just fine."
msgstr "si dovrebbe usare un Web Bean enterprise. Quando non occorrono queste cose, va bene utilizzare un Web Bean semplice."

#. Tag: para
#: intro.xml:407
#, no-c-format
msgid "Many Web Beans (including any session or application scoped Web Bean) are available for concurrent access. Therefore, the concurrency management provided by EJB 3.1 is especially useful. Most session and application scoped Web Beans should be EJBs."
msgstr "Molti Web Bean (inclusi Web Bean con scope di sessione o applicazione) sono disponibili per accessi concorrenti. Quindi la gestione della concorrenza fornita da EJB3.1 è molto utile. La maggior parte dei Web Bean con scope sessione e applicazione dovrebbero essere EJB."

# internal state benefit =?
#. Tag: para
#: intro.xml:412
#, no-c-format
msgid "Web Beans which hold references to heavy-weight resources, or hold a lot of internal state benefit from the advanced container-managed lifecycle defined by the EJB <literal>@Stateless</literal>/<literal>@Stateful</literal>/<literal>@Singleton</literal> model, with its support for passivation and instance pooling."
msgstr "Web Bean che mantengono riferimenti alle risorse pesanti o mantengono molti benefici dello stato interno dal ciclo di vita avanzato, gestito dal container, definito dal modello EJB <literal>@Stateless</literal>/<literal>@Stateful</literal>/<literal>@Singleton</literal>\", con supporto alla passivazione e pooling delle istanze."

#. Tag: para
#: intro.xml:417
#, no-c-format
msgid "Finally, it's usually obvious when method-level transaction management, method-level security, timers, remote methods or asynchronous methods are needed."
msgstr "Infine è ovvio quando occorre usare la gestione delle transazioni a livello di metodo, la sicurezza a livello di metoto, i timer, i metodi remoti o i metodi asincroni."

#. Tag: para
#: intro.xml:420
#, no-c-format
msgid "It's usually easy to start with simple Web Bean, and then turn it into an EJB, just by adding an annotation: <literal>@Stateless</literal>, <literal>@Stateful</literal> or <literal>@Singleton</literal>."
msgstr "E' facile iniziare con un Web Bean semplice e poi volgere a EJB semplicemente aggiungendo l'annotazione: <literal>@Stateless</literal>, <literal>@Stateful</literal> o <literal>@Singleton</literal>."

#. Tag: title
#: intro.xml:427
#, no-c-format
msgid "Producer methods"
msgstr "Metodi produttori"

#. Tag: para
#: intro.xml:429
#, no-c-format
msgid "A <emphasis>producer method</emphasis> is a method that is called by the Web Bean manager to obtain an instance of the Web Bean when no instance exists in the current context. A producer method lets the application take full control of the instantiation process, instead of leaving instantiation to the Web Bean manager. For example:"
msgstr "Un <emphasis>metodo produttore</emphasis> è un metodo che viene chiamato dal manager Web Bean per ottenere un'istanza di un Web Bean quando non esiste alcuna istanza nel contesto corrente. Un metodo produttore lascia all'applicazione il pieno controllo del processo di istanziamento, invece di lasciare l'istanziamento al manager Web Bean. Per esempio:"

#. Tag: programlisting
#: intro.xml:435
#, no-c-format
msgid ""
"<![CDATA[@ApplicationScoped\n"
"public class Generator {\n"
"\n"
"    private Random random = new Random( System.currentTimeMillis() );\n"
"    \n"
"    @Produces @Random int next() {\n"
"        return random.nextInt(100);\n"
"    }\n"
"\n"
"}]]>"
msgstr ""
"<![CDATA[@ApplicationScoped\n"
"public class Generator {\n"
"\n"
"    private Random random = new Random( System.currentTimeMillis() );\n"
"    \n"
"    @Produces @Random int next() {\n"
"        return random.nextInt(100);\n"
"    }\n"
"\n"
"}]]>"

#. Tag: para
#: intro.xml:437
#, no-c-format
msgid "The result of a producer method is injected just like any other Web Bean."
msgstr "Il risultato del metodo produttore è iniettato come qualsiasi altro Web Bean."

#. Tag: programlisting
#: intro.xml:439
#, no-c-format
msgid "<![CDATA[@Random int randomNumber]]>"
msgstr "<![CDATA[@Random int randomNumber]]>"

#. Tag: para
#: intro.xml:441
#, no-c-format
msgid "The method return type and all interfaces it extends/implements directly or indirectly are API types of the producer method. If the return type is a class, all superclasses are also API types."
msgstr "Il tipo di ritorno del metodo e tutte le interfacce che estende/implementa direttamente o indirettamente sono tipi di API del metodo produttore. Se il tipo di ritorno è una classe, tutte le superclassi sono anch'esse tipi di API."

#. Tag: para
#: intro.xml:445
#, no-c-format
msgid "Some producer methods return objects that require explicit destruction:"
msgstr "Alcuni metodi produttori restituiscono oggetti che richiedono una distruzione esplicita:"

#. Tag: programlisting
#: intro.xml:447
#, no-c-format
msgid ""
"<![CDATA[@Produces @RequestScoped Connection connect(User user) {\n"
"    return createConnection( user.getId(), user.getPassword() );\n"
"}]]>"
msgstr ""
"<![CDATA[@Produces @RequestScoped Connection connect(User user) {\n"
"    return createConnection( user.getId(), user.getPassword() );\n"
"}]]>"

#. Tag: para
#: intro.xml:449
#, no-c-format
msgid "These producer methods may define matching <emphasis>disposal methods</emphasis>:"
msgstr "Questi metodi produttori possono definire corrispondenti <emphasis>metodi distruttori</emphasis>:\""

#. Tag: programlisting
#: intro.xml:451
#, no-c-format
msgid ""
"<![CDATA[void close(@Disposes Connection connection) {\n"
"    connection.close();\n"
"}]]>"
msgstr ""
"<![CDATA[void close(@Disposes Connection connection) {\n"
"    connection.close();\n"
"}]]>"

#. Tag: para
#: intro.xml:453
#, no-c-format
msgid "This disposal method is called automatically by the Web Bean manager at the end of the request."
msgstr "Il metodo distruttore è chiamato direttamente dal manager Web Bean alla fine della richiesta."

#. Tag: para
#: intro.xml:456
#, no-c-format
msgid "We'll talk much more about producer methods in <xref linkend=\"producermethods\"/>."
msgstr "Si parlerà in maggior dettaglio dei metodi produttori in <xref linkend=\"producermethods\"/>."

#. Tag: title
#: intro.xml:461
#, no-c-format
msgid "JMS endpoints"
msgstr "Endpoint JMS"

#. Tag: para
#: intro.xml:463
#, no-c-format
msgid "Finally, a JMS queue or topic can be a Web Bean. Web Beans relieves the developer from the tedium of managing the lifecycles of all the various JMS objects required to send messages to queues and topics. We'll discuss JMS endpoints in <xref linkend=\"jms\"/>."
msgstr "Infine una coda od un topic JMS possono essere Web Bean. Web Beans solleva lo sviluppatore dalla noia della gestione dei cicli di vita di tutti i vari oggetti JMS richiesto per inviare messaggi a code o topic. Si discuteranno gli endpoint JMS in <xref linkend=\"jms\"/>."

