# Language ja-JP translations for master.xml package.
# Automatically generated, 2008.
#
msgid ""
msgstr ""
"Project-Id-Version: master.xml\n"
"Report-Msgid-Bugs-To: http://bugs.kde.org\n"
"POT-Creation-Date: 2009-04-19 20:36+0000\n"
"PO-Revision-Date: 2009-06-09 03:50+0900\n"
"Last-Translator: Shinobu NOGAMI <s-nogami@sourceforge.jp>\n"
"Language-Team: none\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#. Tag: title
#: intro.xml:4
#, no-c-format
msgid "Getting started with Web Beans"
msgstr "Web Beans を始めよう"

#. Tag: para
#: intro.xml:6
#, no-c-format
msgid "So you're already keen to get started writing your first Web Bean? Or perhaps you're skeptical, wondering what kinds of hoops the Web Beans specification will make you jump through! The good news is that you've probably already written and used hundreds, perhaps thousands of Web Beans. You might not even remember the first Web Bean you wrote."
msgstr "あなたは、すでに最初の Web Bean を書き始めることに夢中ですか。あるいは、たぶん Web Beans 仕様によって、どのような種類のフープを跳ぶことができるのかを不思議に思って疑い深くなっているのかもしれません。朗報なことは、すでにあなたはおそらく数百、もしかすると数千の Web Beans を書いて使用しているかもしれないということです。あなたは最初の書いた Web Bean を思い出すことさえできないかもしれません。"

#. Tag: title
#: intro.xml:13
#, no-c-format
msgid "Your first Web Bean"
msgstr "初めての Web Bean"

#. Tag: para
#: intro.xml:15
#, no-c-format
msgid "With certain, very special exceptions, every Java class with a constructor that accepts no parameters is a Web Bean. That includes every JavaBean. Furthermore, every EJB 3-style session bean is a Web Bean. Sure, the JavaBeans and EJBs you've been writing every day have not been able to take advantage of the new services defined by the Web Beans specification, but you'll be able to use every one of them as Web Beans &#151; injecting them into other Web Beans, configuring them via the Web Beans XML configuration facility, even adding interceptors and decorators to them &#151; without touching your existing code."
msgstr "ある特定のとても特別な例外を除いて、パラメータなしのコンストラクタを持つすべての Java クラスは、Web Bean です。それはすべての JavaBean を含みます。さらに、すべての EJB 3 仕様のセッション Bean も、Web Bean です。確かに、毎日書いている JavaBean と EJB は、Web Beans 仕様によって定義された新しいサービスを利用することができていません。しかし、それらすべての各々は、&#151; Web Beans の XML 構成機能によって構成し、そしてそれらにインタセプタとデコレータを加えることによって &#151;、現存するコードに触れることなく、Web Beans として使用することができるでしょう。"

#. Tag: para
#: intro.xml:25
#, no-c-format
msgid "Suppose that we have two existing Java classes, that we've been using for years in various applications. The first class parses a string into a list of sentences:"
msgstr "様々なアプリケーションで何年間も使っている２つの既存の Java クラスがあると仮定します。１つ目のクラスは、文のリストへ文字列に構文解析します:"

#. Tag: programlisting
#: intro.xml:29
#, no-c-format
msgid ""
"<![CDATA[public class SentenceParser {\n"
"    public List<String> parse(String text) { ... }\n"
"}]]>"
msgstr ""
"<![CDATA[public class SentenceParser {\n"
"    public List<String> parse(String text) { ... }\n"
"}]]>"

#. Tag: para
#: intro.xml:31
#, no-c-format
msgid "The second existing class is a stateless session bean front-end for an external system that is able to translate sentences from one language to another:"
msgstr "２つ目の現存するクラスは、１つの言語からもう１つの言語への文を翻訳することができる外部システムのフロントエンドとなるステートレスセッション Bean です:"

#. Tag: programlisting
#: intro.xml:35
#, no-c-format
msgid ""
"<![CDATA[@Stateless\n"
"public class SentenceTranslator implements Translator {\n"
"    public String translate(String sentence) { ... }\n"
"}]]>"
msgstr ""
"<![CDATA[@Stateless\n"
"public class SentenceTranslator implements Translator {\n"
"    public String translate(String sentence) { ... }\n"
"}]]>"

#. Tag: para
#: intro.xml:37
#, no-c-format
msgid "Where <literal>Translator</literal> is the local interface:"
msgstr "ここで <literal>Translator</literal> はローカルインターフェースです:"

#. Tag: programlisting
#: intro.xml:39
#, no-c-format
msgid ""
"<![CDATA[@Local\n"
"public interface Translator {\n"
"    public String translate(String sentence);\n"
"}]]>"
msgstr ""
"<![CDATA[@Local\n"
"public interface Translator {\n"
"    public String translate(String sentence);\n"
"}]]>"

#. Tag: para
#: intro.xml:41
#, no-c-format
msgid "Unfortunately, we don't have a preexisting class that translates whole text documents. So let's write a Web Bean that does this job:"
msgstr "運悪く、すべてのテキストドキュメントを翻訳する既存のクラスはありません。そこでこの仕事をする Web Bean を書きましょう:"

#. Tag: programlisting
#: intro.xml:44
#, no-c-format
msgid ""
"<![CDATA[public class TextTranslator {\n"
"    \n"
"    private SentenceParser sentenceParser;\n"
"    private Translator sentenceTranslator;\n"
"    \n"
"    @Initializer\n"
"    TextTranslator(SentenceParser sentenceParser, Translator sentenceTranslator) {\n"
"        this.sentenceParser = sentenceParser;\n"
"        this.sentenceTranslator = sentenceTranslator;\n"
"    }\n"
"    \n"
"    public String translate(String text) {\n"
"        StringBuilder sb = new StringBuilder();\n"
"        for (String sentence: sentenceParser.parse(text)) {\n"
"            sb.append(sentenceTranslator.translate(sentence));\n"
"        }\n"
"        return sb.toString();\n"
"    }\n"
"    \n"
"}]]>"
msgstr ""
"<![CDATA[public class TextTranslator {\n"
"    \n"
"    private SentenceParser sentenceParser;\n"
"    private Translator sentenceTranslator;\n"
"    \n"
"    @Initializer\n"
"    TextTranslator(SentenceParser sentenceParser, Translator sentenceTranslator) {\n"
"        this.sentenceParser = sentenceParser;\n"
"        this.sentenceTranslator = sentenceTranslator;\n"
"    }\n"
"    \n"
"    public String translate(String text) {\n"
"        StringBuilder sb = new StringBuilder();\n"
"        for (String sentence: sentenceParser.parse(text)) {\n"
"            sb.append(sentenceTranslator.translate(sentence));\n"
"        }\n"
"        return sb.toString();\n"
"    }\n"
"    \n"
"}]]>"

#. Tag: para
#: intro.xml:46
#, no-c-format
msgid "We may obtain an instance of <literal>TextTranslator</literal> by injecting it into a Web Bean, Servlet or EJB:"
msgstr "Web Bean、サーブレットあるいは EJB へ注入することによって <literal>TextTranslator</literal> のインスタンスを取得することができます:"

#. Tag: programlisting
#: intro.xml:49
#, no-c-format
msgid ""
"<![CDATA[@Initializer\n"
"public setTextTranslator(TextTranslator textTranslator) {\n"
"    this.textTranslator = textTranslator;\n"
"}]]>"
msgstr ""
"<![CDATA[@Initializer\n"
"public setTextTranslator(TextTranslator textTranslator) {\n"
"    this.textTranslator = textTranslator;\n"
"}]]>"

#. Tag: para
#: intro.xml:51
#, no-c-format
msgid "Alternatively, we may obtain an instance by directly calling a method of the Web Bean manager:"
msgstr "もう１つの方法として、Web Bean マネージャのメソッドを直接に呼ぶことによってインスタンスを取得することもできます:"

#. Tag: programlisting
#: intro.xml:54
#, no-c-format
msgid "<![CDATA[TextTranslator tt = manager.getInstanceByType(TextTranslator.class);]]>"
msgstr "<![CDATA[TextTranslator tt = manager.getInstanceByType(TextTranslator.class);]]>"

#. Tag: para
#: intro.xml:56
#, no-c-format
msgid "But wait: <literal>TextTranslator</literal> does not have a constructor with no parameters! Is it still a Web Bean? Well, a class that does not have a constructor with no parameters can still be a Web Bean if it has a constructor annotated <literal>@Initializer</literal>."
msgstr "しかし待ってください: <literal>TextTranslator</literal> はパラメータなしのコンストラクタがありません。それはまだ Web Bean ですか。まあ、<literal>@Initializer</literal> アノテーションを付けたコンストラクタがあれば、パラメータなしのコンストラクタを持たないクラスもまだ Web Bean であることができます。"

#. Tag: para
#: intro.xml:61
#, no-c-format
msgid "As you've guessed, the <literal>@Initializer</literal> annotation has something to do with dependency injection! <literal>@Initializer</literal> may be applied to a constructor or method of a Web Bean, and tells the Web Bean manager to call that constructor or method when instantiating the Web Bean. The Web Bean manager will inject other Web Beans to the parameters of the constructor or method."
msgstr "あなたが推測しているように、 <literal>@Initializer</literal> ノテーションは依存性注入と関係があります。<literal>@Initializer</literal> は、Web Bean のコンストラクタあるいはメソッドに適用することができ、Web Bean をインスタンス化するときに Web Bean マネージャにそのコンストラクタあるいはメソッドを呼ぶ出すように伝えます。Web Beanマネージャは、コンストラクタあるいはメソッドのパラメータに他の Web Beans を注入します。"

#. Tag: para
#: intro.xml:68
#, no-c-format
msgid "At system initialization time, the Web Bean manager must validate that exactly one Web Bean exists which satisfies each injection point. In our example, if no implementation of <literal>Translator</literal> available &#151; if the <literal>SentenceTranslator</literal> EJB was not deployed &#151; the Web Bean manager would throw an <literal>UnsatisfiedDependencyException</literal>. If more than one implementation of <literal>Translator</literal> was available, the Web Bean manager would throw an <literal>AmbiguousDependencyException</literal>."
msgstr "システムの初期化時に、Web Bean マネージャはそれぞれのインジェクションポイントの条件を満たすまさに１つの Web Bean が存在することを検証しなければなりません。サンプルで、もし利用可能な <literal>Translator</literal> の実装がなければ&#151;、あるいは <literal>SentenceTranslator</literal> EJB がデプロイされていなければ&#151;、Web Bean マネージャーは、<literal>UnsatisfiedDependencyException</literal> をスローします。もし１つ以上の <literal>Translator</literal> の実装が利用可能であれば、Web Beanマネージャは、<literal>AmbiguousDependencyException</literal> をスローします。"

#. Tag: title
#: intro.xml:80
#, no-c-format
msgid "What is a Web Bean?"
msgstr "Web Bean とは何か?"

#. Tag: para
#: intro.xml:82
#, no-c-format
msgid "So what, <emphasis>exactly</emphasis>, is a Web Bean?"
msgstr "それでは、Web Bean とは、<emphasis> 一体</emphasis> 何か。"

#. Tag: para
#: intro.xml:84
#, no-c-format
msgid "A Web Bean is an application class that contains business logic. A Web Bean may be called directly from Java code, or it may be invoked via Unified EL. A Web Bean may access transactional resources. Dependencies between Web Beans are managed automatically by the Web Bean manager. Most Web Beans are <emphasis>stateful</emphasis> and <emphasis>contextual</emphasis>. The lifecycle of a Web Bean is always managed by the Web Bean manager."
msgstr "Web Bean は、ビジネスロジックを含むアプリケーションクラスです。Web Bean は、直接 Java コードから呼び出すこともでき、あるいはユニファイド EL から呼び出すこともできます。Web Bean は、トランザクションのリソースにアクセスすることもできます。Web Beans 間での依存関係は、Web Bean マネージャによって自動的に管理されます。 ほとんどのWeb Beansは <emphasis>ステートフル</emphasis> で <emphasis>コンテキスト依存</emphasis> です。Web Bean のライフサイクルは Web Bean マネージャによっていつも管理されます。"

#. Tag: para
#: intro.xml:91
#, no-c-format
msgid "Let's back up a second. What does it really mean to be \"contextual\"? Since Web Beans may be stateful, it matters <emphasis>which</emphasis> bean instance I have. Unlike a stateless component model (for example, stateless session beans) or a singleton component model (such as servlets, or singleton beans), different clients of a Web Bean see the Web Bean in different states. The client-visible state depends upon which instance of the Web Bean the client has a reference to."
msgstr "少しの間ゆっくり考えてみましょう。「コンテキスト依存である」ということは、本当に何を意味するのでしょうか。Web Beans はステートフルですので、 <emphasis>どの</emphasis> Bean インスタンスを持っているかが重要です。ステートレスなコンポーネントモデル(例えば、ステートレスセッション bean)あるいはシングルトンコンポーネントモデル(例えばサーブレット、あるいはシングルトン bean)と違って、Web Bean の異なるクライアントは、異なる状態で Web Bean を参照します。クライアントに見える状態は、Web Bean のどちらのインスタンスへのリファレンスをクライアントが持っているかによります。"

#. Tag: para
#: intro.xml:98
#, no-c-format
msgid "However, like a stateless or singleton model, but <emphasis>unlike</emphasis> stateful session beans, the client does not control the lifecycle of the instance by explicitly creating and destroying it. Instead, the <emphasis>scope</emphasis> of the Web Bean determines:"
msgstr "しかし、しかしステートフルなセッション bean とは <emphasis>違って</emphasis>、クライアントは、ステートレスあるいはシングルトンモデルと同じように、明示的にインスタンスの生成と破棄を行ってインスタンスのライフサイクルを制御はしません。その代わりに、Web Bean の <emphasis>スコープ</emphasis> は以下で決定されます:"

#. Tag: para
#: intro.xml:105
#, no-c-format
msgid "the lifecycle of each instance of the Web Bean and"
msgstr "Web Bean のそれぞれのインスタンスのライフサイクル"

#. Tag: para
#: intro.xml:108
#, no-c-format
msgid "which clients share a reference to a particular instance of the Web Bean."
msgstr "Web Bean のある特定のリファレンスをどのクライアントが共用しているか"

#. Tag: para
#: intro.xml:113
#, no-c-format
msgid "For a given thread in a Web Beans application, there may be an <emphasis>active context</emphasis> associated with the scope of the Web Bean. This context may be unique to the thread (for example, if the Web Bean is request scoped), or it may be shared with certain other threads (for example, if the Web Bean is session scoped) or even all other threads (if it is application scoped)."
msgstr "Web Beans アプリケーションに与えられたスレッドには、Web Bean のスコープに関連付けられた <emphasis>アクティブコンテキスト</emphasis> があります。このコンテキストは、そのスレッドに固有かもしれません(例えば、Web Bean がリクエストスコープの場合)。あるいは、それはその他のスレッド間で共用されるかもしれません(例えば、Web Bean がセッションスコープの場合)。あるいは、それはすべてのスレッドで共用されるかもしれません(アプリケーションスコープの場合)。"

#. Tag: para
#: intro.xml:119
#, no-c-format
msgid "Clients (for example, other Web Beans) executing in the same context will see the same instance of the Web Bean. But clients in a different context will see a different instance."
msgstr "同じコンテキストで実行しているクライアント(例えば、他の Web Beans)は、同じインスタンスの Web Bean を参照するでしょう。しかし、異なるコンテキストのクライアントは、異なるインスタンスを参照します。"

#. Tag: para
#: intro.xml:123
#, no-c-format
msgid "One great advantage of the contextual model is that it allows stateful Web Beans to be treated like services! The client need not concern itself with managing the lifecycle of the Web Bean it is using, <emphasis>nor does it even need to know what that lifecyle is.</emphasis> Web Beans interact by passing messages, and the Web Bean implementations define the lifecycle of their own state. The Web Beans are loosely coupled because:"
msgstr "コンテキスト依存モデルのすばらしい利点の１つには、ステートフルな Web Beans をサービスのように取り扱うことを可能にすることがあります。クライアントは、使用している Web Bean のライフサイクルの管理に関与する必要はありません。 <emphasis>またさらにライフサイクルが何であるかも知っている必要はありません。</emphasis> Web Beansは、メッセージを送信することによって相互に作用し、 Web Bean の実装が自分自身の状態のライフサイクルを定義します。Web Beans が疎結合なのは以下の理由からです:"

#. Tag: para
#: intro.xml:132
#, no-c-format
msgid "they interact via well-defined public APIs"
msgstr "明確に定義されたパブリックなAPI経由で相互に作用する"

#. Tag: para
#: intro.xml:135
#, no-c-format
msgid "their lifecycles are completely decoupled"
msgstr "ライフサイクルは完全に切り離されている"

#. Tag: para
#: intro.xml:139
#, no-c-format
msgid "We can replace one Web Bean with a different Web Bean that implements the same API and has a different lifecycle (a different scope) without affecting the other Web Bean implementation. In fact, Web Beans defines a sophisticated facility for overriding Web Bean implementations at deployment time, as we will see in <xref linkend=\"deploymenttypes\"/>."
msgstr "１つの Web Bean は、その他の Web Bean の実装には影響せずに、同じAPIを実装した異なるライフサイクル(異なるスコープ)を持つ別の Web Bean に置き換えることができます。<xref linkend=\"deploymenttypes\"/> で説明するように、実際 Web Beansは、デプロイメント時に Web Bean の実装をオーバーライドするための洗練された機構を定義します。"

#. Tag: para
#: intro.xml:145
#, no-c-format
msgid "Note that not all clients of a Web Bean are Web Beans. Other objects such as Servlets or Message-Driven Beans &#151; which are by nature not injectable, contextual objects &#151; may also obtain references to Web Beans by injection."
msgstr "すべての Web Bean のクライアントが必ずしも Web Beans ではないことに注意してください。サーブレットまたはメッセージ駆動 Bean といった他のオブジェクト&#151;生まれつき注入可能でなく、コンテキスト依存ではいオブジェクト&#151; が注入によって Web Beans へのリファレンスを取得することもあります。"

#. Tag: para
#: intro.xml:149
#, no-c-format
msgid "Enough hand-waving. More formally, according to the spec:"
msgstr "より正式には、仕様は次の通りです:"

#. Tag: para
#: intro.xml:153
#, no-c-format
msgid "A Web Bean comprises:"
msgstr "Web Bean は以下の要素から構成されます:"

#. Tag: para
#: intro.xml:156
#, no-c-format
msgid "A (nonempty) set of API types"
msgstr "(空ではない) API タイプのセット"

#. Tag: para
#: intro.xml:157
#, no-c-format
msgid "A (nonempty) set of binding annotation types"
msgstr "(空ではない) バインディングアノテーションタイプのセット"

#. Tag: para
#: intro.xml:158
#, no-c-format
msgid "A scope"
msgstr "スコープ"

#. Tag: para
#: intro.xml:159
#, no-c-format
msgid "A deployment type"
msgstr "デプロイメントタイプ"

#. Tag: para
#: intro.xml:160
#, no-c-format
msgid "Optionally, a Web Bean name"
msgstr "(オプションの) Web Bean 名"

#. Tag: para
#: intro.xml:161
#, no-c-format
msgid "A set of interceptor binding types"
msgstr "インタセプタのバインディングタイプのセット"

#. Tag: para
#: intro.xml:162
#, no-c-format
msgid "A Web Bean implementation"
msgstr "Web Bean インプリメンテーション"

#. Tag: para
#: intro.xml:167
#, no-c-format
msgid "Let's see what some of these terms mean, to the Web Bean developer."
msgstr "Web Bean 開発者にとって、これらの用語が何を意味するのか確認しましょう。"

#. Tag: title
#: intro.xml:170
#, no-c-format
msgid "API types, binding types and dependency injection"
msgstr "API タイプとバインディングタイプと依存性注入"

#. Tag: para
#: intro.xml:172
#, no-c-format
msgid "Web Beans usually acquire references to other Web Beans via dependency injection. Any injected attribute specifies a \"contract\" that must be satisfied by the Web Bean to be injected. The contract is:"
msgstr "Web Beans は、通常は依存性注入によって他の Web Beans への参照を獲得します。注入されるどの属性も、注入される Web Bean が条件を満たさなければならない「契約」を指定します。契約は以下の通りです:"

#. Tag: para
#: intro.xml:177
#, no-c-format
msgid "an API type, together with"
msgstr "API タイプ"

#. Tag: para
#: intro.xml:178
#, no-c-format
msgid "a set of binding types."
msgstr "バインディングタイプのセット"

#. Tag: para
#: intro.xml:181
#, no-c-format
msgid "An API is a user-defined class or interface. (If the Web Bean is an EJB session bean, the API type is the <literal>@Local</literal> interface or bean-class local view). A binding type represents some client-visible semantic that is satisfied by some implementations of the API and not by others."
msgstr "API は、ユーザ定義のクラスあるいはインタフェースです。(もし Web Bean が EJB セッション Bean ならば、API タイプは <literal>@Local</literal>  インターフェースか bean クラスのローカルビューです)。バインディングタイプは、API のある実装によっては満たされ他のものでは満足されない、クライアントに見えるセマンティックを表します。"

#. Tag: para
#: intro.xml:186
#, no-c-format
msgid "Binding types are represented by user-defined annotations that are themselves annotated <literal>@BindingType</literal>. For example, the following injection point has API type <literal>PaymentProcessor</literal> and binding type <literal>@CreditCard</literal>:"
msgstr "バインディングタイプは、それ自身が <literal>@BindingType</literal> アノテーションを付与されたユーザ定義のアノテーションによって表されます。例えば、以下のインジェクションポイントは、API タイプ <literal>PaymentProcessor</literal> とバインディングタイプ <literal>@CreditCard</literal> を持っています:"

#. Tag: programlisting
#: intro.xml:191
#, no-c-format
msgid "<![CDATA[@CreditCard PaymentProcessor paymentProcessor]]>"
msgstr "<![CDATA[@CreditCard PaymentProcessor paymentProcessor]]>"

#. Tag: para
#: intro.xml:193
#, no-c-format
msgid "If no binding type is explicitly specified at an injection point, the default binding type <literal>@Current</literal> is assumed."
msgstr "もしどのバインディングタイプもインジェクションポイントで明示的に指定されなければ、デフォルトのバインディングタイプ <literal>@Current</literal> が想定されます。"

#. Tag: para
#: intro.xml:196
#, no-c-format
msgid "For each injection point, the Web Bean manager searches for a Web Bean which satisfies the contract (implements the API, and has all the binding types), and injects that Web Bean."
msgstr "各々のインジェクションポイントに対して、Web Bean マネージャは、契約(API の実装、すべてのバインディングタイプの所持)の条件を満たす Web Bean を探し、その Web Bean を注入します。"

#. Tag: para
#: intro.xml:200
#, no-c-format
msgid "The following Web Bean has the binding type <literal>@CreditCard</literal> and implements the API type <literal>PaymentProcessor</literal>. It could therefore be injected to the example injection point:"
msgstr "以下の Web Bean は、バインディングタイプ <literal>@CreditCard</literal> を持ち、API タイプ <literal>PaymentProcessor</literal> を実装しています。それゆえ、サンプルのインジェクションポイントに注入することができます:"

#. Tag: programlisting
#: intro.xml:204
#, no-c-format
msgid ""
"<![CDATA[@CreditCard\n"
"public class CreditCardPaymentProcessor \n"
"    implements PaymentProcessor { ... }]]>"
msgstr ""
"<![CDATA[@CreditCard\n"
"public class CreditCardPaymentProcessor \n"
"    implements PaymentProcessor { ... }]]>"

#. Tag: para
#: intro.xml:206
#, no-c-format
msgid "If a Web Bean does not explicitly specify a set of binding types, it has exactly one binding type: the default binding type <literal>@Current</literal>."
msgstr "もし Web Bean が明示的にバインディングタイプのセットを指定しなければ、それは１つのバインディングタイプ : デフォルトのバインディングタイプ<literal>@Current</literal> を持つことになります。"

#. Tag: para
#: intro.xml:209
#, no-c-format
msgid "Web Beans defines a sophisticated but intuitive <emphasis>resolution algorithm</emphasis> that helps the container decide what to do if there is more than one Web Bean that satisfies a particular contract. We'll get into the details in <xref linkend=\"injection\"/>."
msgstr "Web Beans は、もし特定の契約と満たす１つ以上の Web Bean があったときに、コンテナが何をすべきかを決定するのを助ける洗練されたしかも直観的な <emphasis>解決アルゴリズム</emphasis> を定義します。その詳細は <xref linkend=\"injection\"/> で説明します。"

#. Tag: title
#: intro.xml:217
#, no-c-format
msgid "Deployment types"
msgstr "デプロイメントタイプ"

#. Tag: para
#: intro.xml:219
#, no-c-format
msgid "<emphasis>Deployment types</emphasis> let us classify our Web Beans by deployment scenario. A deployment type is an annotation that represents a particular deployment scenario, for example <literal>@Mock</literal>, <literal>@Staging</literal> or <literal>@AustralianTaxLaw</literal>. We apply the annotation to Web Beans which should be deployed in that scenario. A deployment type allows a whole set of Web Beans to be conditionally deployed, with a just single line of configuration."
msgstr "<emphasis>デプロイメントタイプ</emphasis> は、デプロイメントシナリオによって Web Beans を分類させます。デプロイメントタイプは、特定のデプロイメントシナリオを表すアノテーション、例えば <literal>@Mock</literal> や <literal>@Staging</literal>、<literal>@AustralianTaxLaw</literal> です。そのシナリオでデプロイされるべき Web Beans にアノテーションを適用します。デプロイメントタイプは、単一の構成で１セットの Web Beans すべてを条件つきでデプロイすることを可能にします。"

#. Tag: para
#: intro.xml:226
#, no-c-format
msgid "Many Web Beans just use the default deployment type <literal>@Production</literal>, in which case no deployment type need be explicitly specified. All three Web Bean in our example have the deployment type <literal>@Production</literal>."
msgstr "多くの Web Beans は、どのデプロイメントタイプも明示的に指定されていない場合、単にデフォルトのデプロイメントタイプ <literal>@Production</literal> を使用します。サンプルで使用する３つの Web Bean すべては、デプロイメントタイプ <literal>@Production</literal> を持っています。"

#. Tag: para
#: intro.xml:230
#, no-c-format
msgid "In a testing environment, we might want to replace the <literal>SentenceTranslator</literal> Web Bean with a \"mock object\":"
msgstr "テスト環境では、<literal>SentenceTranslator</literal> Web Bean を「モックオブジェクト」で置き換えたいでしょう:"

#. Tag: programlisting
#: intro.xml:233
#, no-c-format
msgid ""
"<![CDATA[@Mock\n"
"public class MockSentenceTranslator implements Translator {\n"
"    public String translate(String sentence) {\n"
"        return \"Lorem ipsum dolor sit amet\";\n"
"    }\n"
"}]]>"
msgstr ""
"<![CDATA[@Mock\n"
"public class MockSentenceTranslator implements Translator {\n"
"    public String translate(String sentence) {\n"
"        return \"Lorem ipsum dolor sit amet\";\n"
"    }\n"
"}]]>"

#. Tag: para
#: intro.xml:236
#, no-c-format
msgid "We would enable the deployment type <literal>@Mock</literal> in our testing environment, to indicate that <literal>MockSentenceTranslator</literal> and any other Web Bean annotated <literal>@Mock</literal> should be used."
msgstr "<literal>MockSentenceTranslator</literal> と <literal>@Mock</literal> アノテーションが付与されたその他の Web Bean を使用することを指定するために、テスト環境ではデプロイメントタイプ <literal>@Mock</literal> を有効にします。"

#. Tag: para
#: intro.xml:240
#, no-c-format
msgid "We'll talk more about this unique and powerful feature in <xref linkend=\"deploymenttypes\"/>."
msgstr "この独特で強力な機能については <xref linkend=\"deploymenttypes\"/> で説明します。"

#. Tag: title
#: intro.xml:246
#, no-c-format
msgid "Scope"
msgstr "スコープ"

#. Tag: para
#: intro.xml:248
#, no-c-format
msgid "The <emphasis>scope</emphasis> defines the lifecycle and visibility of instances of the Web Bean. The Web Beans context model is extensible, accommodating arbitrary scopes. However, certain important scopes are built-in to the specification, and provided by the Web Bean manager. A scope is represented by an annotation type."
msgstr "<emphasis>スコープ</emphasis> は Web Bean のインスタンスのライフサイクルと可視性を定義します。Web Beans のコンテキストモデルは拡張可能で、任意のスコープを収容できます。しかし、非常に重要なスコープは仕様に組み込まれ、Web Bean マネージャー によって提供されています。スコープはアノテーションタイプによって表されます。"

#. Tag: para
#: intro.xml:254
#, no-c-format
msgid "For example, any web application may have <emphasis>session scoped</emphasis> Web Beans:"
msgstr "例えば、どんな Web アプリケーションも <emphasis>セッションスコープ</emphasis> の Web Beansを持っています:"

#. Tag: programlisting
#: intro.xml:257
#, no-c-format
msgid ""
"<![CDATA[@SessionScoped\n"
"public class ShoppingCart { ... }]]>"
msgstr ""
"<![CDATA[@SessionScoped\n"
"public class ShoppingCart { ... }]]>"

#. Tag: para
#: intro.xml:259
#, no-c-format
msgid "An instance of a session scoped Web Bean is bound to a user session and is shared by all requests that execute in the context of that session."
msgstr "セッションスコープの Web Bean のインスタンスはユーザセッションにバインドされて、そのセッションのコンテキストで実行されるすべてのリクエストによって共有されます。"

#. Tag: para
#: intro.xml:262
#, no-c-format
msgid "By default, Web Beans belong to a special scope called the <emphasis>dependent pseudo-scope</emphasis>. Web Beans with this scope are pure dependent objects of the object into which they are injected, and their lifecycle is bound to the lifecycle of that object."
msgstr "デフォルトでは、Web Beans は <emphasis>依存擬似スコープ</emphasis> と呼ばれる特別なスコープに属します。このスコープをもつ Web Beans は、注入したオブジェクトに純粋に依存するオブジェクトで、ライフサイクルは注入したオブジェクトのライフサイクルに括り付けられます。"

#. Tag: para
#: intro.xml:267
#, no-c-format
msgid "We'll talk more about scopes in <xref linkend=\"scopescontexts\"/>."
msgstr "スコープの詳細については <xref linkend=\"scopescontexts\"/>で説明します。"

#. Tag: title
#: intro.xml:272
#, no-c-format
msgid "Web Bean names and Unified EL"
msgstr "Web Bean 名とユニファイド EL"

#. Tag: para
#: intro.xml:274
#, no-c-format
msgid "A Web Bean may have a <emphasis>name</emphasis>, allowing it to be used in Unified EL expressions. It's easy to specify the name of a Web Bean:"
msgstr "Web Bean は <emphasis>名前</emphasis> を持ちます。これによりユニファイド EL 式で使用することが可能になります。Web Bean の名前を指定するのは簡単です:"

#. Tag: programlisting
#: intro.xml:278
#, no-c-format
msgid ""
"<![CDATA[@SessionScoped @Named(\"cart\")\n"
"public class ShoppingCart { ... }]]>"
msgstr ""
"<![CDATA[@SessionScoped @Named(\"cart\")\n"
"public class ShoppingCart { ... }]]>"

#. Tag: para
#: intro.xml:280
#, no-c-format
msgid "Now we can easily use the Web Bean in any JSF or JSP page:"
msgstr "これで JSF あるいは JSP ページで Web Bean を簡単に使用することができます:"

#. Tag: programlisting
#: intro.xml:282
#, no-c-format
msgid ""
"<![CDATA[<h:dataTable value=\"#{cart.lineItems}\" var=\"item\">\n"
"    ....\n"
"</h:dataTable>]]>"
msgstr ""
"<![CDATA[<h:dataTable value=\"#{cart.lineItems}\" var=\"item\">\n"
"    ....\n"
"</h:dataTable>]]>"

#. Tag: para
#: intro.xml:284
#, no-c-format
msgid "It's even easier to just let the name be defaulted by the Web Bean manager:"
msgstr "Web Bean マネージャによって名前は単純にデフォルトを使用させることは一層簡単です:"

#. Tag: programlisting
#: intro.xml:287
#, no-c-format
msgid ""
"<![CDATA[@SessionScoped @Named\n"
"public class ShoppingCart { ... }]]>"
msgstr ""
"<![CDATA[@SessionScoped @Named\n"
"public class ShoppingCart { ... }]]>"

#. Tag: para
#: intro.xml:289
#, no-c-format
msgid "In this case, the name defaults to <literal>shoppingCart</literal> &#151; the unqualified class name, with the first character changed to lowercase."
msgstr "この場合、デフォルトで名前は <literal>shoppingCart</literal> になります&#151; 最初の文字を小文字に変換した無資格のクラス名になります。"

#. Tag: title
#: intro.xml:295
#, no-c-format
msgid "Interceptor binding types"
msgstr "インタセプタバインディングタイプ"

#. Tag: para
#: intro.xml:297
#, no-c-format
msgid "Web Beans supports the interceptor functionality defined by EJB 3, not only for EJB beans, but also for plain Java classes. In addition, Web Beans provides a new approach to binding interceptors to EJB beans and other Web Beans."
msgstr "Web Beans は、 EJB beans のためにだけではなく、単純な Java クラスのためにも、EJB 3 で定義されたインタセプタ機能を提供します。さらに、Web Beans は、EJB beans と他の Web Beans へのバインディングインタセプタに新しいアプローチを提供します。"

#. Tag: para
#: intro.xml:302
#, no-c-format
msgid "It remains possible to directly specify the interceptor class via use of the <literal>@Interceptors</literal> annotation:"
msgstr "それは、<literal>@Interceptors</literal> アノテーションを使用することによりインタセプタクラスを直接指定することを可能にします:"

#. Tag: programlisting
#: intro.xml:305
#, no-c-format
msgid ""
"<![CDATA[@SessionScoped \n"
"@Interceptors(TransactionInterceptor.class)\n"
"public class ShoppingCart { ... }]]>"
msgstr ""
"<![CDATA[@SessionScoped \n"
"@Interceptors(TransactionInterceptor.class)\n"
"public class ShoppingCart { ... }]]>"

#. Tag: para
#: intro.xml:307
#, no-c-format
msgid "However, it is more elegant, and better practice, to indirect the interceptor binding through an <emphasis>interceptor binding type</emphasis>:"
msgstr "しかし、<emphasis>インタセプタバインディングタイプ</emphasis> によりインタセプタバインディングを間接化することは、よりエレガントでより良い手法です:"

#. Tag: programlisting
#: intro.xml:311
#, no-c-format
msgid ""
"<![CDATA[@SessionScoped @Transactional\n"
"public class ShoppingCart { ... }]]>"
msgstr ""
"<![CDATA[@SessionScoped @Transactional\n"
"public class ShoppingCart { ... }]]>"

#. Tag: para
#: intro.xml:313
#, no-c-format
msgid "We'll discuss Web Beans interceptors and decorators in <xref linkend=\"interceptors\"/> and <xref linkend=\"decorators\"/>."
msgstr "Web Beans インタセプタとデコレータは <xref linkend=\"interceptors\"/> と <xref linkend=\"decorators\"/> で説明します。"

#. Tag: title
#: intro.xml:321
#, no-c-format
msgid "What kinds of objects can be Web Beans?"
msgstr "どの種類のオブジェクトが Web Beans になることができるのか"

#. Tag: para
#: intro.xml:323
#, no-c-format
msgid "We've already seen that JavaBeans, EJBs and some other Java classes can be Web Beans. But exactly what kinds of objects are Web Beans?"
msgstr "すでに JavaBean や EJB、その他のいくつかの Javaクラス が Web Beans になることを見てきました。しかし、まさにどの種類のオブジェクトが Web Beans になることができるのでしょうか。"

#. Tag: title
#: intro.xml:327
#, no-c-format
msgid "Simple Web Beans"
msgstr "単純な Web Beans"

#. Tag: para
#: intro.xml:329
#, no-c-format
msgid "The Web Beans specification says that a concrete Java class is a <emphasis>simple</emphasis> Web Bean if:"
msgstr "Web Beans 仕様では、以下の条件を満たすときに、コンクリートな Javaクラスが <emphasis>単純な</emphasis>  Web Bean になります:"

#. Tag: para
#: intro.xml:334
#, no-c-format
msgid "it is not an EE container-managed component, like an EJB, a Servlet or a JPA entity,"
msgstr "EJB やサーブレット、JPA エンティティのように EE コンテナで管理されたコンポーネントではないもの"

#. Tag: para
#: intro.xml:338
#, no-c-format
msgid "it is not a non-static static inner class,"
msgstr "静的でないインナークラスではないもの"

#. Tag: para
#: intro.xml:341
#, no-c-format
msgid "it is not a parameterized type, and"
msgstr "パラメータ化されたタイプではないもの"

#. Tag: para
#: intro.xml:344
#, no-c-format
msgid "it has a constructor with no parameters, or a constructor annotated <literal>@Initializer</literal>."
msgstr "パラメータなしのコンストラクタを持つか、あるいは <literal>@Initializer</literal> アノテーションが付与されたコンストラクタを持つもの"

#. Tag: para
#: intro.xml:349
#, no-c-format
msgid "Thus, almost every JavaBean is a simple Web Bean."
msgstr "これにより、ほとんどすべての JavaBean は単純な Web Bean です。"

#. Tag: para
#: intro.xml:351
#, no-c-format
msgid "Every interface implemented directly or indirectly by a simple Web Bean is an API type of the simple Web Bean. The class and its superclasses are also API types."
msgstr "単純な Web Bean によって直接的にまたは間接的にに実装されるすべてのインタフェースは、単純な Web Bean の API タイプです。クラスとそのクラスのスーパークラスもまた API タイプです。"

#. Tag: title
#: intro.xml:358
#, no-c-format
msgid "Enterprise Web Beans"
msgstr "エンタープライズ Web Beans"

#. Tag: para
#: intro.xml:360
#, no-c-format
msgid "The specification says that all EJB 3-style session and singleton beans are <emphasis>enterprise</emphasis> Web Beans. Message driven beans are not Web Beans &#151; since they are not intended to be injected into other objects &#151; but they can take advantage of most of the functionality of Web Beans, including dependency injection and interceptors."
msgstr "仕様によれば、すべての EJB 3 スタイルのセッション Bean とシングルトン Bean は <emphasis>エンタープライズ</emphasis> Web Beans です。メッセージ駆動 Bean は Web Beans ではないのでしょうか。&#151;それらは他のオブジェクトへ注入されることを意図していないのですが&#151; 依存性注入とインタセプタを含む Web Beans のほとんどの機能を利用することができます。"

#. Tag: para
#: intro.xml:366
#, no-c-format
msgid "Every local interface of an enterprise Web Bean that does not have a wildcard type parameter or type variable, and every one of its superinterfaces, is an API type of the enterprise Web Bean. If the EJB bean has a bean class local view, the bean class, and every one of its superclasses, is also an API type."
msgstr "ワイルドカードタイプのパラメータまたはタイプ変数を持たないエンタープライズ Web Bean の ローカルインタフェースと、そのスーパーインタフェースのすべてが、エンタープライズ Web Bean のAPI タイプです。もし EJB Bean が ローカルビューの Bean クラスを持っていれば、Beanクラスとそのすべてのスーパークラスも APIタイプです。"

#. Tag: para
#: intro.xml:372
#, no-c-format
msgid "Stateful session beans should declare a remove method with no parameters or a remove method annotated <literal>@Destructor</literal>. The Web Bean manager calls this method to destroy the stateful session bean instance at the end of its lifecycle. This method is called the <emphasis>destructor</emphasis> method of the enterprise Web Bean."
msgstr "ステートフルなセッション beans は、パラメータのない remove メソッドまたは <literal>@Destructor</literal> アノテーションを付与された remove メソッドを宣言すべきです。Web Bean マネージャは、そのライフサイクルの終わりでステートフルセッション Bean のインスタンスを破棄するために、このメソッドを呼び出します。このメソッドは、エンタープライズ Web Bean の <emphasis>destructor</emphasis> メソッドと呼ばれます。"

#. Tag: programlisting
#: intro.xml:378
#, no-c-format
msgid ""
"<![CDATA[@Stateful @SessionScoped\n"
"public class ShoppingCart {\n"
"\n"
"    ...\n"
"    \n"
"    @Remove\n"
"    public void destroy() {}\n"
"\n"
"}]]>"
msgstr ""
"<![CDATA[@Stateful @SessionScoped\n"
"public class ShoppingCart {\n"
"\n"
"    ...\n"
"    \n"
"    @Remove\n"
"    public void destroy() {}\n"
"\n"
"}]]>"

#. Tag: para
#: intro.xml:380
#, no-c-format
msgid "So when should we use an enterprise Web Bean instead of a simple Web Bean? Well, whenever we need the advanced enterprise services offered by EJB, such as:"
msgstr "それでは、いつ単純な Web Bean でなくエンタープライズ Web Bean を使用すべきでしょうか。EJB によって提供される高度なエンタープライズサービスを必要とする場合に使用します。例えば:"

#. Tag: para
#: intro.xml:387
#, no-c-format
msgid "method-level transaction management and security,"
msgstr "メソッドレベルのトランザクション管理とセキュリティ"

#. Tag: para
#: intro.xml:390
#, no-c-format
msgid "concurrency management,"
msgstr "並行性管理"

#. Tag: para
#: intro.xml:393
#, no-c-format
msgid "instance-level passivation for stateful session beans and instance-pooling for stateless session beans,"
msgstr "ステートフルセッション Bean のためのインスタンスレベルの非活性化とステートレスセッション Bean のためのインスタンスプーリング"

#. Tag: para
#: intro.xml:397
#, no-c-format
msgid "remote and web service invocation, and"
msgstr "リモートサービスと Web サービスの呼び出し"

#. Tag: para
#: intro.xml:400
#, no-c-format
msgid "timers and asynchronous methods,"
msgstr "タイマーと非同期メソッド"

#. Tag: para
#: intro.xml:404
#, no-c-format
msgid "we should use an enterprise Web Bean. When we don't need any of these things, a simple Web Bean will serve just fine."
msgstr "エンタープライズ Web Bean を使用すべきです。これらのエンタープライズサービスのいずれもが必要ではないときには、単純な Web Bean がちょうど見事に役立つでしょう。"

#. Tag: para
#: intro.xml:407
#, no-c-format
msgid "Many Web Beans (including any session or application scoped Web Bean) are available for concurrent access. Therefore, the concurrency management provided by EJB 3.1 is especially useful. Most session and application scoped Web Beans should be EJBs."
msgstr "多くの Web Beans(どんなセッションスコープあるいはアプリケーションスコープのWeb Beanも含む)は、並行アクセスが可能です。それゆえに、EJB 3.1 によって提供された並行性管理は特に役に立ちます。ほとんどのセッションスコープとアプリケーションスコープの Web Beans は EJB であるべきです。"

#. Tag: para
#: intro.xml:412
#, no-c-format
msgid "Web Beans which hold references to heavy-weight resources, or hold a lot of internal state benefit from the advanced container-managed lifecycle defined by the EJB <literal>@Stateless</literal>/<literal>@Stateful</literal>/<literal>@Singleton</literal> model, with its support for passivation and instance pooling."
msgstr "ヘビー級のリソースへの参照を保持あるいは多くの内部状態を保持する Web Beans は、EJB <literal>@Stateless</literal>/<literal>@Stateful</literal>/<literal>@Singleton</literal> モデル によって定義された高度なコンテナで管理されたライフサイクルから恩恵を受け、非活性化とインスタンスプーリングに対するサポートも利用できます。"

#. Tag: para
#: intro.xml:417
#, no-c-format
msgid "Finally, it's usually obvious when method-level transaction management, method-level security, timers, remote methods or asynchronous methods are needed."
msgstr "最後に、メソッドレベルのトランザクション管理、メソッドレベルのセキュリティ、タイマー、リモートメソッドあるいは非同期メソッドが必要とされる場合はたいてい明らかです。"

#. Tag: para
#: intro.xml:420
#, no-c-format
msgid "It's usually easy to start with simple Web Bean, and then turn it into an EJB, just by adding an annotation: <literal>@Stateless</literal>, <literal>@Stateful</literal> or <literal>@Singleton</literal>."
msgstr "通常は単純な Web Bean で始めるのが簡単です。それから、単に <literal>@Stateless</literal> や <literal>@Stateful</literal>、<literal>@Singleton</literal> アノテーションを付け加えることによって、それらをEJBに変えてください。"

#. Tag: title
#: intro.xml:427
#, no-c-format
msgid "Producer methods"
msgstr "プロデューサ (producer) メソッド"

#. Tag: para
#: intro.xml:429
#, no-c-format
msgid "A <emphasis>producer method</emphasis> is a method that is called by the Web Bean manager to obtain an instance of the Web Bean when no instance exists in the current context. A producer method lets the application take full control of the instantiation process, instead of leaving instantiation to the Web Bean manager. For example:"
msgstr "<emphasis>プロデューサメソッド</emphasis> は、現在のコンテキストにインスタンスが存在しないときに、Web Bean のインスタンスを得るために Web Bean マネージャ によって呼ばれるメソッドです。プロデューサメソッドは、インスタンス化を Web Bean マネージャに委ねるのではなく、アプリケーションにインスタンス化プロセスの完全な管理をさせます。例えば:"

#. Tag: programlisting
#: intro.xml:435
#, no-c-format
msgid ""
"<![CDATA[@ApplicationScoped\n"
"public class Generator {\n"
"\n"
"    private Random random = new Random( System.currentTimeMillis() );\n"
"    \n"
"    @Produces @Random int next() {\n"
"        return random.nextInt(100);\n"
"    }\n"
"\n"
"}]]>"
msgstr ""
"<![CDATA[@ApplicationScoped\n"
"public class Generator {\n"
"\n"
"    private Random random = new Random( System.currentTimeMillis() );\n"
"    \n"
"    @Produces @Random int next() {\n"
"        return random.nextInt(100);\n"
"    }\n"
"\n"
"}]]>"

#. Tag: para
#: intro.xml:437
#, no-c-format
msgid "The result of a producer method is injected just like any other Web Bean."
msgstr "プロデューサメソッドの結果は、ちょうど他のWeb Beanのように注入されます。"

#. Tag: programlisting
#: intro.xml:439
#, no-c-format
msgid "<![CDATA[@Random int randomNumber]]>"
msgstr "<![CDATA[@Random int randomNumber]]>"

#. Tag: para
#: intro.xml:441
#, no-c-format
msgid "The method return type and all interfaces it extends/implements directly or indirectly are API types of the producer method. If the return type is a class, all superclasses are also API types."
msgstr "メソッドの戻りタイプとそれが直接的にあるいは間接的に拡張する/実装するすべてのインタフェースはプロデューサメソッドの API タイプです。もし戻りのタイプがクラスならは、すべてのスーパークラスもAPI タイプです。"

#. Tag: para
#: intro.xml:445
#, no-c-format
msgid "Some producer methods return objects that require explicit destruction:"
msgstr "プロデューサメソッドは、明示的な破棄を必要とするオブジェクトを返すものもあります:"

#. Tag: programlisting
#: intro.xml:447
#, no-c-format
msgid ""
"<![CDATA[@Produces @RequestScoped Connection connect(User user) {\n"
"    return createConnection( user.getId(), user.getPassword() );\n"
"}]]>"
msgstr ""
"<![CDATA[@Produces @RequestScoped Connection connect(User user) {\n"
"    return createConnection( user.getId(), user.getPassword() );\n"
"}]]>"

#. Tag: para
#: intro.xml:449
#, no-c-format
msgid "These producer methods may define matching <emphasis>disposal methods</emphasis>:"
msgstr "これらのプロデューサメソッドは、適合する <emphasis> ディスポーザルメソッド</emphasis> を定義するかもしれません: "

#. Tag: programlisting
#: intro.xml:451
#, no-c-format
msgid ""
"<![CDATA[void close(@Disposes Connection connection) {\n"
"    connection.close();\n"
"}]]>"
msgstr ""
"<![CDATA[void close(@Disposes Connection connection) {\n"
"    connection.close();\n"
"}]]>"

#. Tag: para
#: intro.xml:453
#, no-c-format
msgid "This disposal method is called automatically by the Web Bean manager at the end of the request."
msgstr "このディスポーザルメソッドは、リクエストの終わりに Web Bean マネージャ によって自動的に呼び出されます。"

#. Tag: para
#: intro.xml:456
#, no-c-format
msgid "We'll talk much more about producer methods in <xref linkend=\"producermethods\"/>."
msgstr "プロデューサメソッドについての詳細は <xref linkend=\"producermethods\"/> で説明します。"

#. Tag: title
#: intro.xml:461
#, no-c-format
msgid "JMS endpoints"
msgstr "JMS エンドポイント"

#. Tag: para
#: intro.xml:463
#, no-c-format
msgid "Finally, a JMS queue or topic can be a Web Bean. Web Beans relieves the developer from the tedium of managing the lifecycles of all the various JMS objects required to send messages to queues and topics. We'll discuss JMS endpoints in <xref linkend=\"jms\"/>."
msgstr "最後に、JMS キューまたはトピックは、Web Bean になることができます。Web Beans は、キューとトピックにメッセージを送るために必要となる、すべての様々な JMS オブジェクトのライフサイクルを管理する退屈から開発者を開放します。JMS エンドポイントは <xref linkend=\"jms\"/> で説明します。"

