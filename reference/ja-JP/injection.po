# Language ja-JP translations for master.xml package.
# Automatically generated, 2008.
#
msgid ""
msgstr ""
"Project-Id-Version: master.xml\n"
"Report-Msgid-Bugs-To: http://bugs.kde.org\n"
"POT-Creation-Date: 2008-12-19 20:26+0000\n"
"PO-Revision-Date: 2009-06-02 01:32+0900\n"
"Last-Translator: Daisuke Sano <d-sano@nri.co.jp>\n"
"Language-Team: none\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#. Tag: title
#: injection.xml:4
#, no-c-format
msgid "Dependency injection"
msgstr "依存性注入"

#. Tag: para
#: injection.xml:6
#, no-c-format
msgid "Web Beans supports three primary mechanisms for dependency injection:"
msgstr "Web Beansは依存性注入のための3つの基本的な機構を持っています。"

#. Tag: para
#: injection.xml:8
#, no-c-format
msgid "Constructor parameter injection:"
msgstr "コンストラクタの引数による注入、"

#. Tag: programlisting
#: injection.xml:10
#, no-c-format
msgid ""
"<![CDATA[public class Checkout {\n"
"        \n"
"    private final ShoppingCart cart;\n"
"    \n"
"    @Initializer\n"
"    public Checkout(ShoppingCart cart) {\n"
"        this.cart = cart;\n"
"    }\n"
"\n"
"}]]>"
msgstr ""
"<![CDATA[public class Checkout {\n"
"        \n"
"    private final ShoppingCart cart;\n"
"    \n"
"    @Initializer\n"
"    public Checkout(ShoppingCart cart) {\n"
"        this.cart = cart;\n"
"    }\n"
"\n"
"}]]>"

#. Tag: para
#: injection.xml:12
#, no-c-format
msgid "<emphasis>Initializer</emphasis> method parameter injection:"
msgstr "<emphasis>初期化</emphasis>メソッドの引数による注入、"

#. Tag: programlisting
#: injection.xml:14
#, no-c-format
msgid ""
"<![CDATA[public class Checkout {\n"
"        \n"
"    private ShoppingCart cart;\n"
"\n"
"    @Initializer \n"
"    void setShoppingCart(ShoppingCart cart) {\n"
"        this.cart = cart;\n"
"    }\n"
"    \n"
"}]]>"
msgstr ""
"<![CDATA[public class Checkout {\n"
"        \n"
"    private ShoppingCart cart;\n"
"\n"
"    @Initializer \n"
"    void setShoppingCart(ShoppingCart cart) {\n"
"        this.cart = cart;\n"
"    }\n"
"    \n"
"}]]>"

#. Tag: para
#: injection.xml:16
#, no-c-format
msgid "And direct field injection:"
msgstr "そして、フィールドへの直接的な注入です。"

#. Tag: programlisting
#: injection.xml:18
#, no-c-format
msgid ""
"<![CDATA[public class Checkout {\n"
"\n"
"    private @Current ShoppingCart cart;\n"
"    \n"
"}]]>"
msgstr ""
"<![CDATA[public class Checkout {\n"
"\n"
"    private @Current ShoppingCart cart;\n"
"    \n"
"}]]>"

#. Tag: para
#: injection.xml:20
#, no-c-format
msgid "Dependency injection always occurs when the Web Bean instance is first instantiated."
msgstr "依存性注入は、Web Beanインスタンスが最初に生成される際に必ず行われます。"

#. Tag: para
#: injection.xml:25
#, no-c-format
msgid "First, the Web Bean manager calls the Web Bean constructor, to obtain an instance of the Web Bean."
msgstr "最初に、Web Beanマネージャは、Web Beanインスタンスを取得するために、Web Beanのコンストラクタを実行する"

#. Tag: para
#: injection.xml:29
#, no-c-format
msgid "Next, the Web Bean manager initializes the values of all injected fields of the Web Bean."
msgstr "次に、Web Beanマネージャは、Web Beanの、注入すべきすべてのフィールド値を初期化する"

#. Tag: para
#: injection.xml:33
#, no-c-format
msgid "Next, the Web Bean manager calls all initializer methods of Web Bean."
msgstr "次に、Web Beanマネージャは、Web Beanの、すべての初期化メソッドを実行する"

#. Tag: para
#: injection.xml:37
#, no-c-format
msgid "Finally, the <literal>@PostConstruct</literal> method of the Web Bean, if any, is called."
msgstr "最後に、もしあれば、Web Beanの<literal>@PostConstruct</literal>メソッドが呼ばれます。"

#. Tag: para
#: injection.xml:42
#, no-c-format
msgid "Constructor parameter injection is not supported for EJB beans, since the EJB is instantiated by the EJB container, not the Web Bean manager."
msgstr "コンストラクタの引数による注入は、EJBには使用することができません。なぜならば、EJBはWeb Beanマネージャではなく、EJBコンテナによって初期化が行われるからです。"

#. Tag: para
#: injection.xml:45
#, no-c-format
msgid "Parameters of constructors and initializer methods need not be explicitly annotated when the default binding type <literal>@Current</literal> applies. Injected fields, however, <emphasis>must</emphasis> specify a binding type, even when the default binding type applies. If the field does not specify a binding type, it will not be injected."
msgstr "コンストラクタや初期化メソッドの引数で注入を行う場合には、デフォルトで<literal>@Current</literal>バインディングタイプが適用されるので、明示的なアノテーションは必要ありません。しかしながら、フィールドへの直接的な注入を行う場合には、デフォルトのバインディングタイプで良い場合でも、バインディングタイプを指定<emphasis>しなければなりません</emphasis>。バインディングタイプを指定しない場合は、注入は行われません。"

#. Tag: para
#: injection.xml:51
#, no-c-format
msgid "Producer methods also support parameter injection:"
msgstr "プロデューサメソッドもまた、引数による注入を可能とします。"

#. Tag: programlisting
#: injection.xml:53
#, no-c-format
msgid ""
"<![CDATA[@Produces Checkout createCheckout(ShoppingCart cart) {\n"
"    return new Checkout(cart);\n"
"}]]>"
msgstr ""
"<![CDATA[@Produces Checkout createCheckout(ShoppingCart cart) {\n"
"    return new Checkout(cart);\n"
"}]]>"

#. Tag: para
#: injection.xml:55
#, no-c-format
msgid "Finally, observer methods (which we'll meet in <xref linkend=\"events\"/>), disposal methods and destructor methods all support parameter injection."
msgstr "結局、オブザーバメソッド（<xref linkend=\"events\"/>で紹介します）や、ディスポーザルメソッド、デストラクタでも引数による注入が可能です。"

#. Tag: para
#: injection.xml:58
#, no-c-format
msgid "The Web Beans specification defines a procedure, called the <emphasis>typesafe resolution algorithm</emphasis>, that the Web Bean manager follows when identifying the Web Bean to inject to an injection point. This algorithm looks complex at first, but once you understand it, it's really quite intuitive. Typesafe resolution is performed at system initialization time, which means that the manager will inform the user immediately if a Web Bean's dependencies cannot be satisfied, by throwing a <literal>UnsatisfiedDependencyException</literal> or <literal>AmbiguousDependencyException</literal>."
msgstr "Web Beansの仕様では、<emphasis>タイプセーフ解決アルゴリズム</emphasis>が定義されており、Web Beanマネージャは、ある注入箇所への注入を行う際、これにのっとって、注入すべきWeb Beanを特定します。このアルゴリズムは最初は複雑に感じますが、一度理解してしまえば、とても直観的なものです。タイプセーフ解決アルゴリズムは、システムの初期化時に使われます。これは、もしWeb Beanの依存性が充たされない場合には、マネージャが<literal>UnsatisfiedDependencyException</literal>や<literal>AmbiguousDependencyException</literal>をスローすることによって、即座にそれをユーザに通知することを意味します。"

#. Tag: para
#: injection.xml:67
#, no-c-format
msgid "The purpose of this algorithm is to allow multiple Web Beans to implement the same API type and either:"
msgstr "このアルゴリズムの目的は、複数のWeb Beanが同じAPIを実装できるようにすることであり、"

#. Tag: para
#: injection.xml:72
#, no-c-format
msgid "allow the client to select which implementation it requires using <emphasis>binding annotations</emphasis>,"
msgstr "<emphasis>バインディングアノテーション</emphasis>を使用することによって、クライアントが必要とする実装を選択できるようにする"

#. Tag: para
#: injection.xml:77
#, no-c-format
msgid "allow the application deployer to select which implementation is appropriate for a particular deployment, without changes to the client, by enabling or disabling <emphasis>deployment types</emphasis>, or"
msgstr "アプリケーションをデプロイする際に<emphasis>デプロイメントタイプ</emphasis>を有効にしたり無効にしたりすることによって、クライアントを変更することなく、特定の環境に対して適切な実装を選択できるようにする"

#. Tag: para
#: injection.xml:82
#, no-c-format
msgid "allow one implementation of an API to override another implementation of the same API at deployment time, without changes to the client, using <emphasis>deployment type precedence</emphasis>."
msgstr "<emphasis>デプロイメントタイプの優先度</emphasis>を使用することによって、クライアントを変更することなく、APIのとある実装が同じAPIの異なる実装を、デプロイメント時に上書きできるようにする"

#. Tag: para
#: injection.xml:88
#, no-c-format
msgid "Let's explore how the Web Beans manager determines a Web Bean to be injected."
msgstr "それでは、Web Beanマネージャが注入すべきWeb Beanをどのように決定していくのかを見ていくことにしましょう。"

#. Tag: title
#: injection.xml:91
#, no-c-format
msgid "Binding annotations"
msgstr "バインディングアノテーション"

#. Tag: para
#: injection.xml:93
#, no-c-format
msgid "If we have more than one Web Bean that implements a particular API type, the injection point can specify exactly which Web Bean should be injected using a binding annotation. For example, there might be two implementations of <literal>PaymentProcessor</literal>:"
msgstr "もし一つより多いWeb Beanが特定のAPIを実装している場合、注入箇所では、バインディングアノテーションを使用することによって、どのWeb Beanが注入されるべきかということが正確に指定されます。例えば、ここに<literal>PaymentProcessor</literal>に対する二つの実装が存在するとします。"

#. Tag: programlisting
#: injection.xml:98
#, no-c-format
msgid ""
"<![CDATA[@PayByCheque\n"
"public class ChequePaymentProcessor implements PaymentProcessor {\n"
"    public void process(Payment payment) { ... }\n"
"}]]>"
msgstr ""
"<![CDATA[@PayByCheque\n"
"public class ChequePaymentProcessor implements PaymentProcessor {\n"
"    public void process(Payment payment) { ... }\n"
"}]]>"

#. Tag: programlisting
#: injection.xml:100
#, no-c-format
msgid ""
"<![CDATA[@PayByCreditCard\n"
"public class CreditCardPaymentProcessor implements PaymentProcessor {\n"
"    public void process(Payment payment) { ... }\n"
"}]]>"
msgstr ""
"<![CDATA[@PayByCreditCard\n"
"public class CreditCardPaymentProcessor implements PaymentProcessor {\n"
"    public void process(Payment payment) { ... }\n"
"}]]>"

#. Tag: para
#: injection.xml:102
#, no-c-format
msgid "Where <literal>@PayByCheque</literal> and <literal>@PayByCreditCard</literal> are binding annotations:"
msgstr "ここで、<literal>@PayByCheque</literal>と<literal>@PayByCreditCard</literal>はバインディングアノテーションです。"

#. Tag: programlisting
#: injection.xml:105
#, no-c-format
msgid ""
"<![CDATA[@Retention(RUNTIME)\n"
"@Target({TYPE, METHOD, FIELD, PARAMETER})\n"
"@BindingType\n"
"public @interface PayByCheque {}]]>"
msgstr ""
"<![CDATA[@Retention(RUNTIME)\n"
"@Target({TYPE, METHOD, FIELD, PARAMETER})\n"
"@BindingType\n"
"public @interface PayByCheque {}]]>"

#. Tag: programlisting
#: injection.xml:107
#, no-c-format
msgid ""
"<![CDATA[@Retention(RUNTIME)\n"
"@Target({TYPE, METHOD, FIELD, PARAMETER})\n"
"@BindingType\n"
"public @interface PayByCreditCard {}]]>"
msgstr ""
"<![CDATA[@Retention(RUNTIME)\n"
"@Target({TYPE, METHOD, FIELD, PARAMETER})\n"
"@BindingType\n"
"public @interface PayByCreditCard {}]]>"

#. Tag: para
#: injection.xml:109
#, no-c-format
msgid "A client Web Bean developer uses the binding annotation to specify exactly which Web Bean should be injected."
msgstr "クライアントWeb Beanの開発者は、バインディングアノテーションを使用することによって、どのWeb Beanが注入されるべきかということを、正確に指定することができます。"

#. Tag: para
#: injection.xml:112
#, no-c-format
msgid "Using field injection:"
msgstr "フィールドに注入することができます。"

#. Tag: programlisting
#: injection.xml:114
#, no-c-format
msgid ""
"<![CDATA[@PayByCheque PaymentProcessor chequePaymentProcessor;\n"
"@PayByCreditCard PaymentProcessor creditCardPaymentProcessor;]]>"
msgstr ""
"<![CDATA[@PayByCheque PaymentProcessor chequePaymentProcessor;\n"
"@PayByCreditCard PaymentProcessor creditCardPaymentProcessor;]]>"

#. Tag: para
#: injection.xml:116
#, no-c-format
msgid "Using initializer method injection:"
msgstr "初期化メソッドを使用して注入することもできます。"

#. Tag: programlisting
#: injection.xml:118
#, no-c-format
msgid ""
"<![CDATA[@Initializer\n"
"public void setPaymentProcessors(@PayByCheque PaymentProcessor chequePaymentProcessor, \n"
"                                 @PayByCreditCard PaymentProcessor creditCardPaymentProcessor) {\n"
"   this.chequePaymentProcessor = chequePaymentProcessor;\n"
"   this.creditCardPaymentProcessor = creditCardPaymentProcessor;\n"
"}]]>"
msgstr ""
"<![CDATA[@Initializer\n"
"public void setPaymentProcessors(@PayByCheque PaymentProcessor chequePaymentProcessor, \n"
"                                 @PayByCreditCard PaymentProcessor creditCardPaymentProcessor) {\n"
"   this.chequePaymentProcessor = chequePaymentProcessor;\n"
"   this.creditCardPaymentProcessor = creditCardPaymentProcessor;\n"
"}]]>"

#. Tag: para
#: injection.xml:120
#, no-c-format
msgid "Or using constructor injection:"
msgstr "そして、コンストラクタを使用して注入することもできます。"

#. Tag: programlisting
#: injection.xml:122
#, no-c-format
msgid ""
"<![CDATA[@Initializer\n"
"public Checkout(@PayByCheque PaymentProcessor chequePaymentProcessor, \n"
"                @PayByCreditCard PaymentProcessor creditCardPaymentProcessor) {\n"
"   this.chequePaymentProcessor = chequePaymentProcessor;\n"
"   this.creditCardPaymentProcessor = creditCardPaymentProcessor;\n"
"}]]>"
msgstr ""
"<![CDATA[@Initializer\n"
"public Checkout(@PayByCheque PaymentProcessor chequePaymentProcessor, \n"
"                @PayByCreditCard PaymentProcessor creditCardPaymentProcessor) {\n"
"   this.chequePaymentProcessor = chequePaymentProcessor;\n"
"   this.creditCardPaymentProcessor = creditCardPaymentProcessor;\n"
"}]]>"

#. Tag: title
#: injection.xml:125
#, no-c-format
msgid "Binding annotations with members"
msgstr "メンバー付きのバインディングアノテーション"

#. Tag: para
#: injection.xml:127
#, no-c-format
msgid "Binding annotations may have members:"
msgstr "バインディングアノテーションはメンバーを持つことができます。"

#. Tag: programlisting
#: injection.xml:129
#, no-c-format
msgid ""
"<![CDATA[@Retention(RUNTIME)\n"
"@Target({TYPE, METHOD, FIELD, PARAMETER})\n"
"@BindingType\n"
"public @interface PayBy {\n"
"    PaymentType value();\n"
"}]]>"
msgstr ""
"<![CDATA[@Retention(RUNTIME)\n"
"@Target({TYPE, METHOD, FIELD, PARAMETER})\n"
"@BindingType\n"
"public @interface PayBy {\n"
"    PaymentType value();\n"
"}]]>"

#. Tag: para
#: injection.xml:131
#, no-c-format
msgid "In which case, the member value is significant:"
msgstr "このような場合には、メンバーの値が重要な意味を持ちます。"

#. Tag: programlisting
#: injection.xml:133
#, no-c-format
msgid ""
"<![CDATA[@PayBy(CHEQUE) PaymentProcessor chequePaymentProcessor;\n"
"@PayBy(CREDIT_CARD) PaymentProcessor creditCardPaymentProcessor;]]>"
msgstr ""
"<![CDATA[@PayBy(CHEQUE) PaymentProcessor chequePaymentProcessor;\n"
"@PayBy(CREDIT_CARD) PaymentProcessor creditCardPaymentProcessor;]]>"

#. Tag: para
#: injection.xml:135
#, no-c-format
msgid "You can tell the Web Bean manager to ignore a member of a binding annotation type by annotating the member <literal>@NonBinding</literal>."
msgstr "バインディングアノテーションタイプのメンバーに@NonBindingアノテーションをつけることによって、Web Beanマネージャがメンバを無視するように指定することもできます。"

#. Tag: title
#: injection.xml:141
#, no-c-format
msgid "Combinations of binding annnotations"
msgstr "バインディングアノテーションの組み合わせ"

#. Tag: para
#: injection.xml:143
#, no-c-format
msgid "An injection point may even specify multiple binding annotations:"
msgstr "注入箇所に、複数のバインディングアノテーションを指定することもできます。"

#. Tag: programlisting
#: injection.xml:145
#, no-c-format
msgid "<![CDATA[@Asynchronous @PayByCheque PaymentProcessor paymentProcessor]]>"
msgstr "<![CDATA[@Asynchronous @PayByCheque PaymentProcessor paymentProcessor]]>"

#. Tag: para
#: injection.xml:147
#, no-c-format
msgid "In this case, only a Web Bean which has <emphasis>both</emphasis> binding annotations would be eligible for injection."
msgstr "このような場合、<emphasis>両方の</emphasis>バインディングアノテーションを持つWeb Beanのみが、注入する対象として適格となります。"

#. Tag: title
#: injection.xml:153
#, no-c-format
msgid "Binding annotations and producer methods"
msgstr "バインディングアノテーションとプロデューサメソッド"

#. Tag: para
#: injection.xml:155
#, no-c-format
msgid "Even producer methods may specify binding annotations:"
msgstr "プロデューサメソッドでバインディングアノテーションを指定することもできます。"

#. Tag: programlisting
#: injection.xml:157
#, no-c-format
msgid ""
"<![CDATA[@Produces \n"
"@Asynchronous @PayByCheque \n"
"PaymentProcessor createAsyncPaymentProcessor(@PayByCheque PaymentProcessor processor) {\n"
"    return new AsynchronousPaymentProcessor(processor);\n"
"}]]>"
msgstr ""
"<![CDATA[@Produces \n"
"@Asynchronous @PayByCheque \n"
"PaymentProcessor createAsyncPaymentProcessor(@PayByCheque PaymentProcessor processor) {\n"
"    return new AsynchronousPaymentProcessor(processor);\n"
"}]]>"

#. Tag: title
#: injection.xml:162
#, no-c-format
msgid "The default binding type"
msgstr "デフォルトのバインディングタイプ"

#. Tag: para
#: injection.xml:164
#, no-c-format
msgid "Web Beans defines a binding type <literal>@Current</literal> that is the default binding type for any injection point or Web Bean that does not explicitly specify a binding type."
msgstr "Web Beansでは、デフォルトのバインディングタイプ<literal>@Current</literal>が定義されており、明示的なバインディングタイプの指定が行われていないすべての注入箇所やWeb Beanに適用されます。"

#. Tag: para
#: injection.xml:168
#, no-c-format
msgid "There are two common circumstances in which it is necessary to explicitly specify <literal>@Current</literal>:"
msgstr "以下の二つの状況においては、<literal>@Current</literal>を明示的に指定する必要があります。"

#. Tag: para
#: injection.xml:173
#, no-c-format
msgid "on a field, in order to declare it as an injected field with the default binding type, and"
msgstr "フィールドの定義において、そのフィールドがデフォルトのバインディングタイプによって注入される（フィールドが持つ型によって解決される）フィールドであることを宣言する場合"

#. Tag: para
#: injection.xml:177
#, no-c-format
msgid "on a Web Bean which has another binding type in addition to the default binding type."
msgstr "Web Beanの定義において、そのWeb Beanがデフォルトのバインディングタイプ（Web Beanが持つ型によって解決される）に加えて別のバインディングタイプを持つ場合"

#. Tag: title
#: injection.xml:187
#, no-c-format
msgid "Deployment types"
msgstr "デプロイメントタイプ"

#. Tag: para
#: injection.xml:189
#, no-c-format
msgid "All Web Beans have a <emphasis>deployment type</emphasis>. Each deployment type identifies a set of Web Beans that should be conditionally installed in some deployments of the system."
msgstr "すべてのWeb Beanは<emphasis>デプロイメントタイプ</emphasis>を持ちます。それぞれのデプロイメントタイプは、システムのある構成の下で条件つきでインストールされるべきWeb Beanの集合を規定します。"

#. Tag: para
#: injection.xml:193
#, no-c-format
msgid "For example, we could define a deployment type named <literal>@Mock</literal>, which would identify Web Beans that should only be installed when the system executes inside an integration testing environment:"
msgstr "例えば、<literal>@Mock</literal>という名前のデプロイメントタイプを定義し、結合テスト環境の中でシステムが稼動するときにのみインストールされるべきWeb Beanを規定するようなことができます。"

#. Tag: programlisting
#: injection.xml:197
#, no-c-format
msgid ""
"<![CDATA[@Retention(RUNTIME)\n"
"  @Target({TYPE, METHOD})\n"
"  @DeploymentType\n"
"  public @interface Mock {}]]>"
msgstr ""
"<![CDATA[@Retention(RUNTIME)\n"
"  @Target({TYPE, METHOD})\n"
"  @DeploymentType\n"
"  public @interface Mock {}]]>"

#. Tag: para
#: injection.xml:199
#, no-c-format
msgid "Suppose we had some Web Bean that interacted with an external system to process payments:"
msgstr "支払い処理を行う外部システムに関連したあるWeb Beanがあると想定します。"

#. Tag: programlisting
#: injection.xml:202
#, no-c-format
msgid ""
"<![CDATA[public class ExternalPaymentProcessor {\n"
"        \n"
"    public void process(Payment p) {\n"
"        ...\n"
"    }\n"
"    \n"
"}]]>"
msgstr ""
"<![CDATA[public class ExternalPaymentProcessor {\n"
"        \n"
"    public void process(Payment p) {\n"
"        ...\n"
"    }\n"
"    \n"
"}]]>"

#. Tag: para
#: injection.xml:204
#, no-c-format
msgid "Since this Web Bean does not explicitly specify a deployment type, it has the default deployment type <literal>@Production</literal>."
msgstr "このWeb Beanは明示的にデプロイメントタイプが指定されていないので、デフォルトのデプロイメントタイプである<literal>@Production</literal>を持つことになります。"

#. Tag: para
#: injection.xml:207
#, no-c-format
msgid "For integration or unit testing, the external system is slow or unavailable. So we would create a mock object:"
msgstr "結合テストや単体テストを行う際に、外部システムの処理が遅かったり、使用できなかったりする場合には、このようにモックオブジェクトを作成することでしょう。"

#. Tag: programlisting
#: injection.xml:210
#, no-c-format
msgid ""
"<![CDATA[@Mock \n"
"public class MockPaymentProcessor implements PaymentProcessor {\n"
"\n"
"    @Override\n"
"    public void process(Payment p) {\n"
"        p.setSuccessful(true);\n"
"    }\n"
"\n"
"}]]>"
msgstr ""
"<![CDATA[@Mock \n"
"public class MockPaymentProcessor implements PaymentProcessor {\n"
"\n"
"    @Override\n"
"    public void process(Payment p) {\n"
"        p.setSuccessful(true);\n"
"    }\n"
"\n"
"}]]>"

#. Tag: para
#: injection.xml:212
#, no-c-format
msgid "But how does the Web Bean manager determine which implementation to use in a particular deployment?"
msgstr "しかし、Web Beamマネージャは一体どのようにして、そのような特定の環境で使われる実装を決定するのでしょうか？"

#. Tag: title
#: injection.xml:216
#, no-c-format
msgid "Enabling deployment types"
msgstr "デプロイメントタイプを有効にする"

#. Tag: para
#: injection.xml:218
#, no-c-format
msgid "Web Beans defines two built-in deployment types: <literal>@Production</literal> and <literal>@Standard</literal>. By default, only Web Beans with the built-in deployment types are enabled when the system is deployed. We can identify additional deployment types to be enabled in a particular deployment by listing them in <literal>web-beans.xml</literal>."
msgstr "Web Beansは、<literal>@Production</literal>と<literal>@Standard</literal>という、二つの組み込みデプロイメントタイプを定めています。システムがデプロイされた際に、デフォルトでは、組み込みデプロイメントタイプを持つWeb Beanのみが有効となります。特定の環境で有効となるような付加的なデプロイメントタイプを規定するためには、それらを<literal>web-beans.xml</literal>に列挙します。"

#. Tag: para
#: injection.xml:224
#, no-c-format
msgid "Going back to our example, when we deploy our integration tests, we want all our <literal>@Mock</literal> objects to be installed:"
msgstr "先程の例に戻ると、結合テストをデプロイするには、すべての<literal>@Mock</literal>オブジェクトをインストールする必要があります。"

#. Tag: programlisting
#: injection.xml:227
#, no-c-format
msgid ""
"<![CDATA[<WebBeans>\n"
"    <Deploy>\n"
"        <Standard/>\n"
"        <Production/>\n"
"        <test:Mock/>\n"
"    </Deploy>\n"
"</WebBeans>]]>"
msgstr ""
"<![CDATA[<WebBeans>\n"
"    <Deploy>\n"
"        <Standard/>\n"
"        <Production/>\n"
"        <test:Mock/>\n"
"    </Deploy>\n"
"</WebBeans>]]>"

#. Tag: para
#: injection.xml:229
#, no-c-format
msgid "Now the Web Bean manager will identify and install all Web Beans annotated <literal>@Production</literal>, <literal>@Standard</literal> or <literal>@Mock</literal> at deployment time."
msgstr "このようにすることで、Web Beanマネージャは、デプロイ時に、<literal>@Production</literal>、<literal>@Standard</literal>、<literal>@Mock</literal>のアノテーションが付加されたすべてのWeb Beanを規定し、インストールします。"

#. Tag: para
#: injection.xml:233
#, no-c-format
msgid "The deployment type <literal>@Standard</literal> is used only for certain special Web Beans defined by the Web Beans specification. We can't use it for our own Web Beans, and we can't disable it."
msgstr "<literal>@Standard</literal>デプロイメントタイプは、Web Beans仕様で定められた、ある特別なWeb Beanに対してのみ使用されます。開発者が作成したWeb Beanに対してこれを使用したり、デプロイメントタイプを無効にしたりすることはできません。"

#. Tag: para
#: injection.xml:237
#, no-c-format
msgid "The deployment type <literal>@Production</literal> is the default deployment type for Web Beans which don't explicitly declare a deployment type, and may be disabled."
msgstr "<literal>@Production</literal>デプロイメントタイプは、明示的にデプロイメントタイプが宣言されないWeb Beanのデフォルトのデプロイメントタイプであり、無効にすることもできます。"

#. Tag: title
#: injection.xml:244
#, no-c-format
msgid "Deployment type precedence"
msgstr "デプロイメントタイプの優先度"

#. Tag: para
#: injection.xml:246
#, no-c-format
msgid "If you've been paying attention, you're probably wondering how the Web Bean manager decides which implementation &#151; <literal>ExternalPaymentProcessor</literal> or <literal>MockPaymentProcessor</literal> &#151; to choose. Consider what happens when the manager encounters this injection point:"
msgstr "ここまで注意深く読み進めてきた方は、Web Beanマネージャが、一体どうやって<literal>ExternalPaymentProcessor</literal>と<literal>MockPaymentProcessor</literal>のどちらの実装を選択するかを決定するのかという点について、疑問に思われるかもしれません。マネージャがこのような注入箇所に遭遇した場合に、何が起こっているのかを考えてみましょう。"

#. Tag: programlisting
#: injection.xml:251
#, no-c-format
msgid "<![CDATA[@Current PaymentProcessor paymentProcessor]]>"
msgstr "<![CDATA[@Current PaymentProcessor paymentProcessor]]>"

#. Tag: para
#: injection.xml:253
#, no-c-format
msgid "There are now two Web Beans which satisfy the <literal>PaymentProcessor</literal> contract. Of course, we can't use a binding annotation to disambiguate, since binding annotations are hard-coded into the source at the injection point, and we want the manager to be able to decide at deployment time!"
msgstr "今、<literal>PaymentProcessor</literal>の条件を充たす二つのWeb Beanが存在します。もちろん、曖昧さを排除するようなバインディングアノテーションを用いることはできません。なぜならば、そうするにはバインディングアノテーションをソースの注入箇所にハードコーディングする必要があり、我々が行いたいのはそうではなく、デプロイ時に、マネージャによって決定されるようにしたいからです。"

#. Tag: para
#: injection.xml:258
#, no-c-format
msgid "The solution to this problem is that each deployment type has a different <emphasis>precedence</emphasis>. The precedence of the deployment types is determined by the order in which they appear in <literal>web-beans.xml</literal>. In our example, <literal>@Mock</literal> appears later than <literal>@Production</literal> so it has a higher precedence."
msgstr "このような問題への解として、それぞれのデプロイメントタイプは異なる<emphasis>優先度</emphasis>を持ちます。デプロイメントタイプの優先度は、それらが<literal>web-beans.xml</literal>に現れる順番によって決まります。今回の例では、<literal>@Mock</literal>は<literal>@Production</literal>の後に現れるので、<literal>@Mock</literal>の方が高い優先度を持つことになります。"

#. Tag: para
#: injection.xml:264
#, no-c-format
msgid "Whenever the manager discovers that more than one Web Bean could satisfy the contract (API type plus binding annotations) specified by an injection point, it considers the relative precedence of the Web Beans. If one has a higher precedence than the others, it chooses the higher precedence Web Bean to inject. So, in our example, the Web Bean manager will inject <literal>MockPaymentProcessor</literal> when executing in our integration testing environment (which is exactly what we want)."
msgstr "マネージャは、ある注入箇所によって指定される条件（APIタイプやバインディングアノテーション）を充たしうるWeb Beanが一つより多く存在することを発見した場合、Web Beanの相対的な優先度を考慮します。もし、あるWeb Beanが他より高い優先度をもっているならば、そのWeb Beanが選択され、注入されます。今回の例では、結合テスト環境で実行する場合に、Web Beanマネージャは<literal>MockPaymentProcessor</literal>を注入することになります（これが、まさに望みどおりの動作です）。"

#. Tag: para
#: injection.xml:271
#, no-c-format
msgid "It's interesting to compare this facility to today's popular manager architectures. Various \"lightweight\" containers also allow conditional deployment of classes that exist in the classpath, but the classes that are to be deployed must be explicity, individually, listed in configuration code or in some XML configuration file. Web Beans does support Web Bean definition and configuration via XML, but in the common case where no complex configuration is required, deployment types allow a whole set of Web Beans to be enabled with a single line of XML. Meanwhile, a developer browsing the code can easily identify what deployment scenarios the Web Bean will be used in."
msgstr "このような仕組みを、最近の人気のあるマネージャのアーキテクチャと比較すると面白いでしょう。様々な、いわゆる\"軽量\"コンテナにおいて、クラスパスに存在するクラスを条件つきでデプロイすることは可能です。しかし、それらは、設定のためのコードやXMLの設定ファイルに設定を列挙することよって、あくまで明示的に、そして個別に行わなければなりません。WebnBeansでは、Web Beanの設定をXMLを通じて定義することもできますが、複雑な設定が必要ない通常の場合においては、デプロイメントタイプによってすべてのWeb Beanの集合をXML中の一行で有効にすることができます。と同時に、開発者はコードを見るだけで、簡単に、そのWeb Beanがどのシナリオにおいて使用されるのかということをつきとめることができます。"

#. Tag: title
#: injection.xml:284
#, no-c-format
msgid "Example deployment types"
msgstr "デプロイメントタイプの例"

#. Tag: para
#: injection.xml:286
#, no-c-format
msgid "Deployment types are useful for all kinds of things, here's some examples:"
msgstr "デプロイメントタイプは様々な用途に使用できます。以下に例を示します。"

#. Tag: para
#: injection.xml:290
#, no-c-format
msgid "<literal>@Mock</literal> and <literal>@Staging</literal> deployment types for testing"
msgstr "テスト作業における<literal>@Mock</literal>や<literal>@Staging</literal>の使用"

#. Tag: para
#: injection.xml:294
#, no-c-format
msgid "<literal>@AustralianTaxLaw</literal> for site-specific Web Beans"
msgstr "特定のサイトに依存するWeb Beanにおける<literal>@AustralianTaxLaw</literal>の使用"

#. Tag: para
#: injection.xml:297
#, no-c-format
msgid "<literal>@SeamFramework</literal>, <literal>@Guice</literal> for third-party frameworks which build on Web Beans"
msgstr "Web Beansの上に構築されたサードパーティのフレームワークにおける<literal>@SeamFramework</literal>や<literal>@Guice</literal>の使用"

#. Tag: para
#: injection.xml:301
#, no-c-format
msgid "<literal>@Standard</literal> for standard Web Beans defined by the Web Beans specification"
msgstr "Web Beans仕様によって定義された標準Web Beanにおける<literal>@Standard</literal>の使用"

#. Tag: para
#: injection.xml:306
#, no-c-format
msgid "I'm sure you can think of more applications..."
msgstr "他にも色々な使用方法が考えられるかと思います。"

#. Tag: title
#: injection.xml:313
#, no-c-format
msgid "Fixing unsatisfied dependencies"
msgstr "依存性を充たすように修正する"

#. Tag: para
#: injection.xml:315
#, no-c-format
msgid "The typesafe resolution algorithm fails when, after considering the binding annotations and and deployment types of all Web Beans that implement the API type of an injection point, the Web Bean manager is unable to identify exactly one Web Bean to inject."
msgstr "注入箇所のAPIタイプを実装したすべてのWeb Beanのバインディングアノテーションやデプロイメントタイプを考慮した結果、Web Beanマネージャが注入すべきWeb Beanを一つに絞りきれない場合、タイプセーフな解決アルゴリズムは失敗します。"

#. Tag: para
#: injection.xml:320
#, no-c-format
msgid "It's usually easy to fix an <literal>UnsatisfiedDependencyException</literal> or <literal>AmbiguousDependencyException</literal>."
msgstr "通常、<literal>UnsatisfiedDependencyException</literal>や<literal>AmbiguousDependencyException</literal>を修正することは簡単です。"

#. Tag: para
#: injection.xml:323
#, no-c-format
msgid "To fix an <literal>UnsatisfiedDependencyException</literal>, simply provide a Web Bean which implements the API type and has the binding types of the injection point &#151; or enable the deployment type of a Web Bean that already implements the API type and has the binding types."
msgstr "<literal>UnsatisfiedDependencyException</literal>を修正するには、単に、注入箇所のAPIタイプを実装し、バインディングタイプを持つようなWeb Beanを作成するか、既にAPIタイプを実装し、バインディングタイプを持ったWeb Beanのデプロイメントタイプを有効にするだけです。"

#. Tag: para
#: injection.xml:328
#, no-c-format
msgid "To fix an <literal>AmbiguousDependencyException</literal>, introduce a binding type to distinguish between the two implementations of the API type, or change the deployment type of one of the implementations so that the Web Bean manager can use deployment type precedence to choose between them. An <literal>AmbiguousDependencyException</literal> can only occur if two Web Beans share a binding type and have exactly the same deployment type."
msgstr "<literal>AmbiguousDependencyException</literal>を修正するには、APIタイプを実装する二つのWeb Beanを区別することができるバインディングタイプを導入するか、もしくは、片方のWeb Beanのデプロイメントタイプを変更し、Web Beanマネージャがデプロイメントタイプの優先度によってどちらかを選択できるようにします。<literal>AmbiguousDependencyException</literal>は、二つのWeb Beanがバインディングタイプを共有し、全く同じデプロイメントタイプを持つときにのみ、起こり得ます。"

#. Tag: para
#: injection.xml:335
#, no-c-format
msgid "There's one more issue you need to be aware of when using dependency injection in Web Beans."
msgstr "Web Beansにおける依存性注入を行う際に気をつけるべきことが、もう少しあります。"

#. Tag: title
#: injection.xml:341
#, no-c-format
msgid "Client proxies"
msgstr "クライアントプロキシ"

#. Tag: para
#: injection.xml:343
#, no-c-format
msgid "Clients of an injected Web Bean do not usually hold a direct reference to a Web Bean instance."
msgstr "注入されたWeb Beanのクライアントは、通常、Web Beanインスタンスに対する直接的な参照を持ちません。"

#. Tag: para
#: injection.xml:346
#, no-c-format
msgid "Imagine that a Web Bean bound to the application scope held a direct reference to a Web Bean bound to the request scope. The application scoped Web Bean is shared between many different requests. However, each request should see a different instance of the request scoped Web bean!"
msgstr "アプリケーションスコープに結び付けられたWeb Beanが、リクエストスコープに結び付けられたWeb Beanに対する直接的な参照を持っている場合を想像してみてください。アプリケーションスコープのWeb Beanは、たくさんの異なるリクエスト間で共有されます。しかしながら、それぞれのリクエストは、それぞれ異なったリクエストスコープのWeb Beanインスタンスを参照するべきなのです。"

#. Tag: para
#: injection.xml:351
#, no-c-format
msgid "Now imagine that a Web Bean bound to the session scope held a direct reference to a Web Bean bound to the application scope. From time to time, the session context is serialized to disk in order to use memory more efficiently. However, the application scoped Web Bean instance should not be serialized along with the session scoped Web Bean!"
msgstr "今度は、セッションスコープに結び付けられたWeb Beanが、アプリケーションスコープに結び付けられたWeb Beanに対する直接的な参照を持っている場合を想像してみてください。セッションコンテキストは、メモリを効率的に使う目的で、時々ディスクにシリアライズされます。しかしながら、アプリケーションスコープのWeb Beanインスタンスは、セッションスコープのWeb Beanインスタンスと一緒にシリアライズされるべきではないのです。"

#. Tag: para
#: injection.xml:357
#, no-c-format
msgid "Therefore, unless a Web Bean has the default scope <literal>@Dependent</literal>, the Web Bean manager must indirect all injected references to the Web Bean through a proxy object. This <emphasis>client proxy</emphasis> is responsible for ensuring that the Web Bean instance that receives a method invocation is the instance that is associated with the current context. The client proxy also allows Web Beans bound to contexts such as the session context to be serialized to disk without recursively serializing other injected Web Beans."
msgstr "それゆえWeb Beanマネージャは、Web Beanがデフォルトスコープである<literal>@Dependent</literal>を持っていない限り、すべての注入されたWeb Beanへの参照を、プロキシオブジェクトを通じて間接的に行わなければなりません。この<emphasis>クライアントプロキシ</emphasis>は、メソッドが起動されるWeb Beanインスタンスと、現在のコンテキストに結びついたインスタンスが同一であることを保証する責任を持ちます。またクライアントプロキシは、セッションコンテキストのようなコンテキストに結び付けられたWeb Beanが、他の注入されたWeb Beanを再帰的にシリアライズすることなく、シリアライズすることを可能とします。"

#. Tag: para
#: injection.xml:365
#, no-c-format
msgid "Unfortunately, due to limitations of the Java language, some Java types cannot be proxied by the Web Bean manager. Therefore, the Web Bean manager throws an <literal>UnproxyableDependencyException</literal> if the type of an injection point cannot be proxied."
msgstr "不幸にも、Java言語の制限により、いくつかのJavaタイプはWeb Beanマネージャがプロキシ化することができません。それゆえ、注入箇所のタイプがプロキシ化できないものである場合、Web Beanマネージャは<literal>UnproxyableDependencyException</literal>をスローします。"

#. Tag: para
#: injection.xml:370
#, no-c-format
msgid "The following Java types cannot be proxied by the Web Bean manager:"
msgstr "次に挙げるJava型はWeb Beanマネージャがプロキシ化することができません。"

#. Tag: para
#: injection.xml:374
#, no-c-format
msgid "classes which are declared <literal>final</literal> or have a <literal>final</literal> method,"
msgstr "<literal>final</literal>宣言されたクラスや、<literal>final</literal>メソッドを持つクラス"

#. Tag: para
#: injection.xml:378
#, no-c-format
msgid "classes which have no non-private constructor with no parameters, and"
msgstr "プライベートでなく、引数を持たないコンストラクタを持たないクラス"

#. Tag: para
#: injection.xml:381
#, no-c-format
msgid "arrays and primitive types."
msgstr "配列とプリミティブ型"

#. Tag: para
#: injection.xml:385
#, no-c-format
msgid "It's usually very easy to fix an <literal>UnproxyableDependencyException</literal>. Simply add a constructor with no parameters to the injected class, introduce an interface, or change the scope of the injected Web Bean to <literal>@Dependent</literal>."
msgstr "通常、<literal>UnproxyableDependencyException</literal>を修正することはとても簡単です。単に、引数のないコンストラクタを注入されるクラスに追加したり、インタフェースを導入したり、注入されるWeb Beanのスコープを<literal>@Dependent</literal>に変更するだけです。"

#. Tag: title
#: injection.xml:392
#, no-c-format
msgid "Obtaining a Web Bean by programatic lookup"
msgstr "ルックアップ処理によるWeb Beanの取得"

#. Tag: para
#: injection.xml:394
#, no-c-format
msgid "The application may obtain an instance of the interface <literal>Manager</literal> by injection:"
msgstr "アプリケーションは注入によって、<literal>Manager</literal>インタフェースを持つインスタンスを取得することができます。"

#. Tag: programlisting
#: injection.xml:397
#, no-c-format
msgid "<![CDATA[@Current Manager manager;]]>"
msgstr "<![CDATA[@Current Manager manager;]]>"

#. Tag: para
#: injection.xml:399
#, no-c-format
msgid "The <literal>Manager</literal> object provides a set of methods for obtaining a Web Bean instance programatically."
msgstr "<literal>Manager</literal>オブジェクトは、Web Beanインスタンスをプログラミングによって取得するための、メソッド群を提供します。"

#. Tag: programlisting
#: injection.xml:402
#, no-c-format
msgid "<![CDATA[PaymentProcessor p = manager.getInstanceByType(PaymentProcessor.class);]]>"
msgstr "<![CDATA[PaymentProcessor p = manager.getInstanceByType(PaymentProcessor.class);]]>"

#. Tag: para
#: injection.xml:404
#, no-c-format
msgid "Binding annotations may be specified by subclassing the helper class <literal>AnnotationLiteral</literal>, since it is otherwise difficult to instantiate an annotation type in Java."
msgstr "バインディングアノテーションは、ヘルパークラス<literal>AnnotationLiteral</literal>をサブクラス化することによって指定します。これは、その他の方法では、Javaのアノテーションタイプをインスタンス化することは難しいからです。"

#. Tag: programlisting
#: injection.xml:408
#, no-c-format
msgid ""
"<![CDATA[PaymentProcessor p = manager.getInstanceByType(PaymentProcessor.class, \n"
"                                               new AnnotationLiteral<CreditCard>(){});]]>"
msgstr ""
"<![CDATA[PaymentProcessor p = manager.getInstanceByType(PaymentProcessor.class, \n"
"                                               new AnnotationLiteral<CreditCard>(){});]]>"

#. Tag: para
#: injection.xml:410
#, no-c-format
msgid "If the binding type has an annotation member, we can't use an anonymous subclass of <literal>AnnotationLiteral</literal> &#151; instead we'll need to create a named subclass:"
msgstr "バインディングタイプがメンバーを持っている場合には、<literal>AnnotationLiteral</literal>の無名サブクラスを使うことはできません。代わりに、名前つきのサブクラスを作成する必要がでてきます。"

#. Tag: programlisting
#: injection.xml:413
#, no-c-format
msgid ""
"<![CDATA[abstract class CreditCardBinding \n"
"    extends AnnotationLiteral<CreditCard> \n"
"    implements CreditCard {}]]>"
msgstr ""
"<![CDATA[abstract class CreditCardBinding \n"
"    extends AnnotationLiteral<CreditCard> \n"
"    implements CreditCard {}]]>"

#. Tag: programlisting
#: injection.xml:415
#, no-c-format
msgid ""
"<![CDATA[PaymentProcessor p = manager.getInstanceByType(PaymentProcessor.class, \n"
"                                               new CreditCardBinding() { \n"
"                                                   public void value() { return paymentType; } \n"
"                                               } );]]>"
msgstr ""
"<![CDATA[PaymentProcessor p = manager.getInstanceByType(PaymentProcessor.class, \n"
"                                               new CreditCardBinding() { \n"
"                                                   public void value() { return paymentType; } \n"
"                                               } );]]>"

#. Tag: title
#: injection.xml:419
#, no-c-format
msgid "Lifecycle callbacks, <literal>@Resource</literal>, <literal>@EJB</literal> and <literal>@PersistenceContext</literal>"
msgstr "ライフサイクルコールバック、<literal>@Resource</literal>、<literal>@EJB</literal>、<literal>@PersistenceContext</literal>"

#. Tag: para
#: injection.xml:422
#, no-c-format
msgid "Enterprise Web Beans support all the lifecycle callbacks defined by the EJB specification: <literal>@PostConstruct</literal>, <literal>@PreDestroy</literal>, <literal>@PrePassivate</literal> and <literal>@PostActivate</literal>."
msgstr "エンタープライズWeb BeanはEJB仕様で定められたすべてのライフサイクルコールバックをサポートします。<literal>@PostConstruct</literal>、<literal>@PreDestroy</literal>、<literal>@PrePassivate</literal>、<literal>@PostActivate</literal>などです。"

#. Tag: para
#: injection.xml:426
#, no-c-format
msgid "Simple Web Beans support only the <literal>@PostConstruct</literal> and <literal>@PreDestroy</literal> callbacks."
msgstr "シンプルWeb Beanは<literal>@PostConstruct</literal>と<literal>@PreDestroy</literal>のみをコールバックとしてサポートします。"

#. Tag: para
#: injection.xml:429
#, no-c-format
msgid "Both enterprise and simple Web Beans support the use of <literal>@Resource</literal>, <literal>@EJB</literal> and <literal>@PersistenceContext</literal> for injection of Java EE resources, EJBs and JPA persistence contexts, respectively. Simple Web Beans do not support the use of <literal>@PersistenceContext(type=EXTENDED)</literal>."
msgstr "エンタープライズWeb Beanも、シンプルWeb Beasも、<literal>@Resource</literal>や<literal>@EJB</literal>や<literal>@PersistenceContext</literal>を使用して、それぞれJava EEのリソース、EJB、JPAの永続化コンテキストの注入を行うことをサポートします。シンプルWeb Beanは<literal>@PersistenceContext(type=EXTENDED)</literal>の使用をサポートしません。"

#. Tag: para
#: injection.xml:434
#, no-c-format
msgid "The <literal>@PostConstruct</literal> callback always occurs after all dependencies have been injected."
msgstr "<literal>@PostConstruct</literal>コールバックは、なんらかの依存性注入が行われた後、毎回実行されます。"

#. Tag: title
#: injection.xml:440
#, no-c-format
msgid "The <literal>InjectionPoint</literal> object"
msgstr "<literal>InjectionPoint</literal>オブジェクト"

#. Tag: para
#: injection.xml:442
#, no-c-format
msgid "There are certain kinds of dependent objects &#151; Web Beans with scope <literal>@Dependent</literal> &#151; that need to know something about the object or injection point into which they are injected in order to be able to do what they do. For example:"
msgstr "ある種の依存性を持ったオブジェクト、<literal>@Dependent</literal>スコープを持ったWeb Beanは、それらが機能するために注入されたオブジェクトや注入箇所についての情報が必要になります。例えば、"

#. Tag: para
#: injection.xml:448
#, no-c-format
msgid "The log category for a <literal>Logger</literal> depends upon the class of the object that owns it."
msgstr "<literal>Logger</literal>のログカテゴリはロガーを保有するオブジェクトのクラスが何であるかに依存します。"

#. Tag: para
#: injection.xml:452
#, no-c-format
msgid "Injection of a HTTP parameter or header value depends upon what parameter or header name was specified at the injection point."
msgstr "HTTPパラメタ値やヘッダ値の注入は、注入箇所において、どのパラメタ名やヘッダ名が指定されているかに依存します。"

#. Tag: para
#: injection.xml:456
#, no-c-format
msgid "Injection of the result of an EL expression evaluation depends upon the expression that was specified at the injection point."
msgstr "EL式の評価結果の注入は、注入箇所においてどのような式が指定されているかに依存します。"

#. Tag: para
#: injection.xml:461
#, no-c-format
msgid "A Web Bean with scope <literal>@Dependent</literal> may inject an instance of <literal>InjectionPoint</literal> and access metadata relating to the injection point to which it belongs."
msgstr "<literal>@Dependent</literal>スコープを持ったWeb Beanは、<literal>InjectionPoint</literal>のインスタンスに注入を行い、Web Beanが属する注入箇所に関するメタデータにアクセスする可能性があります。"

#. Tag: para
#: injection.xml:465
#, no-c-format
msgid "Let's look at an example. The following code is verbose, and vulnerable to refactoring problems:"
msgstr "例を見てみましょう。次のコードは、煩雑なうえに、リファクタリングしにくいコードです。"

#. Tag: programlisting
#: injection.xml:468
#, no-c-format
msgid "<![CDATA[Logger log = Logger.getLogger(MyClass.class.getName());]]>"
msgstr "<![CDATA[Logger log = Logger.getLogger(MyClass.class.getName());]]>"

#. Tag: para
#: injection.xml:470
#, no-c-format
msgid "This clever little producer method lets you inject a JDK <literal>Logger</literal> without explicitly specifying the log category:"
msgstr "次の賢く小さなプロデューサメソッドは、明示的にログカテゴリを指定することなくJDKの<literal>Logger</literal>を注入します。"

#. Tag: programlisting
#: injection.xml:473
#, no-c-format
msgid ""
"<![CDATA[class LogFactory {\n"
"\n"
"   @Produces Logger createLogger(InjectionPoint injectionPoint) { \n"
"      return Logger.getLogger(injectionPoint.getMember().getDeclaringClass().getName()); \n"
"   }\n"
"\n"
"}]]>"
msgstr ""
"<![CDATA[class LogFactory {\n"
"\n"
"   @Produces Logger createLogger(InjectionPoint injectionPoint) { \n"
"      return Logger.getLogger(injectionPoint.getMember().getDeclaringClass().getName()); \n"
"   }\n"
"\n"
"}]]>"

#. Tag: para
#: injection.xml:475
#, no-c-format
msgid "We can now write:"
msgstr "これによって、次のような記述が可能になります。"

#. Tag: programlisting
#: injection.xml:477
#, no-c-format
msgid "<![CDATA[@Current Logger log;]]>"
msgstr "<![CDATA[@Current Logger log;]]>"

#. Tag: para
#: injection.xml:479
#, no-c-format
msgid "Not convinced? Then here's a second example. To inject HTTP parameters, we need to define a binding type:"
msgstr "納得できませんか？もう一つの例を見てみましょう。HTTPパラメタを注入するためには、バインディングタイプを定義する必要があります。"

#. Tag: programlisting
#: injection.xml:482
#, no-c-format
msgid ""
"<![CDATA[@BindingType\n"
"@Retention(RUNTIME)\n"
"@Target({TYPE, METHOD, FIELD, PARAMETER})\n"
"public @interface HttpParam {\n"
"   @NonBinding public String value();\n"
"}]]>"
msgstr ""
"<![CDATA[@BindingType\n"
"@Retention(RUNTIME)\n"
"@Target({TYPE, METHOD, FIELD, PARAMETER})\n"
"public @interface HttpParam {\n"
"   @NonBinding public String value();\n"
"}]]>"

#. Tag: para
#: injection.xml:484
#, no-c-format
msgid "We would use this binding type at injection points as follows:"
msgstr "このバインディングタイプを注入箇所において、次のように使うことができます。"

#. Tag: programlisting
#: injection.xml:486
#, no-c-format
msgid ""
"<![CDATA[@HttpParam(\"username\") String username;\n"
"@HttpParam(\"password\") String password;]]>"
msgstr ""
"<![CDATA[@HttpParam(\"username\") String username;\n"
"@HttpParam(\"password\") String password;]]>"

#. Tag: para
#: injection.xml:488
#, no-c-format
msgid "The following producer method does the work:"
msgstr "次のプロデューサメソッドが動作します。"

#. Tag: programlisting
#: injection.xml:490
#, no-c-format
msgid ""
"<![CDATA[class HttpParams\n"
"\n"
"   @Produces @HttpParam(\"\")\n"
"   String getParamValue(ServletRequest request, InjectionPoint ip) {\n"
"      return request.getParameter(ip.getAnnotation(HttpParam.class).value());\n"
"   }\n"
"\n"
"}]]>"
msgstr ""
"<![CDATA[class HttpParams\n"
"\n"
"   @Produces @HttpParam(\"\")\n"
"   String getParamValue(ServletRequest request, InjectionPoint ip) {\n"
"      return request.getParameter(ip.getAnnotation(HttpParam.class).value());\n"
"   }\n"
"\n"
"}]]>"

#. Tag: para
#: injection.xml:492
#, no-c-format
msgid "(Note that the <literal>value()</literal> member of the <literal>HttpParam</literal> annotation is ignored by the Web Bean manager since it is annotated <literal>@NonBinding.</literal>)"
msgstr "（<literal>HttpParam</literal>アノテーションの<literal>value()</literal>メンバーは、<literal>@NonBinding</literal>アノテーションが付いているので、Web Beanマネージャには無視されることに注意して下さい。）"

#. Tag: para
#: injection.xml:495
#, no-c-format
msgid "The Web Bean manager provides a built-in Web Bean that implements the <literal>InjectionPoint</literal> interface:"
msgstr "Web Beanマネージャは<literal>InjectionPoint</literal>インタフェースを実装した組み込みWeb Beanを提供します。"

#. Tag: programlisting
#: injection.xml:498
#, no-c-format
msgid ""
"<![CDATA[public interface InjectionPoint { \n"
"   public Object getInstance(); \n"
"   public Bean<?> getBean(); \n"
"   public Member getMember(): \n"
"   public <T extends Annotation> T getAnnotation(Class<T> annotation); \n"
"   public Set<T extends Annotation> getAnnotations(); \n"
"}]]>"
msgstr ""
"<![CDATA[public interface InjectionPoint { \n"
"   public Object getInstance(); \n"
"   public Bean<?> getBean(); \n"
"   public Member getMember(): \n"
"   public <T extends Annotation> T getAnnotation(Class<T> annotation); \n"
"   public Set<T extends Annotation> getAnnotations(); \n"
"}]]>"

