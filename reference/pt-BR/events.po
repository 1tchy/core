# Language pt-BR translations for Introduction_to_Web_Beans package.
# Automatically generated, 2009.
#
msgid ""
msgstr ""
"Project-Id-Version: Introduction_to_Web_Beans VERSION\n"
"Report-Msgid-Bugs-To: http://bugs.kde.org\n"
"POT-Creation-Date: 2009-01-06 11:30+0000\n"
"PO-Revision-Date: 2009-04-05 11:37-0300\n"
"Last-Translator: João Paulo Viragine <joao.viragine@redhat.com>\n"
"Language-Team: none\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#. Tag: title
#: events.xml:4
#, no-c-format
msgid "Events"
msgstr "Eventos"

#. Tag: para
#: events.xml:6
#, no-c-format
msgid "The Web Beans event notification facility allows Web Beans to interact in a totally decoupled manner. Event <emphasis>producers</emphasis> raise events that are then delivered to event <emphasis>observers</emphasis> by the Web Bean manager. This basic schema might sound like the familiar observer/observable pattern, but there are a couple of twists:"
msgstr ""

#. Tag: para
#: events.xml:14
#, no-c-format
msgid "not only are event producers decoupled from observers; observers are completely decoupled from producers,"
msgstr "não só os produtores são desacoplados dos observadores; os observadores são totalmente desacoplados dos produtores,"

#. Tag: para
#: events.xml:18
#, no-c-format
msgid "observers can specify a combination of \"selectors\" to narrow the set of event notifications they will receive, and"
msgstr "observadores podem especificar uma combinação de \"seletores\" para reduzir o conjunto de eventos que irão receber notificações, e"

#. Tag: para
#: events.xml:22
#, no-c-format
msgid "observers can be notified immediately, or can specify that delivery of the event should be delayed until the end of the current transaction"
msgstr "observadores podem ser notificados imediatamente ou podem especificar que a notificação do evento deveria esperar até o têrmino da transação corrente"

#. Tag: title
#: events.xml:28
#, no-c-format
msgid "Event observers"
msgstr "Observadores de eventos"

#. Tag: para
#: events.xml:30
#, no-c-format
msgid "An <emphasis>observer method</emphasis> is a method of a Web Bean with a parameter annotated <literal>@Observes</literal>."
msgstr "Um <emphasis>método observador (observer method)</emphasis> é um método de um Web Bean com um parâmetro anotado<literal>@Observes</literal>."

#. Tag: programlisting
#: events.xml:33
#, no-c-format
msgid "<![CDATA[public void onAnyDocumentEvent(@Observes Document document) { ... }]]>"
msgstr "<![CDATA[public void onAnyDocumentEvent(@Observes Document document) { ... }]]>"

#. Tag: para
#: events.xml:35
#, no-c-format
msgid "The annotated parameter is called the <emphasis>event parameter</emphasis>. The type of the event parameter is the observed <emphasis>event type</emphasis>. Observer methods may also specify \"selectors\", which are just instances of Web Beans binding types. When a binding type is used as an event selector, it is called an <emphasis>event binding type</emphasis>."
msgstr ""

#. Tag: programlisting
#: events.xml:41
#, no-c-format
msgid ""
"<![CDATA[@BindingType\n"
"@Target({PARAMETER, FIELD})\n"
"@Retention(RUNTIME)\n"
"public @interface Updated { ... }]]>"
msgstr ""
"<![CDATA[@BindingType\n"
"@Target({PARAMETER, FIELD})\n"
"@Retention(RUNTIME)\n"
"public @interface Updated { ... }]]>"

#. Tag: para
#: events.xml:43
#, no-c-format
msgid "We specify the event bindings of the observer method by annotating the event parameter:"
msgstr "Especificamos os bindings de eventos do observador anotando o parâmetro do evento:"

#. Tag: programlisting
#: events.xml:46
#: events.xml:190
#, no-c-format
msgid "<![CDATA[public void afterDocumentUpdate(@Observes @Updated Document document) { ... }]]>"
msgstr "<![CDATA[public void afterDocumentUpdate(@Observes @Updated Document document) { ... }]]>"

#. Tag: para
#: events.xml:48
#, no-c-format
msgid "An observer method need not specify any event bindings &#151; in this case it is interested in <emphasis>all</emphasis> events of a particular type. If it does specify event bindings, it is only interested in events which also have those event bindings."
msgstr "Um método observador não necessita especificar qualquer bindings de evento &#151; neste caso, ele está interessado em <emphasis>todos</emphasis> os eventos de um determinado tipo. Se ele especificar o bindings de evento, ele estará apenas interessado em eventos que também têm esses bindings de evento."

#. Tag: para
#: events.xml:53
#, no-c-format
msgid "The observer method may have additional parameters, which are injected according to the usual Web Beans method parameter injection semantics:"
msgstr "O método observador pode ter parâmetros adicionais que são injetados de acordo com a semântica usual de injeção de parâmetros em métodos de Web Beans"

#. Tag: programlisting
#: events.xml:56
#, no-c-format
msgid "<![CDATA[public void afterDocumentUpdate(@Observes @Updated Document document, User user) { ... }]]>"
msgstr "<![CDATA[public void afterDocumentUpdate(@Observes @Updated Document document, User user) { ... }]]>"

#. Tag: title
#: events.xml:61
#, no-c-format
msgid "Event producers"
msgstr "Produtores de Eventos"

#. Tag: para
#: events.xml:63
#, no-c-format
msgid "The event producer may obtain an <emphasis>event notifier</emphasis> object by injection:"
msgstr "O evento produtor pode obter um objeto <emphasis>notificador de evento (event notifier)</emphasis> por injeção:"

#. Tag: programlisting
#: events.xml:66
#, no-c-format
msgid "<![CDATA[@Observable Event<Document> documentEvent]]>"
msgstr "<![CDATA[@Observable Event<Document> documentEvent]]>"

#. Tag: para
#: events.xml:68
#, no-c-format
msgid "The <literal>@Observable</literal> annotation implicitly defines a Web Bean with scope <literal>@Dependent</literal> and deployment type <literal>@Standard</literal>, with an implementation provided by the Web Bean manager."
msgstr ""

#. Tag: para
#: events.xml:72
#, no-c-format
msgid "A producer raises events by calling the <literal>fire()</literal> method of the <literal>Event</literal> interface, passing an <emphasis>event object</emphasis>:"
msgstr "Um produtor lança eventos chamando o método <literal>fire()</literal> da interface <literal>Event</literal>, passando um objeto <emphasis>event object</emphasis>:"

#. Tag: programlisting
#: events.xml:75
#, no-c-format
msgid "<![CDATA[documentEvent.fire(document);]]>"
msgstr "<![CDATA[documentEvent.fire(document);]]>"

#. Tag: para
#: events.xml:77
#, no-c-format
msgid "An event object may be an instance of any Java class that has no type variables or wildcard type parameters. The event will be delivered to every observer method that:"
msgstr "Um objeto de evento pode ser uma instância de qualquer classe Java que não tem qualquer tipo de variáveis ou parâmetros tipo curinga. O evento será entregue a cada método observador  que:"

#. Tag: para
#: events.xml:83
#: events.xml:107
#: events.xml:126
#, no-c-format
msgid "has an event parameter to which the event object is assignable, and"
msgstr "tenha um parâmetro evento em que objeto evento objeto é atribuído, e"

#. Tag: para
#: events.xml:86
#, no-c-format
msgid "specifies no event bindings."
msgstr "especifica nenhum evento bindings."

#. Tag: para
#: events.xml:90
#, no-c-format
msgid "The Web Bean manager simply calls all the observer methods, passing the event object as the value of the event parameter. If any observer method throws an exception, the Web Bean manager stops calling observer methods, and the exception is rethrown by the <literal>fire()</literal> method."
msgstr ""

#. Tag: para
#: events.xml:95
#, no-c-format
msgid "To specify a \"selector\", the event producer may pass an instance of the event binding type to the <literal>fire()</literal> method:"
msgstr "Para especificar um \"seletor\", o produtor do evento pode passar uma instância do tipo de binding do evento para o método <literal>fire()</literal>:"

#. Tag: programlisting
#: events.xml:98
#, no-c-format
msgid "<![CDATA[documentEvent.fire( document, new AnnotationLiteral<Updated>(){} );]]>"
msgstr "<![CDATA[documentEvent.fire( document, new AnnotationLiteral<Updated>(){} );]]>"

#. Tag: para
#: events.xml:100
#, no-c-format
msgid "The helper class <literal>AnnotationLiteral</literal> makes it possible to instantiate binding types inline, since this is otherwise difficult to do in Java."
msgstr "O classe auxiliar <literal>AnnotationLiteral</literal> permite instanciar tipo de binding inline, uma vez que, esta é de outra maneira, difícil de fazer em Java."

#. Tag: para
#: events.xml:103
#, no-c-format
msgid "The event will be delivered to every observer method that:"
msgstr "O evento será entregue a todo método observador (observer method) que:"

#. Tag: para
#: events.xml:110
#, no-c-format
msgid "does not specify any event binding <emphasis>except</emphasis> for the event bindings passed to <literal>fire()</literal>."
msgstr "não especifica qualquer binding de evento <emphasis>exceto</emphasis> para o binding de evento passado para o <literal>fire()</literal>."

#. Tag: para
#: events.xml:115
#, no-c-format
msgid "Alternatively, event bindings may be specified by annotating the event notifier injection point:"
msgstr "Alternativamente, bindings de eventos podem ser especificados anotando o ponto de injeção do notificador do evento:"

#. Tag: programlisting
#: events.xml:118
#, no-c-format
msgid "<![CDATA[@Observable @Updated Event<Document> documentUpdatedEvent]]>"
msgstr "<![CDATA[@Observable @Updated Event<Document> documentUpdatedEvent]]>"

#. Tag: para
#: events.xml:120
#, no-c-format
msgid "Then every event fired via this instance of <literal>Event</literal> has the annotated event binding. The event will be delivered to every observer method that:"
msgstr "Em seguida, todos os eventos disparados por essa instância de <literal>Event</literal> tem o binding de evento anotada. O evento será entregue a cada método observador que:"

#. Tag: para
#: events.xml:129
#, no-c-format
msgid "does not specify any event binding <emphasis>except</emphasis> for the event bindings passed to <literal>fire()</literal> or the annotated event bindings of the event notifier injection point."
msgstr "não especifica qualquer binding de evento <emphasis>exceto</emphasis> para os bindings de evento passados para o <literal>fire()</literal> ou os bindings de evento anotados do ponto de injeção do notificador de evento."

#. Tag: title
#: events.xml:138
#, no-c-format
msgid "Registering observers dynamically"
msgstr "Resgistrando observadores (observers) dinamicamente"

#. Tag: para
#: events.xml:140
#, no-c-format
msgid "It's often useful to register an event observer dynamically. The application may implement the <literal>Observer</literal> interface and register an instance with an event notifier by calling the <literal>observe()</literal> method."
msgstr ""

#. Tag: programlisting
#: events.xml:144
#, no-c-format
msgid "<![CDATA[documentEvent.observe( new Observer<Document>() { public void notify(Document doc) { ... } } );]]>"
msgstr "<![CDATA[documentEvent.observe( new Observer<Document>() { public void notify(Document doc) { ... } } );]]>"

#. Tag: para
#: events.xml:146
#, no-c-format
msgid "Event binding types may be specified by the event notifier injection point or by passing event binding type instances to the <literal>observe()</literal> method:"
msgstr "Tipo de binding de eventos podem ser especificados pelo notificador do evento no ponto de injeção ou passando instâncias do tipo de binding de evento para o método observador <literal>observe()</literal> method:"

#. Tag: programlisting
#: events.xml:149
#, no-c-format
msgid ""
"<![CDATA[documentEvent.observe( new Observer<Document>() { public void notify(Document doc) { ... } }, \n"
"                                                new AnnotationLiteral<Updated>(){} );]]>"
msgstr ""
"<![CDATA[documentEvent.observe( new Observer<Document>() { public void notify(Document doc) { ... } }, \n"
"                                                new AnnotationLiteral<Updated>(){} );]]>"

#. Tag: title
#: events.xml:154
#, no-c-format
msgid "Event bindings with members"
msgstr "Bindings de eventos com os membros"

#. Tag: para
#: events.xml:156
#, no-c-format
msgid "An event binding type may have annotation members:"
msgstr "Um tipo de binding de evento pode ter anotações membro:"

#. Tag: programlisting
#: events.xml:158
#, no-c-format
msgid ""
"<![CDATA[@BindingType\n"
"@Target({PARAMETER, FIELD})\n"
"@Retention(RUNTIME)\n"
"public @interface Role {\n"
"    RoleType value();\n"
"}]]>"
msgstr ""
"<![CDATA[@BindingType\n"
"@Target({PARAMETER, FIELD})\n"
"@Retention(RUNTIME)\n"
"public @interface Role {\n"
"    RoleType value();\n"
"}]]>"

#. Tag: para
#: events.xml:160
#, no-c-format
msgid "The member value is used to narrow the messages delivered to the observer:"
msgstr "O valor do membro é utilizado para reduzir as mensagens entregues ao observador:"

#. Tag: programlisting
#: events.xml:162
#, no-c-format
msgid "<![CDATA[public void adminLoggedIn(@Observes @Role(ADMIN) LoggedIn event) { ... }]]>"
msgstr "<![CDATA[public void adminLoggedIn(@Observes @Role(ADMIN) LoggedIn event) { ... }]]>"

#. Tag: para
#: events.xml:164
#, no-c-format
msgid "Event binding type members may be specified statically by the event producer, via annotations at the event notifier injection point:"
msgstr "Membros de tipo de binding de evento podem ser especificados estaticamente pelo produtor do evento, através de anotações no ponto de notificação do evento:"

#. Tag: programlisting
#: events.xml:167
#, no-c-format
msgid "<![CDATA[@Observable @Role(ADMIN) Event<LoggedIn> LoggedInEvent;}}]]>"
msgstr "<![CDATA[@Observable @Role(ADMIN) Event<LoggedIn> LoggedInEvent;}}]]>"

#. Tag: para
#: events.xml:169
#, no-c-format
msgid "Alternatively, the value of the event binding type member may be determined dynamically by the event producer. We start by writing an abstract subclass of <literal>AnnotationLiteral</literal>:"
msgstr "Alternativamente, o valor do membro do tipo de binding de evento pode ser determinado dinamicamente pelo produtor do evento. Vamos começar escrevendo uma sub classe abstrata de <literal>AnnotationLiteral</literal>:"

#. Tag: programlisting
#: events.xml:172
#, no-c-format
msgid ""
"<![CDATA[abstract class RoleBinding \n"
"    extends AnnotationLiteral<Role> \n"
"    implements Role {}]]>"
msgstr ""
"<![CDATA[abstract class RoleBinding \n"
"    extends AnnotationLiteral<Role> \n"
"    implements Role {}]]>"

#. Tag: para
#: events.xml:174
#, no-c-format
msgid "The event producer passes an instance of this class to <literal>fire()</literal>:"
msgstr "O produtor do evento (event producer) passa uma instância dessa classe para <literal>fire()</literal>:"

#. Tag: programlisting
#: events.xml:176
#, no-c-format
msgid "<![CDATA[documentEvent.fire( document, new RoleBinding() { public void value() { return user.getRole(); } } );]]>"
msgstr "<![CDATA[documentEvent.fire( document, new RoleBinding() { public void value() { return user.getRole(); } } );]]>"

#. Tag: title
#: events.xml:181
#, no-c-format
msgid "Multiple event bindings"
msgstr "Múltiplos evento bindings"

#. Tag: para
#: events.xml:183
#, no-c-format
msgid "Event binding types may be combined, for example:"
msgstr "Tipos de event binding  podem ser combinados, por exemplo:"

#. Tag: programlisting
#: events.xml:185
#, no-c-format
msgid ""
"<![CDATA[@Observable @Blog Event<Document> blogEvent;\n"
"...\n"
"if (document.isBlog()) blogEvent.fire(document, new AnnotationLiteral<Updated>(){});]]>"
msgstr ""
"<![CDATA[@Observable @Blog Event<Document> blogEvent;\n"
"...\n"
"if (document.isBlog()) blogEvent.fire(document, new AnnotationLiteral<Updated>(){});]]>"

#. Tag: para
#: events.xml:187
#, no-c-format
msgid "When this event occurs, all of the following observer methods will be notified:"
msgstr "Quando esse evento ocorre, todos os métodos observadores que seguem esse evento serão notificados:"

#. Tag: programlisting
#: events.xml:189
#, no-c-format
msgid "<![CDATA[public void afterBlogUpdate(@Observes @Updated @Blog Document document) { ... }]]>"
msgstr "<![CDATA[public void afterBlogUpdate(@Observes @Updated @Blog Document document) { ... }]]>"

#. Tag: programlisting
#: events.xml:191
#, no-c-format
msgid "<![CDATA[public void onAnyBlogEvent(@Observes @Blog Document document) { ... }]]>"
msgstr "<![CDATA[public void onAnyBlogEvent(@Observes @Blog Document document) { ... }]]>"

#. Tag: programlisting
#: events.xml:192
#, no-c-format
msgid "<![CDATA[public void onAnyDocumentEvent(@Observes Document document) { ... }}}]]>"
msgstr "<![CDATA[public void onAnyDocumentEvent(@Observes Document document) { ... }}}]]>"

#. Tag: title
#: events.xml:197
#, no-c-format
msgid "Transactional observers"
msgstr "Observadores transacionais"

#. Tag: para
#: events.xml:199
#, no-c-format
msgid "Transactional observers receive their event notifications during the before or after completion phase of the transaction in which the event was raised. For example, the following observer method needs to refresh a query result set that is cached in the application context, but only when transactions that update the <literal>Category</literal> tree succeed:"
msgstr ""

#. Tag: programlisting
#: events.xml:205
#, no-c-format
msgid "<![CDATA[public void refreshCategoryTree(@AfterTransactionSuccess @Observes CategoryUpdateEvent event) { ... }]]>"
msgstr "<![CDATA[public void refreshCategoryTree(@AfterTransactionSuccess @Observes CategoryUpdateEvent event) { ... }]]>"

#. Tag: para
#: events.xml:207
#, no-c-format
msgid "There are three kinds of transactional observers:"
msgstr "Existem três tipos de observadores transacionais:"

#. Tag: para
#: events.xml:211
#, no-c-format
msgid "<literal>@AfterTransactionSuccess</literal> observers are called during the after completion phase of the transaction, but only if the transaction completes successfully"
msgstr "<literal>@AfterTransactionSuccess</literal> observadores são chamados durante a fase após a conclusão da transação, mas somente se a transação concluída com sucesso"

#. Tag: para
#: events.xml:216
#, no-c-format
msgid "<literal>@AfterTransactionFailure</literal> observers are called during the after completion phase of the transaction, but only if the transaction fails to complete successfully"
msgstr "<literal>@AfterTransactionFailure</literal> observadores são chamados durante a fase após a conclusão da transação, mas somente se a transação não seja concluída com êxito"

#. Tag: para
#: events.xml:221
#, no-c-format
msgid "<literal>@AfterTransactionCompletion</literal> observers are called during the after completion phase of the transaction"
msgstr "<literal>@AfterTransactionCompletion</literal> observadores são chamados durante a fase, após a conclusão da transacção"

#. Tag: para
#: events.xml:225
#, no-c-format
msgid "<literal>@BeforeTransactionCompletion</literal> observers are called during the before completion phase of the transaction"
msgstr "<literal>@BeforeTransactionCompletion</literal> observadores são chamados durante a fase antes da conclusão da transacção"

#. Tag: para
#: events.xml:230
#, no-c-format
msgid "Transactional observers are very important in a stateful object model like Web Beans, because state is often held for longer than a single atomic transaction."
msgstr "Observadores transacionais  são muito importantes para um modelo de objetos stateful como o Web Beans, porque o estado é muitas vezes mantido por mais de uma única transação atômica."

#. Tag: para
#: events.xml:233
#, no-c-format
msgid "Imagine that we have cached a JPA query result set in the application scope:"
msgstr "Imagine que fizemos cache do conjunto de resultados da consulta JPA no escopo de aplicação (application scope):"

#. Tag: programlisting
#: events.xml:235
#, no-c-format
msgid ""
"<![CDATA[@ApplicationScoped @Singleton\n"
"public class Catalog {\n"
"\n"
"    @PersistenceContext EntityManager em;\n"
"    \n"
"    List<Product> products;\n"
"\n"
"    @Produces @Catalog \n"
"    List<Product> getCatalog() {\n"
"        if (products==null) {\n"
"            products = em.createQuery(\"select p from Product p where p.deleted = false\")\n"
"                .getResultList();\n"
"        }\n"
"        return products;\n"
"    }\n"
"    \n"
"}]]>"
msgstr ""
"<![CDATA[@ApplicationScoped @Singleton\n"
"public class Catalog {\n"
"\n"
"    @PersistenceContext EntityManager em;\n"
"    \n"
"    List<Product> products;\n"
"\n"
"    @Produces @Catalog \n"
"    List<Product> getCatalog() {\n"
"        if (products==null) {\n"
"            products = em.createQuery(\"select p from Product p where p.deleted = false\")\n"
"                .getResultList();\n"
"        }\n"
"        return products;\n"
"    }\n"
"    \n"
"}]]>"

#. Tag: para
#: events.xml:237
#, no-c-format
msgid "From time to time, a <literal>Product</literal> is created or deleted. When this occurs, we need to refresh the <literal>Product</literal> catalog. But we should wait until <emphasis>after</emphasis> the transaction completes successfully before performing this refresh!"
msgstr ""

#. Tag: para
#: events.xml:242
#, no-c-format
msgid "The Web Bean that creates and deletes <literal>Product</literal>s could raise events, for example:"
msgstr "O Web Bean que cria e remove <literal>Products</literal> pode lançar eventos, por exemplo:"

#. Tag: programlisting
#: events.xml:245
#, no-c-format
msgid ""
"<![CDATA[@Stateless\n"
"public class ProductManager {\n"
"\n"
"    @PersistenceContext EntityManager em;\n"
"    @Observable Event<Product> productEvent;\n"
"\n"
"    public void delete(Product product) {\n"
"        em.delete(product);\n"
"        productEvent.fire(product, new AnnotationLiteral<Deleted>(){});\n"
"    }\n"
"    \n"
"    public void persist(Product product) {\n"
"        em.persist(product);\n"
"        productEvent.fire(product, new AnnotationLiteral<Created>(){});\n"
"    }\n"
"    \n"
"    ...\n"
"    \n"
"}]]>"
msgstr ""
"<![CDATA[@Stateless\n"
"public class ProductManager {\n"
"\n"
"    @PersistenceContext EntityManager em;\n"
"    @Observable Event<Product> productEvent;\n"
"\n"
"    public void delete(Product product) {\n"
"        em.delete(product);\n"
"        productEvent.fire(product, new AnnotationLiteral<Deleted>(){});\n"
"    }\n"
"    \n"
"    public void persist(Product product) {\n"
"        em.persist(product);\n"
"        productEvent.fire(product, new AnnotationLiteral<Created>(){});\n"
"    }\n"
"    \n"
"    ...\n"
"    \n"
"}]]>"

#. Tag: para
#: events.xml:247
#, no-c-format
msgid "And now <literal>Catalog</literal> can observe the events after successful completion of the transaction:"
msgstr "E agora <literal>Catalog</literal> pode observar os eventos após o término da transação com sucesso:"

#. Tag: programlisting
#: events.xml:250
#, no-c-format
msgid ""
"<![CDATA[@ApplicationScoped @Singleton\n"
"public class Catalog {\n"
"\n"
"    ...\n"
"    \n"
"    void addProduct(@AfterTransactionSuccess @Observes @Created Product product) {\n"
"        products.add(product);\n"
"    }\n"
"    \n"
"    void addProduct(@AfterTransactionSuccess @Observes @Deleted Product product) {\n"
"        products.remove(product);\n"
"    }\n"
"    \n"
"}]]>"
msgstr ""
"<![CDATA[@ApplicationScoped @Singleton\n"
"public class Catalog {\n"
"\n"
"    ...\n"
"    \n"
"    void addProduct(@AfterTransactionSuccess @Observes @Created Product product) {\n"
"        products.add(product);\n"
"    }\n"
"    \n"
"    void addProduct(@AfterTransactionSuccess @Observes @Deleted Product product) {\n"
"        products.remove(product);\n"
"    }\n"
"    \n"
"}]]>"

