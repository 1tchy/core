# Language pt-BR translations for Introduction_to_Web_Beans package.
# Automatically generated, 2009.
#
msgid ""
msgstr ""
"Project-Id-Version: Introduction_to_Web_Beans VERSION\n"
"Report-Msgid-Bugs-To: http://bugs.kde.org\n"
"POT-Creation-Date: 2009-11-11 15:00+0000\n"
"PO-Revision-Date: 2009-04-06 08:34-0300\n"
"Last-Translator: João Paulo Viragine <joao.viragine@redhat.com>\n"
"Language-Team: none\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#. Tag: title
#: injection.xml:4
#, fuzzy, no-c-format
msgid "Dependency injection and programmatic lookup"
msgstr "Injeção de Dependências"

#. Tag: para
#: injection.xml:6
#, no-c-format
msgid ""
"One of the most significant features of CDI&#8212;certainly the most "
"recognized&#8212;is dependency injection; excuse me, <emphasis>typesafe</"
"emphasis> dependency injection."
msgstr ""

#. Tag: title
#: injection.xml:12
#, no-c-format
msgid "Injection points"
msgstr ""

#. Tag: para
#: injection.xml:14
#, no-c-format
msgid ""
"The <literal>@Inject</literal> annotation lets us define an injection point "
"that is injected during bean instantiation. Injection can occur via three "
"different mechanisms."
msgstr ""

#. Tag: para
#: injection.xml:19
#, fuzzy, no-c-format
msgid "<emphasis>Bean constructor</emphasis> parameter injection:"
msgstr "<emphasis>Initializer</emphasis>  injeção por parâmetro de método:"

#. Tag: programlisting
#: injection.xml:23
#, fuzzy, no-c-format
msgid ""
"<![CDATA[public class Checkout {\n"
"        \n"
"   private final ShoppingCart cart;\n"
"    \n"
"   @Inject\n"
"   public Checkout(ShoppingCart cart) {\n"
"      this.cart = cart;\n"
"   }\n"
"\n"
"}]]>"
msgstr ""
"<![CDATA[public class Checkout {\n"
"        \n"
"    private final ShoppingCart cart;\n"
"    \n"
"    @Initializer\n"
"    public Checkout(ShoppingCart cart) {\n"
"        this.cart = cart;\n"
"    }\n"
"\n"
"}]]>"

#. Tag: para
#: injection.xml:26
#, no-c-format
msgid "A bean can only have one injectable constructor."
msgstr ""

#. Tag: para
#: injection.xml:31
#, fuzzy, no-c-format
msgid "<emphasis>Initializer method</emphasis> parameter injection:"
msgstr "<emphasis>Initializer</emphasis>  injeção por parâmetro de método:"

#. Tag: programlisting
#: injection.xml:35
#, fuzzy, no-c-format
msgid ""
"<![CDATA[public class Checkout {\n"
"        \n"
"   private ShoppingCart cart;\n"
"\n"
"   @Inject\n"
"   void setShoppingCart(ShoppingCart cart) {\n"
"      this.cart = cart;\n"
"   }\n"
"    \n"
"}]]>"
msgstr ""
"<![CDATA[public class Checkout {\n"
"        \n"
"    private ShoppingCart cart;\n"
"\n"
"    @Initializer \n"
"    void setShoppingCart(ShoppingCart cart) {\n"
"        this.cart = cart;\n"
"    }\n"
"    \n"
"}]]>"

#. Tag: para
#: injection.xml:38
#, no-c-format
msgid ""
"A bean can have multiple initializer methods. If the bean is a session bean, "
"the initializer method is not required to be a business method of the "
"session bean."
msgstr ""

#. Tag: para
#: injection.xml:44
#, no-c-format
msgid "And direct field injection:"
msgstr "E injeção direta de campos:"

#. Tag: programlisting
#: injection.xml:48
#, fuzzy, no-c-format
msgid ""
"<![CDATA[public class Checkout {\n"
"\n"
"   private @Inject ShoppingCart cart;\n"
"    \n"
"}]]>"
msgstr ""
"<![CDATA[public class Checkout {\n"
"\n"
"    private @Current ShoppingCart cart;\n"
"    \n"
"}]]>"

#. Tag: para
#: injection.xml:51
#, no-c-format
msgid ""
"Getter and setter methods are not required for field injection to work "
"(unlike with JSF managed beans)."
msgstr ""

#. Tag: para
#: injection.xml:56
#, fuzzy, no-c-format
msgid ""
"Dependency injection always occurs when the bean instance is first "
"instantiated by the container. Simplifying just a little, things happen in "
"this order:"
msgstr ""
"A injeção de dependências sempre ocorre quando a instância do Web Bean é "
"instanciada."

#. Tag: para
#: injection.xml:63
#, fuzzy, no-c-format
msgid ""
"First, the container calls the bean constructor (the default constructor or "
"the one annotated <literal>@Inject</literal>), to obtain an instance of the "
"bean."
msgstr ""
"Em primeiro lugar, a gerenciador do Web Bean chama o construtor do Web Bean "
"para obter uma instância do Web Bean."

#. Tag: para
#: injection.xml:69
#, fuzzy, no-c-format
msgid ""
"Next, the container initializes the values of all injected fields of the "
"bean."
msgstr ""
"Em seguida, o gerenciador do Web Bean inicializa os valores de todos os "
"campos injetados do Web Bean."

#. Tag: para
#: injection.xml:74
#, fuzzy, no-c-format
msgid ""
"Next, the container calls all initializer methods of bean (the call order is "
"not portable, don't rely on it)."
msgstr ""
"Em seguida, o gerenciador do Web Bean chama todos os métodos do Web Bean."

#. Tag: para
#: injection.xml:80
#, fuzzy, no-c-format
msgid ""
"Finally, the <literal>@PostConstruct</literal> method, if any, is called."
msgstr ""
"Finalmente, o método <literal>@PostConstruct</literal> do Web Bean, se for o "
"caso, é chamado."

#. Tag: para
#: injection.xml:86
#, no-c-format
msgid ""
"(The only complication is that the container might call initializer methods "
"declared by a superclass before initializing injected fields declared by a "
"subclass.)"
msgstr ""

#. Tag: para
#: injection.xml:90
#, no-c-format
msgid ""
"One major advantage of constructor injection is that it allows the bean to "
"be immutable."
msgstr ""

#. Tag: para
#: injection.xml:95
#, no-c-format
msgid ""
"CDI also supports parameter injection for some other methods that are "
"invoked by the container. For instance, parameter injection is supported for "
"producer methods:"
msgstr ""

#. Tag: programlisting
#: injection.xml:100
#, no-c-format
msgid ""
"<![CDATA[@Produces Checkout createCheckout(ShoppingCart cart) {\n"
"    return new Checkout(cart);\n"
"}]]>"
msgstr ""
"<![CDATA[@Produces Checkout createCheckout(ShoppingCart cart) {\n"
"    return new Checkout(cart);\n"
"}]]>"

#. Tag: para
#: injection.xml:102
#, no-c-format
msgid ""
"This is a case where the <literal>@Inject</literal> annotation <emphasis>is "
"not</emphasis> required at the injection point. The same is true for "
"observer methods (which we'll meet in <xref linkend=\"events\"/>) and "
"disposer methods."
msgstr ""

#. Tag: title
#: injection.xml:110
#, no-c-format
msgid "What gets injected"
msgstr ""

#. Tag: para
#: injection.xml:112
#, no-c-format
msgid ""
"The CDI specification defines a procedure, called <emphasis>typesafe "
"resolution</emphasis>, that the container follows when identifying the bean "
"to inject to an injection point. This algorithm looks complex at first, but "
"once you understand it, it's really quite intuitive. Typesafe resolution is "
"performed at system initialization time, which means that the container will "
"inform the developer immediately if a bean's dependencies cannot be "
"satisfied."
msgstr ""

#. Tag: para
#: injection.xml:120
#, fuzzy, no-c-format
msgid ""
"The purpose of this algorithm is to allow multiple beans to implement the "
"same bean type and either:"
msgstr ""
"O objetivo deste algoritmo é permitir que vários Web Beans implementem o "
"mesmo tipo de API e também:"

#. Tag: para
#: injection.xml:126
#, fuzzy, no-c-format
msgid ""
"allow the client to select which implementation it requires using a "
"<emphasis>qualifier</emphasis> or"
msgstr ""
"permitir que o cliente escolha a implementação que lhe melhor convier "
"utilizando <emphasis>anotações de binding (binding annotations)</emphasis>,"

#. Tag: para
#: injection.xml:131
#, fuzzy, no-c-format
msgid ""
"allow the application deployer to select which implementation is appropriate "
"for a particular deployment, without changes to the client, by enabling or "
"disabling an <emphasis>alternative</emphasis>, or"
msgstr ""
"permitir ao implantador (deployer) da aplicação escolher qual a implentação "
"é adequada para uma determinada implantação, sem alterações para o cliente, "
"por ativar ou desativar <emphasis>tipos de implantação (deployment types)</"
"emphasis>, ou"

#. Tag: para
#: injection.xml:137
#, no-c-format
msgid "allow the beans to be isolated into separate modules."
msgstr ""

#. Tag: para
#: injection.xml:143
#, no-c-format
msgid ""
"Obviously, if you have exactly one bean of a given type, and an injection "
"point with that same type, then bean A is going to go into slot A. That's "
"the simplest possible scenario. When you first start your application, "
"you'll likely have lots of those."
msgstr ""

#. Tag: para
#: injection.xml:149
#, no-c-format
msgid ""
"But then, things start to get complicated. Let's explore how the container "
"determines which bean to inject in more advanced cases. We'll start by "
"taking a closer look at qualifiers."
msgstr ""

#. Tag: title
#: injection.xml:157
#, fuzzy, no-c-format
msgid "Qualifier annotations"
msgstr "Anotações de ligação (binding annotations)"

#. Tag: para
#: injection.xml:159
#, no-c-format
msgid ""
"If we have more than one bean that implements a particular bean type, the "
"injection point can specify exactly which bean should be injected using a "
"qualifier annotation. For example, there might be two implementations of "
"<literal>PaymentProcessor</literal>:"
msgstr ""

#. Tag: programlisting
#: injection.xml:165
#, fuzzy, no-c-format
msgid ""
"<![CDATA[@Synchronous\n"
"public class SynchronousPaymentProcessor implements PaymentProcessor {\n"
"   public void process(Payment payment) { ... }\n"
"}]]>"
msgstr ""
"<![CDATA[@PayByCheque\n"
"public class ChequePaymentProcessor implements PaymentProcessor {\n"
"    public void process(Payment payment) { ... }\n"
"}]]>"

#. Tag: programlisting
#: injection.xml:167
#, fuzzy, no-c-format
msgid ""
"<![CDATA[@Asynchronous\n"
"public class AsynchronousPaymentProcessor implements PaymentProcessor {\n"
"   public void process(Payment payment) { ... }\n"
"}]]>"
msgstr ""
"<![CDATA[@PayByCheque\n"
"public class ChequePaymentProcessor implements PaymentProcessor {\n"
"    public void process(Payment payment) { ... }\n"
"}]]>"

#. Tag: para
#: injection.xml:169
#, fuzzy, no-c-format
msgid ""
"Where <literal>@Synchronous</literal> and <literal>@Asynchronous</literal> "
"are qualifier annotations:"
msgstr ""
"Onde <literal>@PayByCheque</literal> e <literal>@PayByCreditCard</literal> "
"são anotações de binding:"

#. Tag: programlisting
#: injection.xml:173
#, fuzzy, no-c-format
msgid ""
"<![CDATA[@Qualifier\n"
"@Retention(RUNTIME)\n"
"@Target({TYPE, METHOD, FIELD, PARAMETER})\n"
"public @interface Synchronous {}]]>"
msgstr ""
"<![CDATA[@Retention(RUNTIME)\n"
"@Target({TYPE, METHOD, FIELD, PARAMETER})\n"
"@BindingType\n"
"public @interface PayByCheque {}]]>"

#. Tag: programlisting
#: injection.xml:175
#, fuzzy, no-c-format
msgid ""
"<![CDATA[@Qualifier\n"
"@Retention(RUNTIME)\n"
"@Target({TYPE, METHOD, FIELD, PARAMETER})\n"
"public @interface Asynchronous {}]]>"
msgstr ""
"<![CDATA[@Retention(RUNTIME)\n"
"@Target({TYPE, METHOD, FIELD, PARAMETER})\n"
"@BindingType\n"
"public @interface PayByCheque {}]]>"

#. Tag: para
#: injection.xml:177
#, fuzzy, no-c-format
msgid ""
"A client bean developer uses the qualifier annotation to specify exactly "
"which bean should be injected."
msgstr ""
"Um desenvolvedor cliente de um Web Bean utiliza a anotação de binding para "
"especificar exatamente quais Web Bean devem ser injetados."

#. Tag: para
#: injection.xml:181
#, no-c-format
msgid "Using field injection:"
msgstr "Utilizando injeção por campos (field injection):"

#. Tag: programlisting
#: injection.xml:183
#, fuzzy, no-c-format
msgid ""
"<![CDATA[@Inject @Synchronous PaymentProcessor syncPaymentProcessor;\n"
"@Inject @Asynchronous PaymentProcessor asyncPaymentProcessor;]]>"
msgstr ""
"<![CDATA[@PayByCheque PaymentProcessor chequePaymentProcessor;\n"
"@PayByCreditCard PaymentProcessor creditCardPaymentProcessor;]]>"

#. Tag: para
#: injection.xml:185
#, no-c-format
msgid "Using initializer method injection:"
msgstr "Utilizando injeção de método de inicialização:"

#. Tag: programlisting
#: injection.xml:187
#, fuzzy, no-c-format
msgid ""
"<![CDATA[@Inject\n"
"public void setPaymentProcessors(@Synchronous PaymentProcessor "
"syncPaymentProcessor, \n"
"                                 @Asynchronous PaymentProcessor "
"asyncPaymentProcessor) {\n"
"   this.syncPaymentProcessor = syncPaymentProcessor;\n"
"   this.asyncPaymentProcessor = asyncPaymentProcessor;\n"
"}]]>"
msgstr ""
"<![CDATA[@Initializer\n"
"public void setPaymentProcessors(@PayByCheque PaymentProcessor "
"chequePaymentProcessor, \n"
"                                 @PayByCreditCard PaymentProcessor "
"creditCardPaymentProcessor) {\n"
"   this.chequePaymentProcessor = chequePaymentProcessor;\n"
"   this.creditCardPaymentProcessor = creditCardPaymentProcessor;\n"
"}]]>"

#. Tag: para
#: injection.xml:189
#, fuzzy, no-c-format
msgid "Using constructor injection:"
msgstr "Ou utilizando injeção de construtor"

#. Tag: programlisting
#: injection.xml:191
#, fuzzy, no-c-format
msgid ""
"<![CDATA[@Inject\n"
"public Checkout(@Synchronous PaymentProcessor syncPaymentProcessor, \n"
"                @Asynchronous PaymentProcessor asyncPaymentProcessor) {\n"
"   this.syncPaymentProcessor = syncPaymentProcessor;\n"
"   this.asyncPaymentProcessor = asyncPaymentProcessor;\n"
"}]]>"
msgstr ""
"<![CDATA[@Initializer\n"
"public Checkout(@PayByCheque PaymentProcessor chequePaymentProcessor, \n"
"                @PayByCreditCard PaymentProcessor "
"creditCardPaymentProcessor) {\n"
"   this.chequePaymentProcessor = chequePaymentProcessor;\n"
"   this.creditCardPaymentProcessor = creditCardPaymentProcessor;\n"
"}]]>"

#. Tag: para
#: injection.xml:193
#, no-c-format
msgid ""
"Qualifier annotations can also qualify method arguments of producer, "
"disposer and observer methods. Combining qualified arguments with producer "
"methods is a good way to have an implementation of a bean type selected at "
"runtime based on the state of the system:"
msgstr ""

#. Tag: programlisting
#: injection.xml:199
#, fuzzy, no-c-format
msgid ""
"<![CDATA[@Produces\n"
"PaymentProcessor getPaymentProcessor(@Synchronous PaymentProcessor "
"syncPaymentProcessor,\n"
"                                     @Asynchronous PaymentProcessor "
"asyncPaymentProcessor) {\n"
"   return isSynchronous() ? syncPaymentProcessor : asyncPaymentProcessor;\n"
"}]]>"
msgstr ""
"<![CDATA[@Initializer\n"
"public void setPaymentProcessors(@PayByCheque PaymentProcessor "
"chequePaymentProcessor, \n"
"                                 @PayByCreditCard PaymentProcessor "
"creditCardPaymentProcessor) {\n"
"   this.chequePaymentProcessor = chequePaymentProcessor;\n"
"   this.creditCardPaymentProcessor = creditCardPaymentProcessor;\n"
"}]]>"

#. Tag: para
#: injection.xml:201
#, no-c-format
msgid ""
"If an injected field or a parameter of a bean constructor or initializer "
"method is not explicitly annotated with a qualifier, the default qualifier, "
"<literal>@Default</literal>, is assumed."
msgstr ""

#. Tag: para
#: injection.xml:206
#, no-c-format
msgid ""
"Now, you may be thinking, <emphasis>\"What's the different between using a "
"qualifier and just specifying the exact implementation class you want?\"</"
"emphasis> It's important to understand that a qualifier is like an extension "
"of the interface. It does not create a direct dependency to any particular "
"implementation. There may be multiple alterative implementations of "
"<literal>@Asynchronous PaymentProcessor</literal>!"
msgstr ""

#. Tag: title
#: injection.xml:216
#, no-c-format
msgid "Qualifiers with members"
msgstr ""

#. Tag: para
#: injection.xml:218
#, no-c-format
msgid ""
"Java annotations can have members. We can use annotation members to further "
"discriminate a qualifier. This prevents a potential explosion of new "
"annotations. For example, instead of creating several qualifiers "
"representing different payment methods, we could aggregate them into a "
"single annotation with a member:"
msgstr ""

#. Tag: programlisting
#: injection.xml:224
#, fuzzy, no-c-format
msgid ""
"<![CDATA[@Qualifier\n"
"@Retention(RUNTIME)\n"
"@Target({METHOD, FIELD, PARAMETER, TYPE})\n"
"public @interface PayBy {\n"
"   PaymentMethod value();\n"
"}]]>"
msgstr ""
"<![CDATA[@Retention(RUNTIME)\n"
"@Target({TYPE, METHOD, FIELD, PARAMETER})\n"
"@BindingType\n"
"public @interface PayBy {\n"
"    PaymentType value();\n"
"}]]>"

#. Tag: para
#: injection.xml:226
#, no-c-format
msgid ""
"Then we select one of the possible member values when appling the qualifier:"
msgstr ""

#. Tag: programlisting
#: injection.xml:230
#, fuzzy, no-c-format
msgid ""
"<![CDATA[private @Inject @PayBy(CHECK) PaymentProcessor checkPayment;]]>"
msgstr ""
"<![CDATA[@Asynchronous @PayByCheque PaymentProcessor paymentProcessor]]>"

#. Tag: para
#: injection.xml:232
#, no-c-format
msgid ""
"We can force the container to ignore a member of a qualifier type by "
"annotating the member <literal>@NonBinding</literal>."
msgstr ""

#. Tag: programlisting
#: injection.xml:237
#, fuzzy, no-c-format
msgid ""
"<![CDATA[@Qualifier\n"
"@Retention(RUNTIME)\n"
"@Target({METHOD, FIELD, PARAMETER, TYPE})\n"
"public @interface PayBy {\n"
"   PaymentMethod value();\n"
"   @NonBinding String comment() default \"\";\n"
"}]]>"
msgstr ""
"<![CDATA[@BindingType\n"
"@Retention(RUNTIME)\n"
"@Target({TYPE, METHOD, FIELD, PARAMETER})\n"
"public @interface HttpParam {\n"
"   @NonBinding public String value();\n"
"}]]>"

#. Tag: title
#: injection.xml:242
#, no-c-format
msgid "Multiple qualifiers"
msgstr ""

#. Tag: para
#: injection.xml:244
#, fuzzy, no-c-format
msgid "An injection point may specify multiple qualifiers:"
msgstr ""
"Um ponto de injeção pode até mesmo especificar múltiplas anotações de "
"binding:"

#. Tag: programlisting
#: injection.xml:248
#, fuzzy, no-c-format
msgid ""
"<![CDATA[@Inject @Synchronous @Reliable PaymentProcessor "
"syncPaymentProcessor;]]>"
msgstr ""
"<![CDATA[@Asynchronous @PayByCheque PaymentProcessor paymentProcessor]]>"

#. Tag: para
#: injection.xml:250
#, fuzzy, no-c-format
msgid ""
"Then only a bean which has <emphasis>both</emphasis> qualifier annotations "
"would be eligible for injection."
msgstr ""
"Neste caso, só o Web Bean que tem <emphasis>ambas</emphasis> anotações de "
"binding são elegíveis para injeção."

#. Tag: programlisting
#: injection.xml:255
#, fuzzy, no-c-format
msgid ""
"<![CDATA[@Synchronous @Reliable\n"
"public class SynchronousReliablePaymentProcessor implements PaymentProcessor "
"{\n"
"   public void process(Payment payment) { ... }\n"
"}]]>"
msgstr ""
"<![CDATA[@PayByCheque\n"
"public class ChequePaymentProcessor implements PaymentProcessor {\n"
"    public void process(Payment payment) { ... }\n"
"}]]>"

#. Tag: title
#: injection.xml:260
#, no-c-format
msgid "Alternatives"
msgstr ""

#. Tag: para
#: injection.xml:262
#, no-c-format
msgid ""
"Alternatives are beans whose implementation is specific to a particular "
"client module or deployment scenario. This alternative defines a mock "
"implementation of both <literal>@Synchronous PaymentProcessor</literal> and "
"<literal>@Asynchronous PaymentProcessor</literal>, all in one:"
msgstr ""

#. Tag: programlisting
#: injection.xml:266
#, fuzzy, no-c-format
msgid ""
"<![CDATA[@Alternative @Synchronous @Asynchronous\n"
"public class MockPaymentProcessor implements PaymentProcessor {\n"
"   public void process(Payment payment) { ... }\n"
"}]]>"
msgstr ""
"<![CDATA[@PayByCheque\n"
"public class ChequePaymentProcessor implements PaymentProcessor {\n"
"    public void process(Payment payment) { ... }\n"
"}]]>"

#. Tag: para
#: injection.xml:268
#, no-c-format
msgid ""
"By default, <literal>@Alternative</literal> beans are disabled. We need to "
"<emphasis>enable</emphasis> an alternative in the <literal>beans.xml</"
"literal> descriptor of a bean archive to make it available for instantiation "
"and injection. This activation only applies to the beans in that archive."
msgstr ""

#. Tag: programlisting
#: injection.xml:274
#, no-c-format
msgid ""
"<![CDATA[<beans\n"
"   xmlns=\"http://java.sun.com/xml/ns/javaee\"\n"
"   xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n"
"   xsi:schemaLocation=\"\n"
"      http://java.sun.com/xml/ns/javaee\n"
"      http://java.sun.com/xml/ns/javaee/beans_1_0.xsd\">\n"
"   <alternatives>\n"
"         <class>org.mycompany.mock.MockPaymentProcessor</class>\n"
"   </alternatives>\n"
"</beans>]]>"
msgstr ""

#. Tag: para
#: injection.xml:276
#, no-c-format
msgid ""
"When an ambiguous dependency exists at an injection point, the container "
"attempts to resolve the ambiguity by looking for an enabled alternative "
"among the beans that could be injected. If there is exactly one enabled "
"alternative, that's the bean that will be injected."
msgstr ""

#. Tag: title
#: injection.xml:285
#, no-c-format
msgid "Fixing unsatisfied and ambiguous dependencies"
msgstr ""

#. Tag: para
#: injection.xml:287
#, no-c-format
msgid ""
"The typesafe resolution algorithm fails when, after considering the "
"qualifier annotations on all beans that implement the bean type of an "
"injection point and filtering out disabled beans (<literal>@Alternative</"
"literal> beans which are not explicitly enabled), the container is unable to "
"identify exactly one bean to inject. The container will abort deployment, "
"informing us of the unsatisfied or ambiguous dependency."
msgstr ""

#. Tag: para
#: injection.xml:294
#, no-c-format
msgid ""
"During the course of your development, you're going to encounter this "
"situation. Let's learn how to resolve it."
msgstr ""

#. Tag: para
#: injection.xml:298
#, no-c-format
msgid "To fix an <emphasis>unsatisfied dependency</emphasis>, either:"
msgstr ""

#. Tag: para
#: injection.xml:304
#, no-c-format
msgid ""
"create a bean which implements the bean type and has all the qualifier types "
"of the injection point,"
msgstr ""

#. Tag: para
#: injection.xml:309
#, no-c-format
msgid ""
"make sure that the bean you already have is in the classpath of the module "
"with the injection point, or"
msgstr ""

#. Tag: para
#: injection.xml:314
#, no-c-format
msgid ""
"explicitly enable an <literal>@Alternative</literal> bean that implements "
"the bean type and has the appropriate qualifier types, using <literal>beans."
"xml</literal>."
msgstr ""

#. Tag: para
#: injection.xml:321
#, no-c-format
msgid "To fix an <emphasis>ambiguous dependency</emphasis>, either:"
msgstr ""

#. Tag: para
#: injection.xml:327
#, no-c-format
msgid ""
"introduce a qualifier to distinguish between the two implementations of the "
"bean type,"
msgstr ""

#. Tag: para
#: injection.xml:332
#, no-c-format
msgid ""
"disable one of the beans by annotating it <literal>@Alternative</literal>,"
msgstr ""

#. Tag: para
#: injection.xml:337
#, no-c-format
msgid ""
"move one of the implementations to a module that is not in the classpath of "
"the module with the injection point, or"
msgstr ""

#. Tag: para
#: injection.xml:343
#, no-c-format
msgid ""
"disable one of two <literal>@Alternative</literal> beans that are trying to "
"occupy the same space, using <literal>beans.xml</literal>."
msgstr ""

#. Tag: para
#: injection.xml:350
#, no-c-format
msgid ""
"See <ulink src=\"http://sfwk.org/Documentation/"
"HowDoAResolveAnAmbiguousResolutionExceptionBetweenAProducerMethodAndARawType"
"\">this FAQ</ulink> for step-by-step instructions for how to resolve an "
"ambigous resolution exception between a raw bean type and a producer method "
"that returns the same bean type."
msgstr ""

#. Tag: para
#: injection.xml:358
#, no-c-format
msgid "Just remember: \"There can be only one.\""
msgstr ""

#. Tag: para
#: injection.xml:361
#, no-c-format
msgid ""
"On the other hand, if you really do have an optional or multivalued "
"injection point, you should change the type of your injection point to "
"<literal>Instance</literal>, as we'll see in <xref linkend=\"lookup\"/>."
msgstr ""

#. Tag: para
#: injection.xml:366
#, no-c-format
msgid ""
"Now there's one more issue you need to be aware of when using the dependency "
"injection service."
msgstr ""

#. Tag: title
#: injection.xml:373
#, no-c-format
msgid "Client proxies"
msgstr "Proxies clientes"

#. Tag: para
#: injection.xml:375
#, fuzzy, no-c-format
msgid ""
"Clients of an injected bean do not usually hold a direct reference to a bean "
"instance, unless the bean is a dependent object (scope <literal>@Dependent</"
"literal>)."
msgstr ""
"Clientes de um Web Bean injetado, geralmente não possuem uma referência "
"direta a uma instância do Web Bean ."

#. Tag: para
#: injection.xml:380
#, no-c-format
msgid ""
"Imagine that a bean bound to the application scope held a direct reference "
"to a bean bound to the request scope. The application-scoped bean is shared "
"between many different requests. However, each request should see a "
"different instance of the request scoped bean&#8212;the current one!"
msgstr ""

#. Tag: para
#: injection.xml:386
#, no-c-format
msgid ""
"Now imagine that a bean bound to the session scope holds a direct reference "
"to a bean bound to the application scope. From time to time, the session "
"context is serialized to disk in order to use memory more efficiently. "
"However, the application scoped bean instance should not be serialized along "
"with the session scoped bean! It can get that reference any time. No need to "
"hoard it!"
msgstr ""

#. Tag: para
#: injection.xml:393
#, no-c-format
msgid ""
"Therefore, unless a bean has the default scope <literal>@Dependent</"
"literal>, the container must indirect all injected references to the bean "
"through a proxy object. This <emphasis>client proxy</emphasis> is "
"responsible for ensuring that the bean instance that receives a method "
"invocation is the instance that is associated with the current context. The "
"client proxy also allows beans bound to contexts such as the session context "
"to be serialized to disk without recursively serializing other injected "
"beans."
msgstr ""

#. Tag: para
#: injection.xml:401
#, no-c-format
msgid ""
"Unfortunately, due to limitations of the Java language, some Java types "
"cannot be proxied by the container. If an injection point declared with one "
"of these types resolves to a bean with any scope other than "
"<literal>@Dependent</literal>, the container will abort deployment, "
"informing us of the problem."
msgstr ""

#. Tag: para
#: injection.xml:407
#, fuzzy, no-c-format
msgid "The following Java types cannot be proxied by the container:"
msgstr ""
"Os seguintes tipos Java não podem ser \"proxied\" pelo gerenciador do Web "
"Bean:"

#. Tag: para
#: injection.xml:411
#, fuzzy, no-c-format
msgid ""
"classes which don't have a non-private constructor with no parameters, and"
msgstr "classes que não têm um construtor não privado sem parâmetros, e"

#. Tag: para
#: injection.xml:414
#, no-c-format
msgid ""
"classes which are declared <literal>final</literal> or have a "
"<literal>final</literal> method,"
msgstr ""
"classes que são declaradas <literal>final</literal> ou que tenham um método "
"<literal>final</literal>,"

#. Tag: para
#: injection.xml:419
#, no-c-format
msgid "arrays and primitive types."
msgstr "arrays e tipos primitivos."

#. Tag: para
#: injection.xml:423
#, no-c-format
msgid ""
"It's usually very easy to fix an unproxyable dependency problem. Simply add "
"a constructor with no parameters to the injected class, introduce an "
"interface, or, if all else fails, change the scope of the injected bean to "
"<literal>@Dependent</literal>."
msgstr ""

#. Tag: para
#: injection.xml:430
#, no-c-format
msgid ""
"A future release of Weld will likely support a non-standard workaround for "
"this limitation, using non-portable JVM APIs:"
msgstr ""

#. Tag: para
#: injection.xml:437
#, no-c-format
msgid ""
"Sun, IcedTea, Mac: <literal>Unsafe.allocateInstance()</literal> (The most "
"efficient)"
msgstr ""

#. Tag: para
#: injection.xml:442
#, no-c-format
msgid ""
"IBM, JRockit: <literal>ReflectionFactory.newConstructorForSerialization()</"
"literal>"
msgstr ""

#. Tag: para
#: injection.xml:448
#, no-c-format
msgid "But we didn't get around to implementing this yet."
msgstr ""

#. Tag: title
#: injection.xml:457
#, fuzzy, no-c-format
msgid "Obtaining a contextual instance by programmatic lookup"
msgstr "Obtendo um Web Bean via lookup programaticamente"

#. Tag: para
#: injection.xml:459
#, no-c-format
msgid ""
"In certain situations, injection is not the most convenient way to obtain a "
"contextual reference. For example, it may not be used when:"
msgstr ""

#. Tag: para
#: injection.xml:466
#, no-c-format
msgid "the bean type or qualifiers vary dynamically at runtime, or"
msgstr ""

#. Tag: para
#: injection.xml:471
#, no-c-format
msgid ""
"depending upon the deployment, there may be no bean which satisfies the type "
"and qualifiers, or"
msgstr ""

#. Tag: para
#: injection.xml:476
#, no-c-format
msgid "we would like to iterate over all beans of a certain type."
msgstr ""

#. Tag: para
#: injection.xml:482
#, fuzzy, no-c-format
msgid ""
"In these situations, the application may obtain an instance of the interface "
"<literal>Instance</literal>, parameterized for the bean type, by injection:"
msgstr ""
"A aplicação pode obter uma instância da interface <literal>Manager</literal> "
"por injeção:"

#. Tag: programlisting
#: injection.xml:487
#, fuzzy, no-c-format
msgid "<![CDATA[@Inject Instance<PaymentProcessor> paymentProcessorSource;]]>"
msgstr "<![CDATA[@Current PaymentProcessor paymentProcessor]]>"

#. Tag: para
#: injection.xml:489
#, no-c-format
msgid ""
"The <literal>get()</literal> method of <literal>Instance</literal> produces "
"a contextual instance of the bean."
msgstr ""

#. Tag: programlisting
#: injection.xml:493
#, fuzzy, no-c-format
msgid "<![CDATA[PaymentProcessor p = paymentProcessorSource.get();]]>"
msgstr "<![CDATA[@Current PaymentProcessor paymentProcessor]]>"

#. Tag: para
#: injection.xml:495
#, no-c-format
msgid "Qualifiers can be specified in one of two ways:"
msgstr ""

#. Tag: para
#: injection.xml:501
#, no-c-format
msgid "by annotating the <literal>Instance</literal> injection point, or"
msgstr ""

#. Tag: para
#: injection.xml:504
#, fuzzy, no-c-format
msgid ""
"by passing qualifiers to the <literal>select()</literal> of <literal>Event</"
"literal>."
msgstr ""
"Web Beans simples suportam apenas chamadas a <literal>@PostConstruct</"
"literal> e <literal>@PreDestroy</literal>."

#. Tag: para
#: injection.xml:508
#, no-c-format
msgid "Specifying the qualifiers at the injection point is much, much easier:"
msgstr ""

#. Tag: programlisting
#: injection.xml:512
#, fuzzy, no-c-format
msgid ""
"<![CDATA[@Inject @Asynchronous Instance<PaymentProcessor> "
"paymentProcessorSource;]]>"
msgstr ""
"<![CDATA[@Asynchronous @PayByCheque PaymentProcessor paymentProcessor]]>"

#. Tag: para
#: injection.xml:514
#, no-c-format
msgid ""
"Now, the <literal>PaymentProcessor</literal> returned by <literal>get()</"
"literal> will have the qualifier <literal>@Asynchronous</literal>."
msgstr ""

#. Tag: para
#: injection.xml:519
#, no-c-format
msgid ""
"Alternatively, we can specify the qualifier dynamically. First, we add the "
"<literal>@Any</literal> qualifier to the injection point, to suppress the "
"default qualifier. (All beans have the qualifier <literal>@Any</literal>.)"
msgstr ""

#. Tag: programlisting
#: injection.xml:524
#, fuzzy, no-c-format
msgid ""
"<![CDATA[@Inject @Any Instance<PaymentProcessor> paymentProcessorSource;]]>"
msgstr "<![CDATA[@Current PaymentProcessor paymentProcessor]]>"

#. Tag: para
#: injection.xml:526
#, no-c-format
msgid ""
"Next, we need to obtain an instance of our qualifier type. Since annotatons "
"are interfaces, we can't just write <literal>new Asynchronous()</literal>. "
"It's also quite tedious to create a concrete implementation of an annotation "
"type from scratch. Instead, CDI lets us obtain a qualifier instance by "
"subclassing the helper class <literal>AnnotationLiteral</literal>."
msgstr ""

#. Tag: programlisting
#: injection.xml:533
#, fuzzy, no-c-format
msgid ""
"<![CDATA[abstract class AsynchronousQualifier\n"
"extends AnnotationLiteral<Asynchronous> implements Asynchronous {}]]>"
msgstr ""
"<![CDATA[abstract class CreditCardBinding \n"
"    extends AnnotationLiteral<CreditCard> \n"
"    implements CreditCard {}]]>"

#. Tag: para
#: injection.xml:535
#, no-c-format
msgid "In some cases, we can use an anonymous class:"
msgstr ""

#. Tag: programlisting
#: injection.xml:539
#, fuzzy, no-c-format
msgid ""
"<![CDATA[PaymentProcessor p = paymentProcessorSource\n"
"   .select(new AnnotationLiteral<Asynchronous>() {});]]>"
msgstr ""
"<![CDATA[PaymentProcessor p = manager.getInstanceByType(PaymentProcessor."
"class, \n"
"                                               new "
"AnnotationLiteral<CreditCard>(){});]]>"

#. Tag: para
#: injection.xml:542
#, no-c-format
msgid ""
"We can't use an anonymous class to implement a qualifier type with members."
msgstr ""

#. Tag: para
#: injection.xml:547
#, no-c-format
msgid ""
"Now, finally, we can pass the qualifier to the <literal>select()</literal> "
"method of <literal>Instance</literal>."
msgstr ""

#. Tag: programlisting
#: injection.xml:551
#, no-c-format
msgid ""
"<![CDATA[Annotation qualifier = synchronously ?\n"
"      new SynchronousQualifier() : new AsynchronousQualifier();\n"
"PaymentProcessor p = anyPaymentProcessor.select(qualifier).get().process"
"(payment);]]>"
msgstr ""

#. Tag: title
#: injection.xml:556
#, no-c-format
msgid "The <literal>InjectionPoint</literal> object"
msgstr "O objeto <literal>InjectionPoint</literal>"

#. Tag: para
#: injection.xml:558
#, no-c-format
msgid ""
"There are certain kinds of dependent objects (beans with scope "
"<literal>@Dependent</literal>) that need to know something about the object "
"or injection point into which they are injected in order to be able to do "
"what they do. For example:"
msgstr ""

#. Tag: para
#: injection.xml:564
#, no-c-format
msgid ""
"The log category for a <literal>Logger</literal> depends upon the class of "
"the object that owns it."
msgstr ""

#. Tag: para
#: injection.xml:568
#, no-c-format
msgid ""
"Injection of a HTTP parameter or header value depends upon what parameter or "
"header name was specified at the injection point."
msgstr ""

#. Tag: para
#: injection.xml:572
#, no-c-format
msgid ""
"Injection of the result of an EL expression evaluation depends upon the "
"expression that was specified at the injection point."
msgstr ""
"Injeção do resultado da avaliação de uma expressão EL depende da expressão "
"que foi especificada no ponto de injeção."

#. Tag: para
#: injection.xml:577
#, no-c-format
msgid ""
"A bean with scope <literal>@Dependent</literal> may inject an instance of "
"<literal>InjectionPoint</literal> and access metadata relating to the "
"injection point to which it belongs."
msgstr ""

#. Tag: para
#: injection.xml:581
#, no-c-format
msgid ""
"Let's look at an example. The following code is verbose, and vulnerable to "
"refactoring problems:"
msgstr ""

#. Tag: programlisting
#: injection.xml:584
#, no-c-format
msgid "<![CDATA[Logger log = Logger.getLogger(MyClass.class.getName());]]>"
msgstr "<![CDATA[Logger log = Logger.getLogger(MyClass.class.getName());]]>"

#. Tag: para
#: injection.xml:586
#, no-c-format
msgid ""
"This clever little producer method lets you inject a JDK <literal>Logger</"
"literal> without explicitly specifying the log category:"
msgstr ""

#. Tag: programlisting
#: injection.xml:589
#, no-c-format
msgid ""
"<![CDATA[class LogFactory {\n"
"\n"
"   @Produces Logger createLogger(InjectionPoint injectionPoint) { \n"
"      return Logger.getLogger(injectionPoint.getMember().getDeclaringClass()."
"getName()); \n"
"   }\n"
"\n"
"}]]>"
msgstr ""
"<![CDATA[class LogFactory {\n"
"\n"
"   @Produces Logger createLogger(InjectionPoint injectionPoint) { \n"
"      return Logger.getLogger(injectionPoint.getMember().getDeclaringClass()."
"getName()); \n"
"   }\n"
"\n"
"}]]>"

#. Tag: para
#: injection.xml:591
#, no-c-format
msgid "We can now write:"
msgstr "Podemos agora escrever:"

#. Tag: programlisting
#: injection.xml:593
#, fuzzy, no-c-format
msgid "<![CDATA[@Inject Logger log;]]>"
msgstr "<![CDATA[@Current Logger log;]]>"

#. Tag: para
#: injection.xml:595
#, no-c-format
msgid ""
"Not convinced? Then here's a second example. To inject HTTP parameters, we "
"need to define a qualifier type:"
msgstr ""

#. Tag: programlisting
#: injection.xml:598
#, no-c-format
msgid ""
"<![CDATA[@BindingType\n"
"@Retention(RUNTIME)\n"
"@Target({TYPE, METHOD, FIELD, PARAMETER})\n"
"public @interface HttpParam {\n"
"   @NonBinding public String value();\n"
"}]]>"
msgstr ""
"<![CDATA[@BindingType\n"
"@Retention(RUNTIME)\n"
"@Target({TYPE, METHOD, FIELD, PARAMETER})\n"
"public @interface HttpParam {\n"
"   @NonBinding public String value();\n"
"}]]>"

#. Tag: para
#: injection.xml:600
#, no-c-format
msgid "We would use this qualifier type at injection points as follows:"
msgstr ""

#. Tag: programlisting
#: injection.xml:602
#, no-c-format
msgid ""
"<![CDATA[@HttpParam(\"username\") String username;\n"
"@HttpParam(\"password\") String password;]]>"
msgstr ""
"<![CDATA[@HttpParam(\"username\") String username;\n"
"@HttpParam(\"password\") String password;]]>"

#. Tag: para
#: injection.xml:604
#, no-c-format
msgid "The following producer method does the work:"
msgstr "O seguinte método produtor faz o trabalho:"

#. Tag: programlisting
#: injection.xml:606
#, no-c-format
msgid ""
"<![CDATA[class HttpParams\n"
"\n"
"   @Produces @HttpParam(\"\")\n"
"   String getParamValue(ServletRequest request, InjectionPoint ip) {\n"
"      return request.getParameter(ip.getAnnotation(HttpParam.class).value"
"());\n"
"   }\n"
"\n"
"}]]>"
msgstr ""
"<![CDATA[class HttpParams\n"
"\n"
"   @Produces @HttpParam(\"\")\n"
"   String getParamValue(ServletRequest request, InjectionPoint ip) {\n"
"      return request.getParameter(ip.getAnnotation(HttpParam.class).value"
"());\n"
"   }\n"
"\n"
"}]]>"

#. Tag: para
#: injection.xml:608
#, no-c-format
msgid ""
"(Note that the <literal>value()</literal> member of the <literal>HttpParam</"
"literal> annotation is ignored by the container since it is annotated "
"<literal>@NonBinding.</literal>)"
msgstr ""

#. Tag: para
#: injection.xml:611
#, no-c-format
msgid ""
"The container provides a built-in bean that implements the "
"<literal>InjectionPoint</literal> interface:"
msgstr ""

#. Tag: programlisting
#: injection.xml:614
#, no-c-format
msgid ""
"<![CDATA[public interface InjectionPoint { \n"
"   public Object getInstance(); \n"
"   public Bean<?> getBean(); \n"
"   public Member getMember(): \n"
"   public <T extends Annotation> T getAnnotation(Class<T> annotation); \n"
"   public Set<T extends Annotation> getAnnotations(); \n"
"}]]>"
msgstr ""
"<![CDATA[public interface InjectionPoint { \n"
"   public Object getInstance(); \n"
"   public Bean<?> getBean(); \n"
"   public Member getMember(): \n"
"   public <T extends Annotation> T getAnnotation(Class<T> annotation); \n"
"   public Set<T extends Annotation> getAnnotations(); \n"
"}]]>"

#~ msgid ""
#~ "Web Beans supports three primary mechanisms for dependency injection:"
#~ msgstr ""
#~ "Web Beans suporta três principais mecanismos de injeção de dependências:"

#~ msgid "Constructor parameter injection:"
#~ msgstr "Injeção de parametros no construtor:"

#~ msgid ""
#~ "Constructor parameter injection is not supported for EJB beans, since the "
#~ "EJB is instantiated by the EJB container, not the Web Bean manager."
#~ msgstr ""
#~ "Injeção de parâmetros no construtor não é suportado em EJB beans, uma vez "
#~ "que o EJB é instanciado pelo container EJB e não pelo gerenciador do Web "
#~ "Bean."

#~ msgid "Producer methods also support parameter injection:"
#~ msgstr "Métodos produtores também suportam injeção de parâmetros:"

#~ msgid ""
#~ "Finally, observer methods (which we'll meet in <xref linkend=\"events\"/"
#~ ">), disposal methods and destructor methods all support parameter "
#~ "injection."
#~ msgstr ""
#~ "Por fim, métodos de observação (que iremos detalhar em <xref linkend="
#~ "\"events\"/>), métodos de disposal e métodos destrutores, todos suportam "
#~ "injeção de parâmetros."

#~ msgid ""
#~ "allow one implementation of an API to override another implementation of "
#~ "the same API at deployment time, without changes to the client, using "
#~ "<emphasis>deployment type precedence</emphasis>."
#~ msgstr ""
#~ "permitir uma implementação de uma API sobrescrever uma outra "
#~ "implementação da mesma API em tempo de implantação, sem alterações no "
#~ "cliente, utilizando <emphasis>precedência do tipo de implantação "
#~ "(deployment type precedence)</emphasis>."

#~ msgid ""
#~ "Let's explore how the Web Beans manager determines a Web Bean to be "
#~ "injected."
#~ msgstr ""
#~ "Vamos explorer como o gerenciador do Web Beans determina qual o Web Bean "
#~ "deve ser injetado."

#~ msgid ""
#~ "<![CDATA[@PayByCreditCard\n"
#~ "public class CreditCardPaymentProcessor implements PaymentProcessor {\n"
#~ "    public void process(Payment payment) { ... }\n"
#~ "}]]>"
#~ msgstr ""
#~ "<![CDATA[@PayByCreditCard\n"
#~ "public class CreditCardPaymentProcessor implements PaymentProcessor {\n"
#~ "    public void process(Payment payment) { ... }\n"
#~ "}]]>"

#~ msgid ""
#~ "<![CDATA[@Retention(RUNTIME)\n"
#~ "@Target({TYPE, METHOD, FIELD, PARAMETER})\n"
#~ "@BindingType\n"
#~ "public @interface PayByCreditCard {}]]>"
#~ msgstr ""
#~ "<![CDATA[@Retention(RUNTIME)\n"
#~ "@Target({TYPE, METHOD, FIELD, PARAMETER})\n"
#~ "@BindingType\n"
#~ "public @interface PayByCreditCard {}]]>"

#~ msgid "In which case, the member value is significant:"
#~ msgstr "Em cada caso, o valor do membro é significante:"

#~ msgid ""
#~ "<![CDATA[@PayBy(CHEQUE) PaymentProcessor chequePaymentProcessor;\n"
#~ "@PayBy(CREDIT_CARD) PaymentProcessor creditCardPaymentProcessor;]]>"
#~ msgstr ""
#~ "<![CDATA[@PayBy(CHEQUE) PaymentProcessor chequePaymentProcessor;\n"
#~ "@PayBy(CREDIT_CARD) PaymentProcessor creditCardPaymentProcessor;]]>"

#~ msgid "Combinations of binding annnotations"
#~ msgstr "Combinações de anotações de binding"

#~ msgid "Binding annotations and producer methods"
#~ msgstr "Anotações de binding e métodos produtores "

#~ msgid "Even producer methods may specify binding annotations:"
#~ msgstr "Mesmo métodos produtores podem especificar anotações de binding:"

#~ msgid ""
#~ "<![CDATA[@Produces \n"
#~ "@Asynchronous @PayByCheque \n"
#~ "PaymentProcessor createAsyncPaymentProcessor(@PayByCheque "
#~ "PaymentProcessor processor) {\n"
#~ "    return new AsynchronousPaymentProcessor(processor);\n"
#~ "}]]>"
#~ msgstr ""
#~ "<![CDATA[@Produces \n"
#~ "@Asynchronous @PayByCheque \n"
#~ "PaymentProcessor createAsyncPaymentProcessor(@PayByCheque "
#~ "PaymentProcessor processor) {\n"
#~ "    return new AsynchronousPaymentProcessor(processor);\n"
#~ "}]]>"

#~ msgid "The default binding type"
#~ msgstr "O tipo padrão de binding"

#~ msgid ""
#~ "There are two common circumstances in which it is necessary to explicitly "
#~ "specify <literal>@Current</literal>:"
#~ msgstr ""
#~ "Há duas situações comuns nas quais é necessário indicar explicitamente "
#~ "<literal>@Current</literal>:"

#~ msgid ""
#~ "on a field, in order to declare it as an injected field with the default "
#~ "binding type, and"
#~ msgstr ""
#~ "em um campo, a fim de declará-lo como um campo injetado com o tipo de "
#~ "binding padrão, e"

#~ msgid ""
#~ "on a Web Bean which has another binding type in addition to the default "
#~ "binding type."
#~ msgstr ""
#~ "em um Web Bean, que tem um outro tipo de binding além do tipo padrão de "
#~ "binding."

#~ msgid "Deployment types"
#~ msgstr "Tipo de deploy"

#~ msgid ""
#~ "<![CDATA[@Retention(RUNTIME)\n"
#~ "  @Target({TYPE, METHOD})\n"
#~ "  @DeploymentType\n"
#~ "  public @interface Mock {}]]>"
#~ msgstr ""
#~ "<![CDATA[@Retention(RUNTIME)\n"
#~ "  @Target({TYPE, METHOD})\n"
#~ "  @DeploymentType\n"
#~ "  public @interface Mock {}]]>"

#~ msgid ""
#~ "Suppose we had some Web Bean that interacted with an external system to "
#~ "process payments:"
#~ msgstr ""
#~ "Suponha que temos alguns Web Beans que interajam com um sistema externo "
#~ "para processar pagamentos:"

#~ msgid ""
#~ "<![CDATA[public class ExternalPaymentProcessor {\n"
#~ "        \n"
#~ "    public void process(Payment p) {\n"
#~ "        ...\n"
#~ "    }\n"
#~ "    \n"
#~ "}]]>"
#~ msgstr ""
#~ "<![CDATA[public class ExternalPaymentProcessor {\n"
#~ "        \n"
#~ "    public void process(Payment p) {\n"
#~ "        ...\n"
#~ "    }\n"
#~ "    \n"
#~ "}]]>"

#~ msgid ""
#~ "Since this Web Bean does not explicitly specify a deployment type, it has "
#~ "the default deployment type <literal>@Production</literal>."
#~ msgstr ""
#~ "Uma vez que esse Web Bean não especifica explicitamente um tipo de "
#~ "implantação, ele tem o tipo de implantação padrão <literal>@Production</"
#~ "literal>."

#~ msgid ""
#~ "<![CDATA[@Mock \n"
#~ "public class MockPaymentProcessor implements PaymentProcessor {\n"
#~ "\n"
#~ "    @Override\n"
#~ "    public void process(Payment p) {\n"
#~ "        p.setSuccessful(true);\n"
#~ "    }\n"
#~ "\n"
#~ "}]]>"
#~ msgstr ""
#~ "<![CDATA[@Mock \n"
#~ "public class MockPaymentProcessor implements PaymentProcessor {\n"
#~ "\n"
#~ "    @Override\n"
#~ "    public void process(Payment p) {\n"
#~ "        p.setSuccessful(true);\n"
#~ "    }\n"
#~ "\n"
#~ "}]]>"

#~ msgid "Enabling deployment types"
#~ msgstr "Ativando tipos de implantação (deployment types)"

#~ msgid ""
#~ "<![CDATA[<WebBeans>\n"
#~ "    <Deploy>\n"
#~ "        <Standard/>\n"
#~ "        <Production/>\n"
#~ "        <test:Mock/>\n"
#~ "    </Deploy>\n"
#~ "</WebBeans>]]>"
#~ msgstr ""
#~ "<![CDATA[<WebBeans>\n"
#~ "    <Deploy>\n"
#~ "        <Standard/>\n"
#~ "        <Production/>\n"
#~ "        <test:Mock/>\n"
#~ "    </Deploy>\n"
#~ "</WebBeans>]]>"

#~ msgid "Deployment type precedence"
#~ msgstr "Precedencia dos tipos de deploy"

#~ msgid "Example deployment types"
#~ msgstr "Exemplo de tipos de deploy"

#~ msgid "<![CDATA[@Current Manager manager;]]>"
#~ msgstr "<![CDATA[@Current Manager manager;]]>"

#~ msgid ""
#~ "The <literal>Manager</literal> object provides a set of methods for "
#~ "obtaining a Web Bean instance programatically."
#~ msgstr ""
#~ "O objeto <literal>Manager</literal> fornece um conjunto de métodos para a "
#~ "obtenção de uma instância de um Web Bean programaticamente."

#~ msgid ""
#~ "<![CDATA[PaymentProcessor p = manager.getInstanceByType(PaymentProcessor."
#~ "class);]]>"
#~ msgstr ""
#~ "<![CDATA[PaymentProcessor p = manager.getInstanceByType(PaymentProcessor."
#~ "class);]]>"

#~ msgid ""
#~ "<![CDATA[PaymentProcessor p = manager.getInstanceByType(PaymentProcessor."
#~ "class, \n"
#~ "                                               new CreditCardBinding() "
#~ "{ \n"
#~ "                                                   public void value() "
#~ "{ return paymentType; } \n"
#~ "                                               } );]]>"
#~ msgstr ""
#~ "<![CDATA[PaymentProcessor p = manager.getInstanceByType(PaymentProcessor."
#~ "class, \n"
#~ "                                               new CreditCardBinding() "
#~ "{ \n"
#~ "                                                   public void value() "
#~ "{ return paymentType; } \n"
#~ "                                               } );]]>"

#~ msgid ""
#~ "Lifecycle callbacks, <literal>@Resource</literal>, <literal>@EJB</"
#~ "literal> and <literal>@PersistenceContext</literal>"
#~ msgstr ""
#~ "Chamadas ao ciclo de vida, <literal>@Resource</literal>, <literal>@EJB</"
#~ "literal> e <literal>@PersistenceContext</literal>"

#~ msgid ""
#~ "The <literal>@PostConstruct</literal> callback always occurs after all "
#~ "dependencies have been injected."
#~ msgstr ""
#~ "A chamada ao <literal>@PostConstruct</literal> sempre ocorre após todas "
#~ "as dependências serem injetadas."
