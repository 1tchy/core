# Language pt-BR translations for Weld_-_JSR-299_Reference_Implementation package.
# Automatically generated, 2009.
#
msgid ""
msgstr ""
"Project-Id-Version: Weld_-_JSR-299_Reference_Implementation VERSION\n"
"Report-Msgid-Bugs-To: http://bugs.kde.org\n"
"POT-Creation-Date: 2010-01-06 12:17+0000\n"
"PO-Revision-Date: 2010-01-07 14:27-0300\n"
"Last-Translator: Bruno Leonardo Gonçalves <brunolmfg@gmail.com>\n"
"Language-Team: none\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#. Tag: title
#: beans.xml:4
#, no-c-format
msgid "More about beans"
msgstr "Mais sobre beans"

#. Tag: para
#: beans.xml:6
#, no-c-format
msgid ""
"A bean is usually an application class that contains business logic. It may "
"be called directly from Java code, or it may be invoked via the Unified EL. "
"A bean may access transactional resources. Dependencies between beans are "
"managed automatically by the container. Most beans are <emphasis>stateful</"
"emphasis> and <emphasis>contextual</emphasis>. The lifecycle of a bean is "
"always managed by the container."
msgstr ""
"Um bean é usualmente uma classe de aplicação que contém lógica de negócio. "
"Pode ser chamado diretamente a partir do código Java, ou pode ser invocado "
"por meio da Unified EL. Um bean pode acessar recursos transacionais. As "
"dependências entre beans são gerenciadas automaticamente pelo contêiner. A "
"maioria dos beans são <emphasis>stateful</emphasis> e <emphasis>contextuais</"
"emphasis>. O ciclo de vida de um bean é sempre gerenciado pelo contêiner."

#. Tag: para
#: beans.xml:13
#, no-c-format
msgid ""
"Let's back up a second. What does it really mean to be <emphasis>contextual</"
"emphasis>? Since beans may be stateful, it matters <emphasis>which</"
"emphasis> bean instance I have. Unlike a stateless component model (for "
"example, stateless session beans) or a singleton component model (such as "
"servlets, or singleton beans), different clients of a bean see the bean in "
"different states. The client-visible state depends upon which instance of "
"the bean the client has a reference to."
msgstr ""
"Vamos voltar um segundo. O que realmente significa ser <emphasis>contextual</"
"emphasis>? Uma vez que os beans podem ser stateful, é importante saber "
"<emphasis>qual</emphasis> instância do bean eu tenho. Ao contrário de um "
"modelo de componentes stateless (por exemplo, stateless session beans) ou um "
"modelo de componentes singleton (como servlets, ou singleton beans), "
"diferentes clientes de um bean vêem o bean em diferentes estados. O estado "
"visível ao cliente depende de para qual instância do bean o cliente tem uma "
"referência."

#. Tag: para
#: beans.xml:21
#, no-c-format
msgid ""
"However, like a stateless or singleton model, but <emphasis>unlike</"
"emphasis> stateful session beans, the client does not control the lifecycle "
"of the instance by explicitly creating and destroying it. Instead, the "
"<emphasis>scope</emphasis> of the bean determines:"
msgstr ""
"No entanto, como em um modelo stateless ou singleton, mas de modo "
"<emphasis>diferente</emphasis> em stateful session beans, o cliente não "
"controla o ciclo de vida da instância pela explícita criação e destruição "
"dela. Em vez disso, o <emphasis>escopo</emphasis> do bean determina:"

#. Tag: para
#: beans.xml:29
#, no-c-format
msgid "the lifecycle of each instance of the bean and"
msgstr "o ciclo de vida de cada instância do bean e"

#. Tag: para
#: beans.xml:32
#, no-c-format
msgid "which clients share a reference to a particular instance of the bean."
msgstr ""
"quais clientes compartilham uma referência para uma instância específica do "
"bean."

#. Tag: para
#: beans.xml:36
#, no-c-format
msgid ""
"For a given thread in a CDI application, there may be an <emphasis>active "
"context</emphasis> associated with the scope of the bean. This context may "
"be unique to the thread (for example, if the bean is request scoped), or it "
"may be shared with certain other threads (for example, if the bean is "
"session scoped) or even all other threads (if it is application scoped)."
msgstr ""
"Para uma dada thread em uma aplicação CDI, pode haver um <emphasis>contexto "
"ativo</emphasis> associado com o escopo do bean. Este contexto pode ser "
"único para a thread (por exemplo, se o bean possui escopo de solicitação), "
"ou pode ser compartilhado com algumas outras threads (por exemplo, se o bean "
"possui escopo de sessão) ou mesmo com todas as outras threads (se ele possui "
"escopo de aplicação)."

#. Tag: para
#: beans.xml:43
#, no-c-format
msgid ""
"Clients (for example, other beans) executing in the same context will see "
"the same instance of the bean. But clients in a different context may see a "
"different instance (depending on the relationship between the contexts)."
msgstr ""
"Os clientes (por exemplo, outros beans) executados no mesmo contexto verão a "
"mesma instância do bean. Mas os clientes em um diferente contexto podem ver "
"uma instância diferente (dependendo do relacionamento entre os contextos)."

#. Tag: para
#: beans.xml:49
#, no-c-format
msgid ""
"One great advantage of the contextual model is that it allows stateful beans "
"to be treated like services! The client need not concern itself with "
"managing the lifecycle of the bean it's using, <emphasis>nor does it even "
"need to know what that lifecycle is.</emphasis> Beans interact by passing "
"messages, and the bean implementations define the lifecycle of their own "
"state. The beans are loosely coupled because:"
msgstr ""
"Uma grande vantagem do modelo contextual é que ele permite que stateful "
"beans sejam tratados como serviços!  O cliente não precisa se preocupar com "
"o gerenciamento do ciclo de vida do bean que ele está usando, <emphasis>nem "
"mesmo precisam saber o que é ciclo de vida.</emphasis> Os beans interagem "
"passando mensagens, e as implementações do bean definem o ciclo de vida de "
"seu próprio estado. Os beans são de baixo acoplamento porque:"

#. Tag: para
#: beans.xml:58
#, no-c-format
msgid "they interact via well-defined public APIs"
msgstr "eles interagem por meio de APIs bem definidas e públicas"

#. Tag: para
#: beans.xml:61
#, no-c-format
msgid "their lifecycles are completely decoupled"
msgstr "seus ciclos de vida são completamente desacoplados"

#. Tag: para
#: beans.xml:65
#, no-c-format
msgid ""
"We can replace one bean with another different bean that implements the same "
"interface and has a different lifecycle (a different scope) without "
"affecting the other bean implementation. In fact, CDI defines a simple "
"facility for overriding bean implementations at deployment time, as we will "
"see in <xref linkend=\"alternatives\"/>."
msgstr ""
"Podemos substituir um bean por outro bean diferente que implementa a mesma "
"interface e tem um ciclo de vida diferente (um escopo diferente) sem afetar "
"a outra implementação do bean. Na verdade, CDI define um mecanismo simples "
"para sobrepor implementações de bean em tempo de implantação, como veremos "
"na <xref linkend=\"alternatives\"/>."

#. Tag: para
#: beans.xml:71
#, no-c-format
msgid ""
"Note that not all clients of a bean are beans themselves. Other objects such "
"as servlets or message-driven beans&#8212;which are by nature not "
"injectable, contextual objects&#8212;may also obtain references to beans by "
"injection."
msgstr ""
"Note que nem todos os clientes de um bean são eles próprios também beans. "
"Outros objetos como servlets ou message-driven beans&#8212;que são por "
"natureza objetos não injetáveis e não contextuais &#8212;podem também obter "
"referências para beans por meio de injeção."

#. Tag: title
#: beans.xml:78
#, no-c-format
msgid "The anatomy of a bean"
msgstr "A anatomia de um bean"

#. Tag: para
#: beans.xml:80
#, no-c-format
msgid ""
"Enough hand-waving. More formally, the anatomy of a bean, according to the "
"spec:"
msgstr ""
"Já chega de acenar as mãos. Mais formalmente, a anatomia de um bean, de "
"acordo com a especificação:"

#. Tag: para
#: beans.xml:84
#, no-c-format
msgid "A bean comprises the following attributes:"
msgstr "Um bean abrange os seguintes atributos:"

#. Tag: para
#: beans.xml:87
#, no-c-format
msgid "A (nonempty) set of bean types"
msgstr "Um conjunto (não vazio) de tipos de bean"

#. Tag: para
#: beans.xml:88
#, no-c-format
msgid "A (nonempty) set of qualifiers"
msgstr "Um conjunto (não vazio) de qualificadores"

#. Tag: para
#: beans.xml:89
#, no-c-format
msgid "A scope"
msgstr "Um escopo"

#. Tag: para
#: beans.xml:90
#, no-c-format
msgid "Optionally, a bean EL name"
msgstr "Opcionalmente, um nome EL do bean"

#. Tag: para
#: beans.xml:91
#, no-c-format
msgid "A set of interceptor bindings"
msgstr "Um conjunto de vinculações com interceptadores"

#. Tag: para
#: beans.xml:92
#, no-c-format
msgid "A bean implementation"
msgstr "Uma implementação do bean"

#. Tag: para
#: beans.xml:95
#, no-c-format
msgid "Furthermore, a bean may or may not be an alternative."
msgstr "Além disso, um bean pode ou não pode ser um bean alternativo."

#. Tag: para
#: beans.xml:99
#, no-c-format
msgid "Let's see what all this new terminology means."
msgstr "Vamos ver o que toda esta nova terminologia significa."

#. Tag: title
#: beans.xml:102
#, no-c-format
msgid "Bean types, qualifiers and dependency injection"
msgstr "Tipos e qualificadores de bean e injeção de dependência"

#. Tag: para
#: beans.xml:104
#, no-c-format
msgid ""
"Beans usually acquire references to other beans via dependency injection. "
"Any injected attribute specifies a \"contract\" that must be satisfied by "
"the bean to be injected. The contract is:"
msgstr ""
"Beans usualmente adquirem referências para outros beans por meio de injeção "
"de dependência. Qualquer atributo injetado especifica um \"contrato\" que "
"deve ser satisfeito pelo bean para ser injetado. O contrato é:"

#. Tag: para
#: beans.xml:110
#, no-c-format
msgid "a bean type, together with"
msgstr "um tipo de bean, juntamente com"

#. Tag: para
#: beans.xml:111
#, no-c-format
msgid "a set of qualifiers."
msgstr "um conjunto de qualificadores."

#. Tag: para
#: beans.xml:114
#, no-c-format
msgid ""
"A bean type is a user-defined class or interface; a type that is client-"
"visible. If the bean is an EJB session bean, the bean type is the "
"<literal>@Local</literal> interface or bean-class local view. A bean may "
"have multiple bean types. For example, the following bean has four bean "
"types:"
msgstr ""
"Um tipo de bean é uma classe ou interface definida pelo usuário; um tipo que "
"é visível ao cliente. Se o bean é um EJB session bean, o tipo do bean é a "
"interface <literal>@Local</literal> ou a classe do bean da visão local. Um "
"bean pode possuir múltiplos tipos. Por exemplo, o seguinte bean possui "
"quatro tipos de bean:"

#. Tag: programlisting
#: beans.xml:120
#, no-c-format
msgid ""
"<![CDATA[public class BookShop \n"
"      extends Business \n"
"      implements Shop<Book> {\n"
"   ...\n"
"}]]>"
msgstr ""
"<![CDATA[public class BookShop \n"
"      extends Business \n"
"      implements Shop<Book> {\n"
"   ...\n"
"}]]>"

#. Tag: para
#: beans.xml:122
#, no-c-format
msgid ""
"The bean types are <literal>BookShop</literal>, <literal>Business</literal> "
"and <literal>Shop&lt;Book&gt;</literal>, as well as the implicit type "
"<literal>java.lang.Object</literal>. (Notice that a parameterized type is a "
"legal bean type)."
msgstr ""
"Os tipos de bean são <literal>BookShop</literal>, <literal>Business</"
"literal> e <literal>Shop&lt;Book&gt;</literal>, bem como o tipo implícito "
"<literal>java.lang.Object</literal>. (Observe que um tipo parametrizado é um "
"tipo de bean válido)."

#. Tag: para
#: beans.xml:128
#, no-c-format
msgid ""
"Meanwhile, this session bean has only the local interfaces "
"<literal>BookShop</literal>, <literal>Auditable</literal> and <literal>java."
"lang.Object</literal> as bean types, since the bean class, "
"<literal>BookShopBean</literal> is not a client-visible type."
msgstr ""
"Entretanto, este session bean possui somente as interfaces locais "
"<literal>BookShop</literal>, <literal>Auditable</literal> e <literal>java."
"lang.Object</literal> como tipos de bean, uma vez que a classe do bean, "
"<literal>BookShopBean</literal>, não é um tipo visível ao cliente."

#. Tag: programlisting
#: beans.xml:134
#, no-c-format
msgid ""
"<![CDATA[@Stateful\n"
"public class BookShopBean \n"
"      extends Business \n"
"      implements BookShop, Auditable {\n"
"   ...\n"
"}]]>"
msgstr ""
"<![CDATA[@Stateful\n"
"public class BookShopBean \n"
"      extends Business \n"
"      implements BookShop, Auditable {\n"
"   ...\n"
"}]]>"

#. Tag: para
#: beans.xml:137
#, no-c-format
msgid ""
"Most bean types you can probably figure out. One gotcha is primitive types. "
"All primitive types are assumed to be identical to their corresponding "
"wrapper types in <literal>java.lang</literal>."
msgstr ""
"A maioria dos tipos de bean você pode provavelmente descobrir. Uma pegadinha "
"são os tipos primitivos. Todos os tipos primitivos são assumidos como "
"idênticos aos seus correspondentes tipos adaptadores em <literal>java.lang</"
"literal>."

#. Tag: para
#: beans.xml:143
#, no-c-format
msgid ""
"Bean types may be restricted to an explicit set by annotating the bean with "
"the <literal>@Typed</literal> annotation and listing the classes that should "
"be bean types. For instance, the bean types of this bean have been "
"restricted to <literal>Shop&lt;Book&gt;</literal>, together with "
"<literal>java.lang.Object</literal>:"
msgstr ""
"Os tipos do bean podem ser limitados a um conjunto explícito, anotando o "
"bean com a anotação <literal>@Typed</literal> e listando as classes que "
"devem ser os tipos do bean. Por exemplo, os tipos de bean desde bean foram "
"restritos a <literal>Shop&lt;Book&gt;</literal>, juntamente com "
"<literal>java.lang.Object</literal>:"

#. Tag: programlisting
#: beans.xml:149
#, no-c-format
msgid ""
"<![CDATA[@Typed(Shop.class)\n"
"public class BookShop \n"
"      extends Business \n"
"      implements Shop<Book> {\n"
"   ...\n"
"}]]>"
msgstr ""
"<![CDATA[@Typed(Shop.class)\n"
"public class BookShop \n"
"      extends Business \n"
"      implements Shop<Book> {\n"
"   ...\n"
"}]]>"

#. Tag: para
#: beans.xml:151
#, no-c-format
msgid ""
"Sometimes, a bean type alone does not provide enough information for the "
"container to know which bean to inject. For instance, suppose we have two "
"implementations of the <literal>PaymentProcessor</literal> interface: "
"<literal>CreditCardPaymentProcessor</literal> and "
"<literal>DebitPaymentProcessor</literal>. Injecting a field of type "
"<literal>PaymentProcessor</literal> introduces an ambiguous condition. In "
"these cases, the client must specify some additional quality of the "
"implementation it is interested in. We model this kind of \"quality\" using "
"a qualifier."
msgstr ""
"Algumas vezes um tipo de bean sozinho não fornece informação suficiente para "
"o contêiner saber qual bean injetar. Por exemplo, suponha que temos duas "
"implementações da interface <literal>PaymentProcessor</literal>: "
"<literal>CreditCardPaymentProcessor</literal> e "
"<literal>DebitPaymentProcessor</literal>. Injetar em um campo do tipo "
"<literal>PaymentProcessor</literal> introduz uma condição ambígua. Nestes "
"casos, o cliente deve especificar algum qualidade adicional da implementação "
"que ele está interessado. Modelamos esta categoria de \"qualidade\" usando "
"um qualificador."

#. Tag: para
#: beans.xml:160
#, no-c-format
msgid ""
"A qualifier is a user-defined annotation that is itself annotated "
"<literal>@Qualifer</literal>. A qualifier annotation is an extension of the "
"type system. It lets us disambiguate a type without having to fall back to "
"string-based names. Here's an example of a qualifier annotation:"
msgstr ""
"Um qualificador é uma anotação definida pelo usuário que é ela própria "
"anotada com <literal>@Qualifer</literal>. Uma anotação de qualificador é uma "
"extensão do sitema de tipos. Ela nos permite desambiguar um tipo sem ter que "
"recorrer a nomes baseados em strings. Aqui está um exemplo de uma anotação "
"de qualificador:"

#. Tag: programlisting
#: beans.xml:166
#, no-c-format
msgid ""
"<![CDATA[@Qualifier\n"
"@Target({TYPE, METHOD, PARAMETER, FIELD})\n"
"@Retention(RUNTIME)\n"
"public @interface CreditCard {}]]>"
msgstr ""
"<![CDATA[@Qualifier\n"
"@Target({TYPE, METHOD, PARAMETER, FIELD})\n"
"@Retention(RUNTIME)\n"
"public @interface CreditCard {}]]>"

#. Tag: para
#: beans.xml:168
#, no-c-format
msgid ""
"You may not be used to seeing the definition of an annotation. In fact, this "
"might be the first time you've encountered one. With CDI, annotation "
"definitions will become a familiar artifact as you'll be creating them from "
"time to time."
msgstr ""
"Você pode não estar acostumado a ver a definição de uma anotação. Na "
"verdade, essa poderia ser a primeira vez que você encontrou uma. Com CDI, "
"definições de anotação se tornará um artefato familiar conforme você for "
"criando-os de vez em quando."

#. Tag: para
#: beans.xml:175
#, no-c-format
msgid ""
"Pay attention to the names of the built-in annotations in CDI and EJB. "
"You'll notice that they are often adjectives. We encourage you to follow "
"this convention when creating your custom annotations, since they serve to "
"describe the behaviors and roles of the class."
msgstr ""
"Preste atenção nos nomes das anotações embutidas em CDI e EJB. Você "
"perceberá que elas são muitas vezes adjetivos. Nós encorajamos você a seguir "
"esta convenção ao criar suas próprias anotações, uma vez que elas servem "
"para descrever os comportamentos e papéis da classe."

#. Tag: para
#: beans.xml:182
#, no-c-format
msgid ""
"Now that we have defined a qualifier annotation, we can use it to "
"disambiguate an injection point. The following injection point has the bean "
"type <literal>PaymentProcessor</literal> and qualifier <literal>@CreditCard</"
"literal>:"
msgstr ""
"Agora que temos definido uma anotação de qualificador, podemos utilizá-la "
"para resolver a ambiguidade no ponto de injeção. O seguinte ponto de injeção "
"possui o tipo de bean <literal>PaymentProcessor</literal> e o qualificador "
"<literal>@CreditCard</literal>:"

#. Tag: programlisting
#: beans.xml:188
#, no-c-format
msgid "<![CDATA[@Inject @CreditCard PaymentProcessor paymentProcessor]]>"
msgstr "<![CDATA[@Inject @CreditCard PaymentProcessor paymentProcessor]]>"

#. Tag: para
#: beans.xml:191
#, no-c-format
msgid ""
"If an injection point does not explicitly specify a qualifier, it has the "
"default qualifier, <literal>@Default</literal>."
msgstr ""
"Se um ponto de injeção não define explicitamente um qualificador, ele terá o "
"qualificador padrão, <literal>@Default</literal>."

#. Tag: para
#: beans.xml:197
#, no-c-format
msgid ""
"For each injection point, the container searches for a bean which satisfies "
"the contract, one which has the bean type and all the qualifiers. If it "
"finds exactly one matching bean, it injects an instance of that bean. If it "
"doesn't, it reports an error to the user."
msgstr ""
"Para cada ponto de injeção, o contêiner pesquisa por um bean que satisfaça o "
"contrato, um que tenha o tipo de bean e todos os qualificadores. Se ele "
"encontrar exatamente um bean, ele injeta uma instância deste bean. Se ele "
"não encontrar, ele reporta um erro ao usuário."

#. Tag: para
#: beans.xml:203
#, no-c-format
msgid ""
"How do we specify that qualifiers of a bean? By annotating the bean class, "
"of course! The following bean has the qualifier <literal>@CreditCard</"
"literal> and implements the bean type <literal>PaymentProcessor</literal>. "
"Therefore, it satisfies our qualified injection point:"
msgstr ""
"Como especificamos os qualificadores de um bean? Anotando a classe de bean, "
"é claro! O seguinte bean possui o qualificador <literal>@CreditCard</"
"literal> e implementa o tipo de bean <literal>PaymentProcessor</literal>. "
"Portanto, ele satisfaz nosso ponto de injeção qualificado:"

#. Tag: programlisting
#: beans.xml:209
#, no-c-format
msgid ""
"<![CDATA[@CreditCard\n"
"public class CreditCardPaymentProcessor \n"
"    implements PaymentProcessor { ... }]]>"
msgstr ""
"<![CDATA[@CreditCard\n"
"public class CreditCardPaymentProcessor \n"
"    implements PaymentProcessor { ... }]]>"

#. Tag: para
#: beans.xml:212
#, no-c-format
msgid ""
"If a bean does not explicitly specify a qualifier, it has the default "
"qualifier, <literal>@Default</literal>."
msgstr ""
"Se um bean não define explicitamente um qualificador, ele terá o "
"qualificador padrão, <literal>@Default</literal>."

#. Tag: para
#: beans.xml:225
#, no-c-format
msgid ""
"That's not quite the end of the story. CDI also defines a simple "
"<emphasis>resolution rule</emphasis> that helps the container decide what to "
"do if there is more than one bean that satisfies a particular contract. "
"We'll get into the details in <xref linkend=\"injection\"/>."
msgstr ""
"Esse não é bem o fim da história. CDI também define uma simples "
"<emphasis>regra de resolução</emphasis> que ajuda o contêiner decidir o que "
"fazer se houver mais de um bean que satisfaz um contrato específico. Vamos "
"entrar em mais detalhes no <xref linkend=\"injection\"/>."

#. Tag: title
#: beans.xml:245
#, no-c-format
msgid "Scope"
msgstr "Escopo"

#. Tag: para
#: beans.xml:248
#, no-c-format
msgid ""
"The <emphasis>scope</emphasis> of a bean defines the lifecycle and "
"visibility of its instances. The CDI context model is extensible, "
"accommodating arbitrary scopes. However, certain important scopes are built "
"into the specification, and provided by the container. Each scope is "
"represented by an annotation type."
msgstr ""
"O <emphasis>escopo</emphasis> de um bean define o ciclo de vida e a "
"visibilidade de suas instâncias. O modelo de contexto da CDI é extensível, "
"acomodando escopos arbitrários. No entanto, certos escopos importantes estão "
"encorporados na especificação, e fornecidos pelo contêiner. Cada escopo é "
"representado por um tipo de anotação."

#. Tag: para
#: beans.xml:255
#, no-c-format
msgid ""
"For example, any web application may have <emphasis>session scoped</"
"emphasis> bean:"
msgstr ""
"Por exemplo, qualquer aplicação web pode possuir beans com <emphasis>escopo "
"de sessão</emphasis>:"

#. Tag: programlisting
#: beans.xml:259
#, no-c-format
msgid ""
"<![CDATA[public @SessionScoped\n"
"class ShoppingCart implements Serializable { ... }]]>"
msgstr ""
"<![CDATA[public @SessionScoped\n"
"class ShoppingCart implements Serializable { ... }]]>"

#. Tag: para
#: beans.xml:261
#, no-c-format
msgid ""
"An instance of a session-scoped bean is bound to a user session and is "
"shared by all requests that execute in the context of that session."
msgstr ""
"Uma instância de um bean com escopo de sessão está vinculada à sessão do "
"usuário e é compartilhada por todas as solicitações executadas no contexto "
"desta sessão."

#. Tag: para
#: beans.xml:265
#, no-c-format
msgid ""
"Keep in mind that once a bean is bound to a context, it remains in that "
"context until the context is destroyed. There is no way to manually remove a "
"bean from a context. If you don't want the bean to sit in the session "
"indefinitely, consider using another scope with a shorted lifespan, such as "
"the request or conversation scope."
msgstr ""
"Mantenha em mente que uma vez que um bean está vinculado a um contexto, ele "
"permanece neste contexto até que o contexto seja destruído. Não existe modo "
"algum para remover manualmente um bean daquele contexto. Se você não quer "
"que o bean fique na sessão indefinitivamente, considere o uso de um outro "
"escopo com um tempo de vida mais curto, como os escopos de solicitação e "
"conversação."

#. Tag: para
#: beans.xml:273
#, no-c-format
msgid ""
"If a scope is not explicitly specified, then the bean belongs to a special "
"scope called the <emphasis>dependent pseudo-scope</emphasis>. Beans with "
"this scope live to serve the object into which they were injected, which "
"means their lifecycle is bound to the lifecycle of that object."
msgstr ""
"Se um escopo não está explicitamente especificado, então o bean pertence a "
"um escopo especial chamado de <emphasis>pseudo-escopo dependente</emphasis>. "
"Os beans com este escopo vivem para servir o objeto no qual eles foram "
"injetados, o que significa que seu ciclo de vida está vinculado ao ciclo de "
"vida deste objeto."

#. Tag: para
#: beans.xml:279
#, no-c-format
msgid "We'll talk more about scopes in <xref linkend=\"scopescontexts\"/>."
msgstr ""
"Nós falaremos mais sobre escopos no <xref linkend=\"scopescontexts\"/>."

#. Tag: title
#: beans.xml:284
#, no-c-format
msgid "EL name"
msgstr "Nome EL"

#. Tag: para
#: beans.xml:286
#, no-c-format
msgid ""
"If you want to reference a bean in non-Java code that supports Unified EL "
"expressions, for example, in a JSP or JSF page, you must assign the bean an "
"<emphasis>EL name</emphasis>."
msgstr ""
"Se você quer referenciar um bean em um código não-Java que suporta "
"expressões Unified EL, por exemplo, em uma página JSP ou JSF, você deve "
"assinar o bean com um <emphasis>nome EL</emphasis>."

#. Tag: para
#: beans.xml:291
#, no-c-format
msgid ""
"The EL name is specified using the <literal>@Named</literal> annotation, as "
"shown here:"
msgstr ""
"O nome EL é especificado usando a anotação <literal>@Named</literal>, como "
"mostrado aqui:"

#. Tag: programlisting
#: beans.xml:295
#, no-c-format
msgid ""
"<![CDATA[public @SessionScoped @Named(\"cart\")\n"
"class ShoppingCart implements Serializable { ... }]]>"
msgstr ""
"<![CDATA[public @SessionScoped @Named(\"cart\")\n"
"class ShoppingCart implements Serializable { ... }]]>"

#. Tag: para
#: beans.xml:297
#, no-c-format
msgid "Now we can easily use the bean in any JSF or JSP page:"
msgstr "Agora podemos facilmente usar o bean em qualquer página JSF ou JSP:"

#. Tag: programlisting
#: beans.xml:299
#, no-c-format
msgid ""
"<![CDATA[<h:dataTable value=\"#{cart.lineItems}\" var=\"item\">\n"
"   ...\n"
"</h:dataTable>]]>"
msgstr ""
"<![CDATA[<h:dataTable value=\"#{cart.lineItems}\" var=\"item\">\n"
"   ...\n"
"</h:dataTable>]]>"

#. Tag: para
#: beans.xml:302
#, no-c-format
msgid ""
"The <literal>@Named</literal> annotation is not what makes the class a bean. "
"Most classes in a bean archive are already recognized as beans. The "
"<literal>@Named</literal> annotation just makes it possible to reference the "
"bean from the EL, most commonly from a JSF view."
msgstr ""
"A anotação <literal>@Named</literal> não é o que torna a classe um bean. A "
"maioria das classes em um arquivo de beans já são reconhecidas como beans. A "
"anotação <literal>@Named</literal> apenas torna possível referenciar o bean "
"a partir da EL, mais comumente a partir de uma visão JSF."

#. Tag: para
#: beans.xml:309
#, no-c-format
msgid ""
"We can let CDI choose a name for us by leaving off the value of the "
"<literal>@Named</literal> annotation:"
msgstr ""
"Nós podemos deixar o CDI escolher um nome para nós, deixando de fora o valor "
"da anotação <literal>@Named</literal>:"

#. Tag: programlisting
#: beans.xml:313
#, no-c-format
msgid ""
"<![CDATA[public @SessionScoped @Named\n"
"class ShoppingCart implements Serializable { ... }]]>"
msgstr ""
"<![CDATA[public @SessionScoped @Named\n"
"class ShoppingCart implements Serializable { ... }]]>"

#. Tag: para
#: beans.xml:315
#, no-c-format
msgid ""
"The name defaults to the unqualified class name, decapitalized; in this "
"case, <literal>shoppingCart</literal>."
msgstr ""
"O nome padrão vem do nome não-qualificado da classe, descapitalizado; neste "
"caso, <literal>shoppingCart</literal>."

#. Tag: title
#: beans.xml:325
#, no-c-format
msgid "Alternatives"
msgstr "Alternativos"

#. Tag: para
#: beans.xml:327
#, no-c-format
msgid ""
"We've already seen how qualifiers let us choose between multiple "
"implementations of an interface at development time. But sometimes we have "
"an interface (or other bean type) whose implementation varies depending upon "
"the deployment environment. For example, we may want to use a mock "
"implementation in a testing environment. An <emphasis>alternative</emphasis> "
"may be declared by annotating the bean class with the <literal>@Alternative</"
"literal> annotation."
msgstr ""
"Nós já vimos como os qualificadores nos permite escolher entre múltiplas "
"implementações de uma interface durante o desenvolvimento. Mas algumas vezes "
"temos uma interface (ou outro tipo de bean), cuja implementação varia "
"dependendo do ambiente de implantação. Por exemplo, podemos querer usar uma "
"implementação de imitação em um ambiente de teste. Uma "
"<emphasis>alternativa</emphasis> seria declarar a classe de bean com a "
"anotação <literal>@Alternative</literal>."

#. Tag: programlisting
#: beans.xml:335
#, no-c-format
msgid ""
"<![CDATA[public @Alternative\n"
"class MockPaymentProcessor extends PaymentProcessorImpl { ... }]]>"
msgstr ""
"<![CDATA[public @Alternative\n"
"class MockPaymentProcessor extends PaymentProcessorImpl { ... }]]>"

#. Tag: para
#: beans.xml:337
#, no-c-format
msgid ""
"We normally annotate a bean <literal>@Alternative</literal> only when there "
"is some other implementation of an interface it implements (or of any of its "
"bean types). We can choose between alternatives at deployment time by "
"<emphasis>selecting</emphasis> an alternative in the CDI deployment "
"descriptor <literal>META-INF/beans.xml</literal> of the JAR or Java EE "
"module that uses it. Different modules can specify that they use different "
"alternatives."
msgstr ""
"Normalmente anotamos um bean com <literal>@Alternative</literal> somente "
"quando existe alguma outra implementação de uma interface que ele implementa "
"(ou de qualquer de seus tipos de bean). Podemos escolher entre as "
"alternativas no momento da implantação <emphasis>selecionando</emphasis> uma "
"alternativa no descritor de implantação do CDI <literal>META-INF/beans.xml</"
"literal> dentro do JAR ou módulo Java EE que utiliza-o. Diferentes módulos "
"podem especificar que eles usam diferentes alternativas."

#. Tag: para
#: beans.xml:345
#, no-c-format
msgid ""
"We cover alternatives in more detail in <xref linkend=\"alternatives\"/>."
msgstr ""
"Nós cobriremos os alternativos em mais detalhes na <xref linkend="
"\"alternatives\"/>."

#. Tag: title
#: beans.xml:352
#, no-c-format
msgid "Interceptor binding types"
msgstr "Tipos para vinculação de interceptador"

#. Tag: para
#: beans.xml:354
#, no-c-format
msgid ""
"You might be familiar with the use of interceptors in EJB 3.0. In Java EE 6, "
"this functionality has been generalized to work with other managed beans. "
"That's right, you no longer have to make your bean an EJB just to intercept "
"its methods. Holler. So what does CDI have to offer above and beyond that? "
"Well, quite a lot actually. Let's cover some background."
msgstr ""
"Você pode estar familiarizado com o uso de interceptadores em EJB 3.0. Em "
"Java EE 6, esta funcionalidade foi generalizada para trabalhar com outros "
"beans gerenciados. Está bem, você não precisa tornar seu bean um EJB apenas "
"para interceptar seus métodos. (Berro). Então, o que CDI tem a oferecer além "
"disso? Bem, bastante realmente. Vamos dar algumas explicações."

#. Tag: para
#: beans.xml:361
#, no-c-format
msgid ""
"The way that interceptors were defined in Java EE 5 was counter-intuitive. "
"You were required to specify the <emphasis>implementation</emphasis> of the "
"interceptor directly on the <emphasis>implementation</emphasis> of the EJB, "
"either in the <literal>@Interceptors</literal> annotation or in the XML "
"descriptor. You might as well just put the interceptor code <emphasis>in</"
"emphasis> the implementation! Second, the order in which the interceptors "
"are applied is taken from the order in which they are declared in the "
"annotation or the XML descriptor. Perhaps this isn't so bad if you're "
"applying the interceptors to a single bean. But, if you are applying them "
"repeatedly, then there's a good chance that you'll inadvertently define a "
"different order for different beans. Now that's a problem."
msgstr ""
"A maneira em que interceptadores foram definidos em Java EE 5 não foi muito "
"intuitivo. Era necessário especificar a <emphasis>implementação</emphasis> "
"do interceptador diretamente na <emphasis>implementação</emphasis> do EJB, "
"seja pela anotação <literal>@Interceptors</literal> ou no descritor XML. "
"Você pode muito bem apenas colocar o código do interceptador "
"<emphasis>dentro</emphasis> da implementação! Em segundo lugar, a ordem na "
"qual os interceptadores são aplicados é obtida a partir da ordem na qual "
"eles são declarados na anotação ou no descritor XML. Talvez isto não seja "
"tão ruim se você está aplicando os interceptadores a um único bean. Mas, se "
"você está aplicando eles repetidamente, então há uma boa chance de você "
"definir por descuido uma ordem diferente para diferentes beans. Agora isso é "
"um problema."

#. Tag: para
#: beans.xml:372
#, no-c-format
msgid ""
"CDI provides a new approach to binding interceptors to beans that introduces "
"a level of indirection (and thus control). We must define an "
"<emphasis>interceptor binding type</emphasis> to describe the behavior "
"implemented by the interceptor."
msgstr ""
"CDI fornece uma nova abordagem para vincular interceptadores a beans que "
"introduz um nível de indirecionamento (e, portanto, de controle). Nós temos "
"que definir um <emphasis>tipo para vinculação de interceptador</emphasis> "
"que descreve o comportamento implementado pelo interceptador."

#. Tag: para
#: beans.xml:378
#, no-c-format
msgid ""
"An interceptor binding type is a user-defined annotation that is itself "
"annotated <literal>@InterceptorBinding</literal>. It lets us bind "
"interceptor classes to bean classes with no direct dependency between the "
"two classes."
msgstr ""
"Um tipo para vinculação de interceptador é uma anotação definida pelo "
"usuário que é ela mesma anotada com <literal>@InterceptorBinding</literal>. "
"Isto nos permite vincular as classes de interceptador a classes de bean com "
"nenhuma dependência direta entre as duas classes."

#. Tag: programlisting
#: beans.xml:383
#, no-c-format
msgid ""
"<![CDATA[@InterceptorBinding\n"
"@Inherited\n"
"@Target( { TYPE, METHOD })\n"
"@Retention(RUNTIME)\n"
"public @interface Transactional {}]]>"
msgstr ""
"<![CDATA[@InterceptorBinding\n"
"@Inherited\n"
"@Target( { TYPE, METHOD })\n"
"@Retention(RUNTIME)\n"
"public @interface Transactional {}]]>"

#. Tag: para
#: beans.xml:385
#, no-c-format
msgid ""
"The interceptor that implements transaction management declares this "
"annotation:"
msgstr ""
"O interceptador que implementa o gerenciamento de transação declara esta "
"anotação:"

#. Tag: programlisting
#: beans.xml:389
#, no-c-format
msgid ""
"<![CDATA[public @Transactional @Interceptor\n"
"class TransactionInterceptor { ... }]]>"
msgstr ""
"<![CDATA[public @Transactional @Interceptor\n"
"class TransactionInterceptor { ... }]]>"

#. Tag: para
#: beans.xml:391
#, no-c-format
msgid ""
"We can apply the interceptor to a bean by annotating the bean class with the "
"same interceptor binding type:"
msgstr ""
"Podemos aplicar o interceptador em um bean anotando a classe de bean com o "
"mesmo tipo para vinculação de interceptador."

#. Tag: programlisting
#: beans.xml:395
#, no-c-format
msgid ""
"<![CDATA[public @SessionScoped @Transactional\n"
"class ShoppingCart implements Serializable { ... }]]>"
msgstr ""
"<![CDATA[public @SessionScoped @Transactional\n"
"class ShoppingCart implements Serializable { ... }]]>"

#. Tag: para
#: beans.xml:397
#, no-c-format
msgid ""
"Notice that <literal>ShoppingCart</literal> and "
"<literal>TransactionInterceptor</literal> don't know anything about each "
"other."
msgstr ""
"Observe que <literal>ShoppingCart</literal> e "
"<literal>TransactionInterceptor</literal> não sabem nada sobre o outro."

#. Tag: para
#: beans.xml:402
#, no-c-format
msgid ""
"Interceptors are deployment-specific. (We don't need a "
"<literal>TransactionInterceptor</literal> in our unit tests!) By default, an "
"interceptor is disabled. We can enable an interceptor using the CDI "
"deployment descriptor <literal>META-INF/beans.xml</literal> of the JAR or "
"Java EE module. This is also where we specify the interceptor ordering."
msgstr ""
"Interceptadores são específicos de implantação. (Não precisamos de um "
"<literal>TransactionInterceptor</literal> em nossos testes de unidade!) Por "
"padrão, um interceptador está disabilitado. Podemos habilitar um "
"interceptador usando o descritor de implantação do CDI <literal>META-INF/"
"beans.xml</literal> do JAR ou módulo Java EE."

#. Tag: para
#: beans.xml:409
#, no-c-format
msgid ""
"We'll discuss interceptors, and their cousins, decorators, in <xref linkend="
"\"interceptors\"/> and <xref linkend=\"decorators\"/>."
msgstr ""
"Discutiremos sobre interceptadores, e seus primos decoradores, no <xref "
"linkend=\"interceptors\"/> e <xref linkend=\"decorators\"/>."

#. Tag: title
#: beans.xml:419
#, no-c-format
msgid "What kinds of classes are beans?"
msgstr ""

#. Tag: para
#: beans.xml:421
#, no-c-format
msgid ""
"We've already seen two types of beans: JavaBeans and EJB session beans. Is "
"that the whole story? Actually, it's just the beginning. Let's explore the "
"various kinds of beans that CDI implementations must support out-of-the-box."
msgstr ""

#. Tag: title
#: beans.xml:428
#, no-c-format
msgid "Managed beans"
msgstr ""

#. Tag: para
#: beans.xml:430
#, no-c-format
msgid ""
"A managed bean is a Java class. The basic lifecycle and semantics of a "
"managed bean are defined by the Managed Beans specification. You can "
"explicitly declare a managed bean by annotating the bean class "
"<literal>@ManagedBean</literal>, but in CDI you don't need to. According to "
"the specification, the CDI container treats any class that satisfies the "
"following conditions as a managed bean:"
msgstr ""

#. Tag: para
#: beans.xml:441
#, no-c-format
msgid "It is not a non-static inner class."
msgstr ""

#. Tag: para
#: beans.xml:444
#, no-c-format
msgid "It is a concrete class, or is annotated <literal>@Decorator</literal>."
msgstr ""

#. Tag: para
#: beans.xml:447
#, no-c-format
msgid ""
"It is not annotated with an EJB component-defining annotation or declared as "
"an EJB bean class in <literal>ejb-jar.xml</literal>."
msgstr ""

#. Tag: para
#: beans.xml:453
#, no-c-format
msgid ""
"It does not implement <literal>javax.enterprise.inject.spi.Extension</"
"literal>."
msgstr ""

#. Tag: para
#: beans.xml:456
#, no-c-format
msgid "It has an appropriate constructor&#8212;either:"
msgstr ""

#. Tag: para
#: beans.xml:461
#, no-c-format
msgid "the class has a constructor with no parameters, or"
msgstr ""

#. Tag: para
#: beans.xml:464
#, no-c-format
msgid "the class declares a constructor annotated <literal>@Inject</literal>."
msgstr ""

#. Tag: para
#: beans.xml:472
#, no-c-format
msgid ""
"The unrestricted set of bean types for a managed bean contains the bean "
"class, every superclass and all interfaces it implements directly or "
"indirectly."
msgstr ""

#. Tag: para
#: beans.xml:475
#, no-c-format
msgid ""
"If a managed bean has a public field, it must have the default scope "
"<literal>@Dependent</literal>."
msgstr ""

#. Tag: para
#: beans.xml:477
#, no-c-format
msgid ""
"Managed beans support the <literal>@PostConstruct</literal> and "
"<literal>@PreDestroy</literal> lifecycle callbacks."
msgstr ""

#. Tag: para
#: beans.xml:480
#, no-c-format
msgid ""
"Session beans are also, technically, managed beans. However, since they have "
"their own special lifecycle and take advantage of additional enterprise "
"services, the CDI specification considers them to be a different kind of "
"bean."
msgstr ""

#. Tag: title
#: beans.xml:489
#, no-c-format
msgid "Session beans"
msgstr ""

#. Tag: para
#: beans.xml:491
#, no-c-format
msgid ""
"Session beans belong to the EJB specification. They have a special "
"lifecycle, state management and concurrency model that is different to other "
"managed beans and non-managed Java objects. But session beans participate in "
"CDI just like any other bean. You can inject one session bean into another "
"session bean, a managed bean into a session bean, a session bean into a "
"managed bean, have a managed bean observe an event raised by a session bean, "
"and so on."
msgstr ""

#. Tag: para
#: beans.xml:500
#, no-c-format
msgid ""
"Message-driven and entity beans are by nature non-contextual objects and may "
"not be injected into other objects. However, message-driven beans can take "
"advantage of some CDI functionality, such as dependency injection, "
"interceptors and decorators. In fact, CDI will perform injection into any "
"session or message-driven bean, even those which are not contextual "
"instances."
msgstr ""

#. Tag: para
#: beans.xml:508
#, no-c-format
msgid ""
"The unrestricted set of bean types for a session bean contains all local "
"interfaces of the bean and their superinterfaces. If the session bean has a "
"bean class local view, the unrestricted set of bean types contains the bean "
"class and all superclasses. In addition, <literal>java.lang.Object</literal> "
"is a bean type of every session bean. But remote interfaces are "
"<emphasis>not</emphasis> included in the set of bean types."
msgstr ""

#. Tag: para
#: beans.xml:516
#, no-c-format
msgid ""
"There's no reason to explicitly declare the scope of a stateless session "
"bean or singleton session bean. The EJB container controls the lifecycle of "
"these beans, according to the semantics of the <literal>@Stateless</literal> "
"or <literal>@Singleton</literal> declaration. On the other hand, a stateful "
"session bean may have any scope."
msgstr ""

#. Tag: para
#: beans.xml:520
#, no-c-format
msgid ""
"Stateful session beans may define a <emphasis>remove method</emphasis>, "
"annotated <literal>@Remove</literal>, that is used by the application to "
"indicate that an instance should be destroyed. However, for a contextual "
"instance of the bean&#8212;an instance under the control of CDI&#8212;this "
"method may only be called by the application if the bean has scope "
"<literal>@Dependent</literal>. For beans with other scopes, the application "
"must let the container destroy the bean."
msgstr ""

#. Tag: para
#: beans.xml:528
#, no-c-format
msgid ""
"So, when should we use a session bean instead of a plain managed bean? "
"Whenever we need the advanced enterprise services offered by EJB, such as:"
msgstr ""

#. Tag: para
#: beans.xml:535
#, no-c-format
msgid "method-level transaction management and security,"
msgstr ""

#. Tag: para
#: beans.xml:538
#, no-c-format
msgid "concurrency management,"
msgstr ""

#. Tag: para
#: beans.xml:541
#, no-c-format
msgid ""
"instance-level passivation for stateful session beans and instance-pooling "
"for stateless session beans,"
msgstr ""

#. Tag: para
#: beans.xml:545
#, no-c-format
msgid "remote or web service invocation, or"
msgstr ""

#. Tag: para
#: beans.xml:548
#, no-c-format
msgid "timers and asynchronous methods,"
msgstr ""

#. Tag: para
#: beans.xml:552
#, no-c-format
msgid ""
"When we don't need any of these things, an ordinary managed bean will serve "
"just fine."
msgstr ""

#. Tag: para
#: beans.xml:554
#, no-c-format
msgid ""
"Many beans (including any <literal>@SessionScoped</literal> or "
"<literal>@ApplicationScoped</literal> beans) are available for concurrent "
"access. Therefore, the concurrency management provided by EJB 3.1 is "
"especially useful. Most session and application scoped beans should be EJBs."
msgstr ""

#. Tag: para
#: beans.xml:560
#, no-c-format
msgid ""
"Beans which hold references to heavy-weight resources, or hold a lot of "
"internal state benefit from the advanced container-managed lifecycle defined "
"by the EJB stateless/stateful/singleton model, with its support for "
"passivation and instance pooling."
msgstr ""

#. Tag: para
#: beans.xml:566
#, no-c-format
msgid ""
"Finally, it's usually obvious when method-level transaction management, "
"method-level security, timers, remote methods or asynchronous methods are "
"needed."
msgstr ""

#. Tag: para
#: beans.xml:571
#, no-c-format
msgid ""
"The point we're trying to make is: use a session bean when you need the "
"services it provides, not just because you want to use dependency injection, "
"lifecycle management, or interceptors. Java EE 6 provides a graduated "
"programming model. It's usually easy to start with an ordinary managed bean, "
"and later turn it into an EJB just by adding one of the following "
"annotations: <literal>@Stateless</literal>, <literal>@Stateful</literal> or "
"<literal>@Singleton</literal>."
msgstr ""

#. Tag: para
#: beans.xml:579
#, no-c-format
msgid ""
"On the other hand, don't be scared to use session beans just because you've "
"heard your friends say they're \"heavyweight\". It's nothing more than "
"superstition to think that something is \"heavier\" just because it's hosted "
"natively within the Java EE container, instead of by a proprietary bean "
"container or dependency injection framework that runs as an additional layer "
"of obfuscation. And as a general principle, you should be skeptical of folks "
"who use vaguely defined terminology like \"heavyweight\"."
msgstr ""

#. Tag: title
#: beans.xml:590
#, no-c-format
msgid "Producer methods"
msgstr ""

#. Tag: para
#: beans.xml:592
#, no-c-format
msgid ""
"Not everything that needs to be injected can be boiled down to a bean class "
"instantiated by the container using <literal>new</literal>. There are plenty "
"of cases where we need additional control. What if we need to decide at "
"runtime which implementation of a type to instantiate and inject? What if we "
"need to inject an object that is obtained by querying a service or "
"transactional resource, for example by executing a JPA query?"
msgstr ""

#. Tag: para
#: beans.xml:600
#, no-c-format
msgid ""
"A <emphasis>producer method</emphasis> is a method that acts as a source of "
"bean instances. The method declaration itself describes the bean and the "
"container invokes the method to obtain an instance of the bean when no "
"instance exists in the specified context. A producer method lets the "
"application take full control of the bean instantiation process."
msgstr ""

#. Tag: para
#: beans.xml:607
#, no-c-format
msgid ""
"A producer method is declared by annotating a method of a bean class with "
"the <literal>@Produces</literal> annotation."
msgstr ""

#. Tag: programlisting
#: beans.xml:612
#, no-c-format
msgid ""
"<![CDATA[@ApplicationScoped\n"
"public class RandomNumberGenerator {\n"
"   \n"
"   private Random random = new Random(System.currentTimeMillis());\n"
"       \n"
"   @Produces @Named @Random int getRandomNumber() {\n"
"      return random.nextInt(100);\n"
"   }\n"
"   \n"
"}]]>"
msgstr ""
"<![CDATA[@ApplicationScoped\n"
"public class RandomNumberGenerator {\n"
"   \n"
"   private Random random = new Random(System.currentTimeMillis());\n"
"       \n"
"   @Produces @Named @Random int getRandomNumber() {\n"
"      return random.nextInt(100);\n"
"   }\n"
"   \n"
"}]]>"

#. Tag: para
#: beans.xml:614
#, no-c-format
msgid ""
"We can't write a bean class that is itself a random number. But we can "
"certainly write a method that returns a random number. By making the method "
"a producer method, we allow the return value of the method&#8212;in this "
"case an <literal>Integer</literal>&#8212;to be injected. We can even specify "
"a qualifier&#8212;in this case <literal>@Random</literal>, a scope&#8212;"
"which in this case defaults to <literal>@Dependent</literal>, and an EL "
"name&#8212;which in this case defaults to <literal>randomNumber</literal> "
"according to the JavaBeans property name convention. Now we can get a random "
"number anywhere:"
msgstr ""

#. Tag: programlisting
#: beans.xml:623
#, no-c-format
msgid "<![CDATA[@Inject @Random int randomNumber;]]>"
msgstr "<![CDATA[@Inject @Random int randomNumber;]]>"

#. Tag: para
#: beans.xml:625
#, no-c-format
msgid "Even in a Unified EL expression:"
msgstr ""

#. Tag: programlisting
#: beans.xml:629
#, no-c-format
msgid "<![CDATA[<p>Your raffle number is #{randomNumber}.</p>]]>"
msgstr "<![CDATA[<p>Your raffle number is #{randomNumber}.</p>]]>"

#. Tag: para
#: beans.xml:631
#, no-c-format
msgid ""
"A producer method must be a non-abstract method of a managed bean class or "
"session bean class. A producer method may be either static or non-static. If "
"the bean is a session bean, the producer method must be either a business "
"method of the EJB or a static method of the bean class."
msgstr ""

#. Tag: para
#: beans.xml:637
#, no-c-format
msgid "The bean types of a producer method depend upon the method return type:"
msgstr ""

#. Tag: para
#: beans.xml:643
#, no-c-format
msgid ""
"If the return type is an interface, the unrestricted set of bean types "
"contains the return type, all interfaces it extends directly or indirectly "
"and <literal>java.lang.Object</literal>."
msgstr ""

#. Tag: para
#: beans.xml:649
#, no-c-format
msgid ""
"If a return type is primitive or is a Java array type, the unrestricted set "
"of bean types contains exactly two types: the method return type and "
"<literal>java.lang.Object</literal>."
msgstr ""

#. Tag: para
#: beans.xml:655
#, no-c-format
msgid ""
"If the return type is a class, the unrestricted set of bean types contains "
"the return type, every superclass and all interfaces it implements directly "
"or indirectly."
msgstr ""

#. Tag: para
#: beans.xml:662
#, no-c-format
msgid ""
"If the producer method has method parameters, the container will look for a "
"bean that satisfies the type and qualifiers of each parameter and pass it to "
"the method automatically&#8212;another form of dependency injection."
msgstr ""

#. Tag: programlisting
#: beans.xml:668
#, no-c-format
msgid ""
"<![CDATA[@Produces Set<Roles> getRoles(User user) {\n"
"   return user.getRoles();\n"
"}]]>"
msgstr ""
"<![CDATA[@Produces Set<Roles> getRoles(User user) {\n"
"   return user.getRoles();\n"
"}]]>"

#. Tag: para
#: beans.xml:670
#, no-c-format
msgid ""
"We'll talk much more about producer methods in <xref linkend="
"\"producermethods\"/>."
msgstr ""

#. Tag: title
#: beans.xml:675
#, no-c-format
msgid "Producer fields"
msgstr ""

#. Tag: para
#: beans.xml:677
#, no-c-format
msgid ""
"A <emphasis>producer field</emphasis> is a simpler alternative to a producer "
"method. A producer field is declared by annotating a field of a bean class "
"with the <literal>@Produces</literal> annotation&#8212;the same annotation "
"used for producer methods."
msgstr ""

#. Tag: programlisting
#: beans.xml:683
#, no-c-format
msgid ""
"<![CDATA[public class Shop {\n"
"   @Produces PaymentProcessor paymentProcessor = ....;\n"
"   @Produces @Catalog List<Product> products = ....;\n"
"}]]>"
msgstr ""
"<![CDATA[public class Shop {\n"
"   @Produces PaymentProcessor paymentProcessor = ....;\n"
"   @Produces @Catalog List<Product> products = ....;\n"
"}]]>"

#. Tag: para
#: beans.xml:685
#, no-c-format
msgid ""
"The rules for determining the bean types of a producer field parallel the "
"rules for producer methods."
msgstr ""

#. Tag: para
#: beans.xml:689
#, no-c-format
msgid ""
"A producer field is really just a shortcut that lets us avoid writing a "
"useless getter method. However, in addition to convenience, producer fields "
"serve a specific purpose as an adaptor for Java EE component environment "
"injection, but to learn more about that, you'll have to wait until <xref "
"linkend=\"resources\"/>. Because we can't wait to get to work on some "
"examples."
msgstr ""

#. Tag: title
#: beans.xml:701
#, no-c-format
msgid "The (minimal) bean descriptor"
msgstr ""

#. Tag: para
#: beans.xml:703
#, no-c-format
msgid ""
"First, it's important to understand that the XML bean descriptor in CDI "
"(beans.xml) is not there to define beans in XML, like in other popular bean "
"containers. Rather, you use this file to enable CDI services for the current "
"bean archive that is difficult to define consistently in Java or which you "
"don't want to define in Java (e.g., to accomodate testing)."
msgstr ""

#. Tag: para
#: beans.xml:710
#, no-c-format
msgid ""
"For example, the XML is used to enable interceptors (which are disabled by "
"default) and define interceptor ordering. So the bean descriptor "
"<emphasis>complements</emphasis> the metadata that is provided in the Java "
"language syntax. (You may still want to define beans in XML for other "
"reasons, but that is the concern of an extension)."
msgstr ""

#. Tag: para
#: beans.xml:717
#, no-c-format
msgid ""
"Let's first ask why the beans.xml is required, then look at what services it "
"is used used to enable."
msgstr ""

#. Tag: title
#: beans.xml:722
#, no-c-format
msgid "Why is beans.xml required?"
msgstr ""

#. Tag: para
#: beans.xml:724
#, no-c-format
msgid ""
"You may be wondering, if beans are not described using XML, why do we need "
"beans.xml at all, particularly if you don't have anything that you would "
"need the bean descriptor to enable (alternatives, interceptors or "
"decorators)?"
msgstr ""

#. Tag: para
#: beans.xml:730
#, no-c-format
msgid "There are two things about CDI that we need to keep in mind:"
msgstr ""

#. Tag: para
#: beans.xml:736
#, no-c-format
msgid ""
"CDI does not require any special declaration for a Java class to be injected "
"- that's right, no annotation or XML declaration at all!"
msgstr ""

#. Tag: para
#: beans.xml:742
#, no-c-format
msgid ""
"CDI does not define any special kind of module - CDI beans can be deployed "
"in a library JAR, EJB JAR, WAR, RAR, or JVM classpath directory."
msgstr ""

#. Tag: para
#: beans.xml:749
#, no-c-format
msgid ""
"The CDI specification calls the process of identifying beans in modules "
"<emphasis>bean discovery</emphasis>."
msgstr ""

#. Tag: para
#: beans.xml:753
#, no-c-format
msgid ""
"So there are potentially a lot of classes in the classpath which might be "
"beans! We don't want to force the container to scan every one of those "
"classes at startup and build its internal metamodel for each of them. This "
"really could make bean discovery very slow."
msgstr ""

#. Tag: para
#: beans.xml:759
#, no-c-format
msgid ""
"But there's another reason we need to give the user some control over which "
"classes are available for injection. We don't want every class in the "
"classpath to potentially match an injection point, including classes that "
"were never intended to be injected into things. This would force the "
"developer to have to use qualifiers much more often to disambiguate "
"injection points."
msgstr ""

#. Tag: para
#: beans.xml:766
#, no-c-format
msgid "So we have two choices. We could have the developer:"
msgstr ""

#. Tag: para
#: beans.xml:772
#, no-c-format
msgid "explicitly exclude modules which do not contain beans, or"
msgstr ""

#. Tag: para
#: beans.xml:775
#, no-c-format
msgid "explicitly declare modules which do contain beans."
msgstr ""

#. Tag: para
#: beans.xml:779
#, no-c-format
msgid ""
"It should be clear that the second option is a much better way to go. Thus, "
"CDI has the notion of a bean archive. A bean archive is just a module that "
"has a file named beans.xml in the META-INF directory. The container looks "
"for beans in bean archives. It ignores other modules."
msgstr ""

#. Tag: para
#: beans.xml:785
#, no-c-format
msgid ""
"Now, you might be wondering if we've got the granularity wrong here. Why "
"should module be the right criteria to use for including/excluding a class. "
"Why not consider:"
msgstr ""

#. Tag: para
#: beans.xml:792
#, no-c-format
msgid "a class-level annotation,"
msgstr ""

#. Tag: para
#: beans.xml:795
#, no-c-format
msgid "the package,"
msgstr ""

#. Tag: para
#: beans.xml:798
#, no-c-format
msgid "some type it implements or extends, or"
msgstr ""

#. Tag: para
#: beans.xml:801
#, no-c-format
msgid "some naming convention."
msgstr ""

#. Tag: para
#: beans.xml:805
#, no-c-format
msgid ""
"We've got the first option covered. Annotate a bean <literal>@Alternative</"
"literal>, or with an alternative stereotype, and it will be considered "
"disabled by CDI, as long as you don't explicitly enable it in beans.xml. "
"That's not quite the same thing as excluding the class from scanning "
"altogether, but it's close. (One difference is that a portable extension "
"with still get a <literal>ProcessAnnotatedType</literal> event for that "
"class)."
msgstr ""

#. Tag: para
#: beans.xml:813
#, no-c-format
msgid ""
"A future version of CDI might allow you to declare excluded packages in "
"beans.xml. Excluding a bean by type or naming convention isn't really that "
"appealing. In the world of CDI, we use stereotypes for identifying "
"architectural roles. We don't use marker interfaces or naming conventions. "
"Names really shouldn't affect functionality as it is too fragile."
msgstr ""

#. Tag: para
#: beans.xml:820
#, no-c-format
msgid "Enough theory, what elements are available in beans.xml?"
msgstr ""

#. Tag: title
#: beans.xml:826
#, no-c-format
msgid "Bean descriptor schema"
msgstr ""

#. Tag: para
#: beans.xml:828
#, no-c-format
msgid ""
"If you don't need to activate any interceptors, decorators or alternatives "
"(you just have plain beans that you need to use in an archive), the beans."
"xml file can be <emphasis>empty</emphasis>. If you do have one of these "
"requirements, then you need to start popularing the descriptor."
msgstr ""

#. Tag: para
#: beans.xml:834
#, no-c-format
msgid ""
"The root element of a beans.xml file is <literal>beans</literal>, with the "
"following <ulink url=\"http://anonsvn.jboss.org/repos/weld/api/trunk/cdi/src/"
"main/resources/beans.xsd\">schema</ulink>:"
msgstr ""

#. Tag: programlisting
#: beans.xml:839
#, no-c-format
msgid ""
"<![CDATA[<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n"
"<beans xmlns=\"http://java.sun.com/xml/ns/javaee\"\n"
"   xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n"
"   xsi:schemaLocation=\"\n"
"      http://java.sun.com/xml/ns/javaee \n"
"      http://java.sun.com/xml/ns/javaee/beans_1_0.xsd\">\n"
"</beans>]]>"
msgstr ""

#. Tag: para
#: beans.xml:841
#, no-c-format
msgid ""
"The <literal>beans</literal> element can have one or more of each of the "
"following children:"
msgstr ""

#. Tag: literal
#: beans.xml:847
#, no-c-format
msgid "interceptors"
msgstr ""

#. Tag: literal
#: beans.xml:850
#, no-c-format
msgid "decorators"
msgstr ""

#. Tag: literal
#: beans.xml:853
#, no-c-format
msgid "alternatives"
msgstr ""

#. Tag: para
#: beans.xml:857
#, no-c-format
msgid "Let's look at each element in detail."
msgstr ""

#. Tag: title
#: beans.xml:862
#, no-c-format
msgid "&lt;interceptors&gt;"
msgstr ""

#. Tag: para
#: beans.xml:864
#, no-c-format
msgid ""
"By default, a bean archive has no enabled interceptors bound via interceptor "
"bindings. An interceptor must be explicitly enabled by listing the fully "
"qualified class name in a child &lt;class&gt; element of &lt;"
"interceptors&gt;."
msgstr ""

#. Tag: para
#: beans.xml:870
#, no-c-format
msgid ""
"There may be zero or more interceptor class elements. The order of the class "
"declarations determines the interceptor ordering. Interceptors which occur "
"earlier in the list are called first. The same class may not be listed "
"twice. And of course, the class must exist and it must be an interceptor "
"class."
msgstr ""

#. Tag: programlisting
#: beans.xml:877
#, no-c-format
msgid ""
"<![CDATA[<interceptors>\n"
"   <class>com.acme.intercept.SecurityInterceptor</class>\n"
"   <class>com.acme.intercept.TransactionInterceptor</class>\n"
"</interceptors>]]>"
msgstr ""

#. Tag: title
#: beans.xml:883
#, no-c-format
msgid "&lt;decorators&gt;"
msgstr ""

#. Tag: para
#: beans.xml:885
#, no-c-format
msgid ""
"By default, a bean archive has no enabled decorators. A decorator must be "
"explicitly enabled by listing the fully qualified class name in a child &lt;"
"class&gt; element of &lt;decorators&gt;."
msgstr ""

#. Tag: para
#: beans.xml:891
#, no-c-format
msgid ""
"There may be zero or more decorator class elements. The order of the class "
"declarations determines the decorator ordering. Decorators which occur "
"earlier in the list are called first. The same class may not be listed "
"twice. And of course, the class must exist and it must be an decorator class."
msgstr ""

#. Tag: programlisting
#: beans.xml:898
#, no-c-format
msgid ""
"<![CDATA[<interceptors>\n"
"   <class>com.acme.decorate.BigAccountDecorator</class>\n"
"   <class>com.acme.decorate.SpecialGiftDecorator</class>\n"
"</interceptors>]]>"
msgstr ""

#. Tag: title
#: beans.xml:903
#, no-c-format
msgid "&lt;alternatives&gt;"
msgstr ""

#. Tag: para
#: beans.xml:905
#, no-c-format
msgid ""
"An alternative is a bean that must be explicitly declared in the beans.xml "
"file if it should be available for lookup, injection or EL resolution. By "
"default, a bean archive has no active alternatives. An alternative must be "
"explicitly declared using the fully qualified bean class name or stereotype "
"class name in either a child &lt;class&gt; or &lt;stereotype&gt; element of "
"&lt;alternatives&gt;, respectively."
msgstr ""

#. Tag: para
#: beans.xml:913
#, no-c-format
msgid ""
"An alternative is selected for the bean archive if either: the alternative "
"is a managed bean or session bean and the bean class of the bean is listed, "
"or the alternative is a producer method, field or resource, and the bean "
"class that declares the method or field is listed, or any "
"<literal>@Alternative</literal> stereotype of the alternative is listed."
msgstr ""

#. Tag: para
#: beans.xml:920
#, no-c-format
msgid ""
"There may be zero or more alternative bean class elements. The same class "
"may not be listed twice. And of course, the class must exist and it must be "
"an alternative bean class."
msgstr ""

#. Tag: para
#: beans.xml:925
#, no-c-format
msgid ""
"There may also be zero or more <literal>@Alternative</literal> stereotype "
"elements. The same stereotype may not be listed twice. And of course, the "
"stereotype class must exist and it must be an stereotype annotation."
msgstr ""

#. Tag: programlisting
#: beans.xml:931
#, no-c-format
msgid ""
"<![CDATA[<stereotypes>\n"
"   <class>com.acme.business.MockPaymentProcessor</class>\n"
"   <stereotype>com.acme.stereotype.Mock</stereotype>\n"
"</stereotypes>]]>"
msgstr ""

#. Tag: para
#: beans.xml:935
#, no-c-format
msgid ""
"And that's it! A very simple schema, used only to activate and order CDI "
"services."
msgstr ""
