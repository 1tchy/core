# translation of scopescontexts.po to Korean
# Language ko-KR translations for Introduction_to_Web_Beans package.
#
# Automatically generated, 2009.
# Eunju Kim <eukim@redhat.com>, 2009.
msgid ""
msgstr ""
"Project-Id-Version: scopescontexts\n"
"Report-Msgid-Bugs-To: http://bugs.kde.org\n"
"POT-Creation-Date: 2009-01-06 11:30+0000\n"
"PO-Revision-Date: 2009-01-21 17:14+1000\n"
"Last-Translator: Eunju Kim <eukim@redhat.com>\n"
"Language-Team: Korean <ko@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"X-Generator: KBabel 1.11.4\n"
"Plural-Forms:  nplurals=2; plural=(n!=1);\n\n"
"\n"
"\n"

#. Tag: title
#: scopescontexts.xml:4
#, no-c-format
msgid "Scopes and contexts"
msgstr "범위 및 컨텍스트 "

#. Tag: para
#: scopescontexts.xml:6
#, no-c-format
msgid ""
"So far, we've seen a few examples of <emphasis>scope type annotations</"
"emphasis>. The scope of a Web Bean determines the lifecycle of instances of "
"the Web Bean. The scope also determines which clients refer to which "
"instances of the Web Bean. According to the Web Beans specification, a scope "
"determines:"
msgstr "지금까지 <emphasis>범위 유형 어노테이션</emphasis>의 여러 가지 예를 살펴보았습니다. Web Bean의 범위는 Web Bean 인스턴스의 수명주기를 결정합니다. 또한 범위는 어떤 클라이언트가 어떤 Web Bean 인스턴스를 참조하게 할 지를 결정합니다. Web Beans 사양에 따라 범위는 다음을 결정합니다: "

#. Tag: para
#: scopescontexts.xml:14
#, no-c-format
msgid "When a new instance of any Web Bean with that scope is created"
msgstr "범위와 함께 Web Bean의 새로운 인스턴스가 생성될 시기 "

#. Tag: para
#: scopescontexts.xml:17
#, no-c-format
msgid "When an existing instance of any Web Bean with that scope is destroyed"
msgstr "범위와 함께 Web Bean의 기존 인스턴스가 제거될 시기  "

#. Tag: para
#: scopescontexts.xml:20
#, no-c-format
msgid "Which injected references refer to any instance of a Web Bean with that scope"
msgstr "삽입된 어떤 참조가 범위와 함께 Web Bean 인스턴스를 참조하는 지 "

#. Tag: para
#: scopescontexts.xml:25
#, no-c-format
msgid ""
"For example, if we have a session scoped Web Bean, <literal>CurrentUser</"
"literal>, all Web Beans that are called in the context of the same "
"<literal>HttpSession</literal> will see the same instance of "
"<literal>CurrentUser</literal>. This instance will be automatically created "
"the first time a <literal>CurrentUser</literal> is needed in that session, "
"and automatically destroyed when the session ends."
msgstr "예를 들어, Web Bean 세션 범위가 있을 경우, <literal>CurrentUser</literal>, 동일한 <literal>HttpSession</literal> 컨텍스트에서 호출되는 모든 Web Beans는 동일한 <literal>CurrentUser</literal> 인스턴스를 확인하게 됩니다. 이러한 인스턴스는 세션에서 <literal>CurrentUser</literal>가 처음으로 필요할 때 자동으로 생성되고 세션이 끝나면 자동으로 삭제됩니다. "

#. Tag: title
#: scopescontexts.xml:32
#, no-c-format
msgid "Scope types"
msgstr "범위 유형 "

#. Tag: para
#: scopescontexts.xml:34
#, no-c-format
msgid ""
"Web Beans features an <emphasis>extensible context model</emphasis>. It is "
"possible to define new scopes by creating a new scope type annotation:"
msgstr "Web Beans는 <emphasis>extensible context model</emphasis>을 특징으로 합니다. 새로운 범위 유형 어노테이션을 생성하여 새로운 범위를 정의할 수 있습니다:  "

#. Tag: programlisting
#: scopescontexts.xml:37
#, no-c-format
msgid ""
"<![CDATA[@Retention(RUNTIME)\n"
"@Target({TYPE, METHOD})\n"
"@ScopeType\n"
"public @interface ClusterScoped {}]]>"
msgstr ""
"<![CDATA[@Retention(RUNTIME)\n"
"@Target({TYPE, METHOD})\n"
"@ScopeType\n"
"public @interface ClusterScoped {}]]>"

#. Tag: para
#: scopescontexts.xml:39
#, no-c-format
msgid ""
"Of course, that's the easy part of the job. For this scope type to be "
"useful, we will also need to define a <literal>Context</literal> object that "
"implements the scope! Implementing a <literal>Context</literal> is usually a "
"very technical task, intended for framework development only."
msgstr "물론 이는 이러한 작업 중 쉬운 부분입니다. 이러한 범위 유형을 유용하게 하려면, 범위를 구현하는 <literal>Context</literal> 객체를 정의해야 합니다! <literal>Context</literal> 구현은 아주 기술적인 작업으로, 프레임워크 개발 만을 목적으로 합니다.  "

#. Tag: para
#: scopescontexts.xml:44
#, no-c-format
msgid ""
"We can apply a scope type annotation to a Web Bean implementation class to "
"specify the scope of the Web Bean:"
msgstr "Web Bean 범위를 지정하기 위해 Web Bean 구현 클래스에 범위 유형 어노테이션을 적용할 수 있습니다:  "

#. Tag: programlisting
#: scopescontexts.xml:47
#, no-c-format
msgid ""
"<![CDATA[@ClusterScoped\n"
"public class SecondLevelCache { ... }]]>"
msgstr ""
"<![CDATA[@ClusterScoped\n"
"public class SecondLevelCache { ... }]]>"

#. Tag: para
#: scopescontexts.xml:58
#, no-c-format
msgid "Usually, you'll use one of Web Beans' built-in scopes."
msgstr "주로, Web Beans의 내장된 범위 중 하나를 사용하게 됩니다.  "

#. Tag: title
#: scopescontexts.xml:63
#, no-c-format
msgid "Built-in scopes"
msgstr "내장된 범위 "

#. Tag: para
#: scopescontexts.xml:65
#, no-c-format
msgid "Web Beans defines four built-in scopes:"
msgstr "Web Beans는 네 가지 내장된 범위를 정의합니다:  "

#. Tag: literal
#: scopescontexts.xml:69
#, no-c-format
msgid "@RequestScoped"
msgstr "@RequestScoped"

#. Tag: literal
#: scopescontexts.xml:72
#, no-c-format
msgid "@SessionScoped"
msgstr "@SessionScoped"

#. Tag: literal
#: scopescontexts.xml:75
#, no-c-format
msgid "@ApplicationScoped"
msgstr "@ApplicationScoped"

#. Tag: literal
#: scopescontexts.xml:78
#, no-c-format
msgid "@ConversationScoped"
msgstr "@ConversationScoped"

#. Tag: para
#: scopescontexts.xml:82
#, no-c-format
msgid "For a web application that uses Web Beans:"
msgstr "Web Beans를 사용하는 웹 애플리케이션의 경우: "

#. Tag: para
#: scopescontexts.xml:86
#, no-c-format
msgid ""
"any servlet request has access to active request, session and application "
"scopes, and, additionally"
msgstr "servlet 요청은 활성 요청, 세션 및 애플리케이션 범위에 액세스합니다 "

#. Tag: para
#: scopescontexts.xml:90
#, no-c-format
msgid "any JSF request has access to an active conversation scope."
msgstr "JSF 요청은 활성 컨버세이션 범위에 액세스합니다.   "

#. Tag: para
#: scopescontexts.xml:94
#, no-c-format
msgid "The request and application scopes are also active:"
msgstr "요청 및 애플리케이션 범위도 활성화되어 있습니다: "

#. Tag: para
#: scopescontexts.xml:98
#, no-c-format
msgid "during invocations of EJB remote methods,"
msgstr "EJB 원격 방식의 호출시 "

#. Tag: para
#: scopescontexts.xml:101
#, no-c-format
msgid "during EJB timeouts,"
msgstr "EJB 시간 초과시 "

#. Tag: para
#: scopescontexts.xml:104
#, no-c-format
msgid "during message delivery to a message-driven bean, and"
msgstr "메세지 구동 빈에 메세지 전달시 "

#. Tag: para
#: scopescontexts.xml:107
#, no-c-format
msgid "during web service invocations."
msgstr "웹 서비스 호출시 "

#. Tag: para
#: scopescontexts.xml:111
#, no-c-format
msgid ""
"If the application tries to invoke a Web Bean with a scope that does not "
"have an active context, a <literal>ContextNotActiveException</literal> is "
"thrown by the Web Bean manager at runtime."
msgstr "애플리케이션이 활성 컨텍스트가 없는 범위와 함께 Web Bean을 호출하고자할 경우, 런타임시 <literal>ContextNotActiveException</literal>은 Web Bean 관리자에 의해 넘기게 됩니다.  "

#. Tag: para
#: scopescontexts.xml:115
#, no-c-format
msgid ""
"Three of the four built-in scopes should be extremely familiar to every Java "
"EE developer, so let's not waste time discussing them here. One of the "
"scopes, however, is new."
msgstr "네 개의 내장된 범위 중 세 개는 모든 Java EE 개발자에게 익숙하므로, 여기서 다루지 않겠습니다. 하지만 이 중 하나의 범위 새로운 것입니다. "

#. Tag: title
#: scopescontexts.xml:122
#, no-c-format
msgid "The conversation scope"
msgstr "컨버세이션 범위 "

#. Tag: para
#: scopescontexts.xml:124
#, no-c-format
msgid ""
"The Web Beans conversation scope is a bit like the traditional session scope "
"in that it holds state associated with a user of the system, and spans "
"multiple requests to the server. However, unlike the session scope, the "
"conversation scope:"
msgstr "Web Beans 컨버세이션 범위는 시스템 사용자와 관련된 상태를 보유하고 있는 전통 세션 범위와 유사하며, 서버에 여러 가지 요청을 보냅니다. 하지만, 세션 범위와 다르게 컨버세이션 범위는 다음과 같은 사항을 갖습니다:      "

#. Tag: para
#: scopescontexts.xml:130
#, no-c-format
msgid "is demarcated explicitly by the application, and"
msgstr "애플리케이션에 의해 명시적으로 경계를 정합니다  "

#. Tag: para
#: scopescontexts.xml:133
#, no-c-format
msgid ""
"holds state associated with a particular web browser tab in a JSF "
"application."
msgstr "JSF 애플리케이션에 있는 특정 웹 브라우저 탭과 관련한 상태를 유지합니다.  "

#. Tag: para
#: scopescontexts.xml:138
#, no-c-format
msgid ""
"A conversation represents a task, a unit of work from the point of view of "
"the user. The conversation context holds state associated with what the user "
"is currently working on. If the user is doing multiple things at the same "
"time, there are multiple conversations."
msgstr ""

#. Tag: para
#: scopescontexts.xml:143
#, no-c-format
msgid ""
"The conversation context is active during any JSF request. However, most "
"conversations are destroyed at the end of the request. If a conversation "
"should hold state across multiple requests, it must be explicitly promoted "
"to a <emphasis>long-running conversation</emphasis>."
msgstr "컨버세이션 컨텍스트는 JSF 요청 시 활성화되어 있습니다. 하지만 대부분의 컨버세이션은 요청 마지막에 삭제됩니다. 컨버세이션이 여러 가지 요청을 통해 상태를 유지해야 할 경우, <emphasis>장기 실행 컨버세이션</emphasis>으로 요청되어야 합니다. "

#. Tag: title
#: scopescontexts.xml:149
#, no-c-format
msgid "Conversation demarcation"
msgstr "컨버세이션 경계 설정 "

#. Tag: para
#: scopescontexts.xml:151
#, no-c-format
msgid ""
"Web Beans provides a built-in Web Bean for controlling the lifecyle of "
"conversations in a JSF application. This Web Bean may be obtained by "
"injection:"
msgstr "Web Beans는 JSF 애플리케이션에 있는 컨버세이션 수명 주기를 제어하기 위한 내장된 Web Bean을 제공합니다. 이러한 Web Bean은 삽입에 의해 획득될 수 있습니다:  "

#. Tag: programlisting
#: scopescontexts.xml:154
#, no-c-format
msgid "@Current Conversation conversation;"
msgstr "@Current Conversation conversation;"

#. Tag: para
#: scopescontexts.xml:156
#, no-c-format
msgid ""
"To promote the conversation associated with the current request to a long-"
"running conversation, call the <literal>begin()</literal> method from "
"application code. To schedule the current long-running conversation context "
"for destruction at the end of the current request, call <literal>end()</"
"literal>."
msgstr "장기 실행 컨버세이션으로의 최근 요청과 관련된 컨버세이션을 활성화하려면, 애플리케이션 코드에서 <literal>begin()</literal> 방식을 호출합니다. 현재 요청의 마지막에 삭제를 위해 장기 실행 컨버세이션 컨텍스트를 스케줄하려면 <literal>end()</literal>를 호출합니다.  "

#. Tag: para
#: scopescontexts.xml:161
#, no-c-format
msgid ""
"In the following example, a conversation-scoped Web Bean controls the "
"conversation with which it is associated:"
msgstr "다음의 예에서, 컨버세이션 범위 Web Bean은 관련 된 컨버세이션을 제어합니다: "

#. Tag: programlisting
#: scopescontexts.xml:164
#, no-c-format
msgid ""
"@ConversationScoped @Stateful\n"
"public class OrderBuilder {\n"
"\n"
"    private Order order;\n"
"    private @Current Conversation conversation;\n"
"    private @PersistenceContext(type=EXTENDED) EntityManager em;\n"
"    \n"
"    @Produces public Order getOrder() {\n"
"        return order;\n"
"    }\n"
"\n"
"    public Order createOrder() {\n"
"        order = new Order();\n"
"        conversation.begin();\n"
"        return order;\n"
"    }\n"
"    \n"
"    public void addLineItem(Product product, int quantity) {\n"
"        order.add( new LineItem(product, quantity) );\n"
"    }\n"
"\n"
"    public void saveOrder(Order order) {\n"
"        em.persist(order);\n"
"        conversation.end();\n"
"    }\n"
"    \n"
"    @Remove\n"
"    public void destroy() {}\n"
"    \n"
"}"
msgstr ""
"@ConversationScoped @Stateful\n"
"public class OrderBuilder {\n"
"\n"
"    private Order order;\n"
"    private @Current Conversation conversation;\n"
"    private @PersistenceContext(type=EXTENDED) EntityManager em;\n"
"    \n"
"    @Produces public Order getOrder() {\n"
"        return order;\n"
"    }\n"
"\n"
"    public Order createOrder() {\n"
"        order = new Order();\n"
"        conversation.begin();\n"
"        return order;\n"
"    }\n"
"    \n"
"    public void addLineItem(Product product, int quantity) {\n"
"        order.add( new LineItem(product, quantity) );\n"
"    }\n"
"\n"
"    public void saveOrder(Order order) {\n"
"        em.persist(order);\n"
"        conversation.end();\n"
"    }\n"
"    \n"
"    @Remove\n"
"    public void destroy() {}\n"
"    \n"
"}"

#. Tag: para
#: scopescontexts.xml:166
#, no-c-format
msgid ""
"This Web Bean is able to control its own lifecycle through use of the "
"<literal>Conversation</literal> API. But some other Web Beans have a "
"lifecycle which depends completely upon another object."
msgstr ""

#. Tag: title
#: scopescontexts.xml:173
#, no-c-format
msgid "Conversation propagation"
msgstr ""

#. Tag: para
#: scopescontexts.xml:175
#, no-c-format
msgid ""
"The conversation context automatically propagates with any JSF faces request "
"(JSF form submission). It does not automatically propagate with non-faces "
"requests, for example, navigation via a link."
msgstr ""

#. Tag: para
#: scopescontexts.xml:179
#, no-c-format
msgid ""
"We can force the conversation to propagate with a non-faces request by "
"including the unique identifier of the conversation as a request parameter. "
"The Web Beans specification reserves the request parameter named "
"<literal>cid</literal> for this use. The unique identifier of the "
"conversation may be obtained from the <literal>Conversation</literal> "
"object, which has the Web Beans name <literal>conversation</literal>."
msgstr ""

#. Tag: para
#: scopescontexts.xml:186
#, no-c-format
msgid "Therefore, the following link propagates the conversation:"
msgstr ""

#. Tag: programlisting
#: scopescontexts.xml:188
#, no-c-format
msgid ""
"<![CDATA[<a href=\"/addProduct.jsp?cid=#{conversation.id}\">Add Product</a>]]"
">"
msgstr ""
"<![CDATA[<a href=\"/addProduct.jsp?cid=#{conversation.id}\">Add Product</a>]]"
">"

#. Tag: para
#: scopescontexts.xml:190
#, no-c-format
msgid ""
"The Web Bean manager is also required to propagate conversations across any "
"redirect, even if the conversation is not marked long-running. This makes it "
"very easy to implement the common POST-then-redirect pattern, without resort "
"to fragile constructs such as a \"flash\" object. In this case, the Web Bean "
"manager automatically adds a request parameter to the redirect URL."
msgstr ""

#. Tag: title
#: scopescontexts.xml:200
#, no-c-format
msgid "Conversation timeout"
msgstr "컨버세이션 시간 초과   "

#. Tag: para
#: scopescontexts.xml:202
#, no-c-format
msgid ""
"The Web Bean manager is permitted to destroy a conversation and all state "
"held in its context at any time in order to preserve resources. A Web Bean "
"manager implementation will normally do this on the basis of some kind of "
"timeout &#151; though this is not required by the Web Beans specification. The "
"timeout is the period of inactivity before the conversation is destroyed."
msgstr ""

#. Tag: para
#: scopescontexts.xml:208
#, no-c-format
msgid ""
"The <literal>Conversation</literal> object provides a method to set the "
"timeout. This is a hint to the Web Bean manager, which is free to ignore the "
"setting."
msgstr ""

#. Tag: programlisting
#: scopescontexts.xml:212
#, no-c-format
msgid "conversation.setTimeout(timeoutInMillis);"
msgstr "conversation.setTimeout(timeoutInMillis);"

#. Tag: title
#: scopescontexts.xml:219
#, no-c-format
msgid "The dependent pseudo-scope"
msgstr ""

#. Tag: para
#: scopescontexts.xml:221
#, no-c-format
msgid ""
"In addition to the four built-in scopes, Web Beans features the so-called "
"<emphasis>dependent pseudo-scope</emphasis>. This is the default scope for a "
"Web Bean which does not explicitly declare a scope type."
msgstr ""

#. Tag: para
#: scopescontexts.xml:225
#, no-c-format
msgid "For example, this Web Bean has the scope type <literal>@Dependent</literal>:"
msgstr ""

#. Tag: programlisting
#: scopescontexts.xml:227
#, no-c-format
msgid "<![CDATA[public class Calculator { ... }]]>"
msgstr "<![CDATA[public class Calculator { ... }]]>"

#. Tag: para
#: scopescontexts.xml:229
#, no-c-format
msgid ""
"When an injection point of a Web Bean resolves to a dependent Web Bean, a "
"new instance of the dependent Web Bean is created every time the first Web "
"Bean is instantiated. Instances of dependent Web Beans are never shared "
"between different Web Beans or different injection points. They are "
"<emphasis>dependent objects</emphasis> of some other Web Bean instance."
msgstr ""

#. Tag: para
#: scopescontexts.xml:235
#, no-c-format
msgid ""
"Dependent Web Bean instances are destroyed when the instance they depend "
"upon is destroyed."
msgstr ""

#. Tag: para
#: scopescontexts.xml:243
#, no-c-format
msgid ""
"Web Beans makes it easy to obtain a dependent instance of a Java class or "
"EJB bean, even if the class or EJB bean is already declared as a Web Bean "
"with some other scope type."
msgstr ""

#. Tag: title
#: scopescontexts.xml:248
#, no-c-format
msgid "The <literal>@New</literal> annotation"
msgstr ""

#. Tag: para
#: scopescontexts.xml:250
#, no-c-format
msgid ""
"The built-in <literal>@New</literal> binding annotation allows "
"<emphasis>implicit</emphasis> definition of a dependent Web Bean at an "
"injection point. Suppose we declare the following injected field:"
msgstr ""

#. Tag: programlisting
#: scopescontexts.xml:254
#, no-c-format
msgid "<![CDATA[@New Calculator calculator;]]>"
msgstr "<![CDATA[@New Calculator calculator;]]>"

#. Tag: para
#: scopescontexts.xml:256
#, no-c-format
msgid ""
"Then a Web Bean with scope <literal>@Dependent</literal>, binding type "
"<literal>@New</literal>, API type <literal>Calculator</literal>, "
"implementation class <literal>Calculator</literal> and deployment type "
"<literal>@Standard</literal> is implicitly defined."
msgstr ""

#. Tag: para
#: scopescontexts.xml:261
#, no-c-format
msgid ""
"This is true even if <literal>Calculator</literal> is <emphasis>already</"
"emphasis> declared with a different scope type, for example:"
msgstr ""

#. Tag: programlisting
#: scopescontexts.xml:264
#, no-c-format
msgid ""
"<![CDATA[@ConversationScoped\n"
"public class Calculator { ... }]]>"
msgstr ""
"<![CDATA[@ConversationScoped\n"
"public class Calculator { ... }]]>"

#. Tag: para
#: scopescontexts.xml:266
#, no-c-format
msgid ""
"So the following injected attributes each get a different instance of "
"<literal>Calculator</literal>:"
msgstr ""

#. Tag: programlisting
#: scopescontexts.xml:269
#, no-c-format
msgid ""
"<![CDATA[public class PaymentCalc {\n"
"\n"
"    @Current Calculator calculator;\n"
"    @New Calculator newCalculator;\n"
"\n"
"}]]>"
msgstr ""
"<![CDATA[public class PaymentCalc {\n"
"\n"
"    @Current Calculator calculator;\n"
"    @New Calculator newCalculator;\n"
"\n"
"}]]>"

#. Tag: para
#: scopescontexts.xml:271
#, no-c-format
msgid ""
"The <literal>calculator</literal> field has a conversation-scoped instance "
"of <literal>Calculator</literal> injected. The <literal>newCalculator</"
"literal> field has a new instance of <literal>Calculator</literal> injected, "
"with a lifecycle that is bound to the owning <literal>PaymentCalc</literal>."
msgstr ""

#. Tag: para
#: scopescontexts.xml:276
#, no-c-format
msgid ""
"This feature is particularly useful with producer methods, as we'll see in "
"the next chapter."
msgstr ""

