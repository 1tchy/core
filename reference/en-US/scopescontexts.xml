<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.3//EN" "http://www.oasis-open.org/docbook/xml/4.3/docbookx.dtd"  [ ]>

<chapter id="scopescontexts">
  <title>Scopes and contexts</title>

<para>So far, we've seen a few examples of <emphasis>scope type annotations</emphasis>. 
The scope of a Web Bean determines the lifecycle of instances of the Web Bean. The 
scope also determines which clients refer to which instances of the Web Bean. 
According to the Web Beans specification, a scope determines:</para>

<blockquote>
<itemizedlist>
  <listitem>
    <para>When a new instance of any Web Bean with that scope is created</para>
  </listitem>
  <listitem>
    <para>When an existing instance of any Web Bean with that scope is destroyed</para>
  </listitem>
  <listitem>
    <para>Which injected references refer to any instance of a Web Bean with that scope</para>
  </listitem>
</itemizedlist>
</blockquote>

<para>For example, if we have a session scoped Web Bean, <literal>CurrentUser</literal>, 
all Web Beans that are called in the context of the same <literal>HttpSession</literal> 
will see the same instance of <literal>CurrentUser</literal>. This instance will be 
automatically created the first time a <literal>CurrentUser</literal> is needed in that 
session, and automatically destroyed when the session ends.</para>

<section>
  <title>Scope types</title>

<para>Web Beans features an <emphasis>extensible context model</emphasis>. It is possible 
to define new scopes by creating a new scope type annotation:</para>

<programlisting role="JAVA"><![CDATA[@Retention(RUNTIME)
@Target({TYPE, METHOD})
@ScopeType
public @interface ClusterScoped {}]]></programlisting>

<para>Of course, that's the easy part of the job. For this scope type to be useful, we 
will also need to define a <literal>Context</literal> object that implements the scope! 
Implementing a <literal>Context</literal> is usually a very technical task, intended for 
framework development only.</para>

<para>We can apply a scope type annotation to a Web Bean implementation class to specify 
the scope of the Web Bean:</para>

<programlisting role="JAVA"><![CDATA[@ClusterScoped
public class SecondLevelCache { ... }]]></programlisting>

<!--  

<para>We can even use the scope type to obtain an instance of the <literal>Context</literal> 
object for the scope:</para>

<programlisting><![CDATA[Bean<SecondLevelCache> cacheBean = manager.resolveByType(SecondLevelCache.class);
SecondLevelCache cache = manager.getContext(ClusterScoped.class).get(cacheBean);]]></programlisting>

-->

<para>Usually, you'll use one of Web Beans' built-in scopes.</para>

</section>

<section>
  <title>Built-in scopes</title>

<para>Web Beans defines four built-in scopes:</para>

<itemizedlist>
  <listitem>
    <para><literal>@RequestScoped</literal></para>
  </listitem>
  <listitem>
    <para><literal>@SessionScoped</literal></para>
  </listitem>
  <listitem>
    <para><literal>@ApplicationScoped</literal></para>
  </listitem>
  <listitem>
    <para><literal>@ConversationScoped</literal></para>
  </listitem>
</itemizedlist>

<para>For a web application that uses Web Beans:</para>

<itemizedlist>
  <listitem>
    <para>any servlet request has access to active request, session and application 
    scopes, and, additionally</para>
  </listitem>
  <listitem>
    <para>any JSF request has access to an active conversation scope.</para>
  </listitem>
</itemizedlist>

<para>The request and application scopes are also active:</para>

<itemizedlist>
  <listitem>
    <para>during invocations of EJB remote methods,</para>
  </listitem>
  <listitem>
    <para>during EJB timeouts,</para>
  </listitem>
  <listitem>
    <para>during message delivery to a message-driven bean, and</para>
  </listitem>
  <listitem>
    <para>during web service invocations.</para>
  </listitem>
</itemizedlist>

<para>If the application tries to invoke a Web Bean with a scope that does not have 
an active context, a <literal>ContextNotActiveException</literal> is thrown by the 
Web Bean manager at runtime.</para>

<para>Three of the four built-in scopes should be extremely familiar to every Java EE
developer, so let's not waste time discussing them here. One of the scopes, however,
is new.</para>

</section>

<section>
  <title>The conversation scope</title>
  
  <para>The Web Beans conversation scope is a bit like the traditional session scope
  in that it holds state associated with a user of the system, and spans multiple
  requests to the server. However, unlike the session scope, the conversation scope:</para>
  
  <itemizedlist>
    <listitem>
      <para>is demarcated explicitly by the application, and</para>
    </listitem>
    <listitem>
      <para>holds state associated with a particular web browser tab in a JSF 
      application.</para>
    </listitem>
  </itemizedlist>
  
  <para>A conversation represents a task, a unit of work from the point of view
  of the user. The conversation context holds state associated with what the user
  is currently working on. If the user is doing multiple things at the same time,
  there are multiple conversations.</para>
  
  <para>The conversation context is active during any JSF request. However, most
  conversations are destroyed at the end of the request. If a conversation should
  hold state across multiple requests, it must be explicitly promoted to a
  <emphasis>long-running conversation</emphasis>.</para>
  
  <section>
    <title>Conversation demarcation</title>
  
  <para>Web Beans provides a built-in Web Bean for controlling the lifecyle of
  conversations in a JSF application. This Web Bean may be obtained by injection:</para>
  
  <programlisting role="JAVA">@Current Conversation conversation;</programlisting>
  
  <para>To promote the conversation associated with the current request to a 
  long-running conversation, call the <literal>begin()</literal> method from
  application code. To schedule the current long-running conversation context 
  for destruction at the end of the current request, call <literal>end()</literal>.</para>

  <para>In the following example, a conversation-scoped Web Bean controls the
  conversation with which it is associated:</para>
  
<programlisting role="JAVA">@ConversationScoped @Stateful
public class OrderBuilder {

    private Order order;
    private @Current Conversation conversation;
    private @PersistenceContext(type=EXTENDED) EntityManager em;
    
    @Produces public Order getOrder() {
        return order;
    }

    public Order createOrder() {
        order = new Order();
        conversation.begin();
        return order;
    }
    
    public void addLineItem(Product product, int quantity) {
        order.add( new LineItem(product, quantity) );
    }

    public void saveOrder(Order order) {
        em.persist(order);
        conversation.end();
    }
    
    @Remove
    public void destroy() {}
    
}</programlisting>

  <para>This Web Bean is able to control its own lifecycle through use of the
  <literal>Conversation</literal> API. But some other Web Beans have a lifecycle
  which depends completely upon another object.</para>

  </section>
  
  <section>
    <title>Conversation propagation</title>
    
    <para>The conversation context automatically propagates with any JSF faces 
    request (JSF form submission). It does not automatically propagate with 
    non-faces requests, for example, navigation via a link.</para>
    
    <para>We can force the conversation to propagate with a non-faces request
    by including the unique identifier of the conversation as a request 
    parameter. The Web Beans specification reserves the request parameter named
    <literal>cid</literal> for this use. The unique identifier of the conversation
    may be obtained from the <literal>Conversation</literal> object, which has
    the Web Beans name <literal>conversation</literal>.</para>
    
    <para>Therefore, the following link propagates the conversation:</para>
    
    <programlisting role="HTML"><![CDATA[<a href="/addProduct.jsp?cid=#{conversation.id}">Add Product</a>]]></programlisting>
    
    <para>The Web Bean manager is also required to propagate conversations
    across any redirect, even if the conversation is not marked long-running.
    This makes it very easy to implement the common POST-then-redirect pattern,
    without resort to fragile constructs such as a "flash" object. In this case,
    the Web Bean manager automatically adds a request parameter to the redirect
    URL.</para>
        
  </section>
  
  <section>
    <title>Conversation timeout</title>
    
    <para>The Web Bean manager is permitted to destroy a conversation and all state
    held in its context at any time in order to preserve resources. A Web Bean 
    manager implementation will normally do this on the basis of some kind of 
    timeout &#151; though this is not required by the Web Beans specification.
    The timeout is the period of inactivity before the conversation is destroyed.</para>
    
    <para>The <literal>Conversation</literal> object provides a method to set
    the timeout. This is a hint to the Web Bean manager, which is free to ignore
    the setting.</para>
    
    <programlisting role="JAVA">conversation.setTimeout(timeoutInMillis);</programlisting>
    
  </section>
  
  <section id="wicketContexts">
  <title>Conversations using Wicket</title>
  <para>The conversation scope can also be used in WebBeans with the Apache Wicket web framework, through the 
  <literal>webbeans-wicket</literal> module.  This module takes care of:
  <itemizedlist>
  <listitem><para>Setting up the conversation context at the beginning of a wicket request, and tearing it down afterwards</para></listitem> 
  <listitem><para>Storing the id of any long-running conversation in Wicket's WebPage metadata when the page response is complete</para></listitem>
  <listitem><para>Activating the correct long-running conversation based upon which page is being accessed</para></listitem>
  <listitem><para>Propagating the conversation context for any long-running conversation to new pages</para></listitem>
  </itemizedlist>  </para>
  <section>
  <title>Starting and stopping conversations in Wicket</title>
  <para>As in WebBeans JSF applications, a conversation <emphasis>always</emphasis> exists for any request, but its lifetime is only that of the current request unless it is marked as 
  <emphasis>long-running</emphasis>.  For Wicket applications this is accomplished exactly as in JSF applications, by injecting the <literal>@Current Conversation</literal> and then 
  invoking <literal>conversation.begin()</literal>.  Likewise, conversations are ended with <literal>conversation.end()</literal>
  </para>
  </section>
  
  <section>
  <title>Long running conversation propagation in Wicket</title>
  <para>
  When a conversation is marked as long-running, the id of that conversation will be stored in Wicket's WebPage metadata for the current page.
  In addition, if a new page is created and set as the response target through <literal>setResponsePage</literal>, this new page will also participate
  in this conversation.  This occurs for both directly instantiated pages, i.e. <literal>setResponsePage(new OtherPage())</literal> as well as for 
  bookmarkable pages created with <literal>setResponsePage(OtherPage.class)</literal> where <literal>OtherPage.class</literal> is mounted as bookmarkable
  from your <literal>WebApplication</literal> subclass (or through annotations.)  In the latter case, because the new page instance is not created until after
  a redirect, the conversation id will be propagated through a request parameter, and then stored in page metadata after the redirect.
  </para>
  </section>
  <section>
  <title>The Wicket Conversations Example</title>
  <para>In <literal>examples/wicket/conversations</literal> there is an example application for using conversations from Wicket.  To setup and run the 
  application, follow the examples in <xref linkend="numberguessWicket"/>.  If running within eclipse, the application is available at <literal>http://localhost:8080</literal>,
  and if running within an external container, the app is available at <literal>http://localhost:8080/webbeans-conversations-wicket</literal>.
  </para>
  <section>
  <title>Using the application</title>
  <para>The <emphasis>conversations</emphasis> application is simply an interface to begin and end conversations, switch between them, and store a single piece of data in each.
  The interface looks like the following:
     <mediaobject>
    <imageobject>
    <imagedata fileref="images/wicket-conversations-snap.png" format="PNG"/> 
    </imageobject>
   </mediaobject></para>
   <para>
  The menu at the top will show the list of long-running conversations, along with data about each,
  as well as the active conversation (even if it is not long running.)  The currently selected item
  of this menu is the current conversation for the last request that was processed.  Changing this menu
  changes the current conversation.  The "Data in conversation" text box and the submit
  button labeled "Change Value" allow you to change a piece of string data associated 
  with the conversation.  The "begin" button marks the conversation as long running.
  The "noop" button submits the form without changing the state of the conversation.
  The "end" button ends the current conversation.  The "longop" button
  executes a method that takes a few seconds, which can be used to play with conversation timeouts and
  synchronization/locking.  The "Abandon" link redirects to the HomePage without propagating
  the conversation, thus starting a new temporary conversation.  The conversation that has been abandoned
  can be rejoined by selecting it in the popup.</para>
  </section>
  <section>
  <title>Understanding the code</title>
  <para>As in <xref linkend="numberguessWicket"/>, there is boilerplate code in the
  SampleApplication, as well as in web.xml, to ensure correct integration of Wicket and Webbeans.
  Other pieces of this application include:</para>
  <itemizedlist>
  <listitem><para>The <literal>Conversations</literal> class exists to allow configuration of the conversation
  timeout for the current session<programlisting><![CDATA[@Produces
@ConversationInactivityTimeout
@Example
public static long getConversationTimeoutInMilliseconds()
{
   return 600000;
}]]></programlisting>The <literal>Example</literal> deployment type is used to illustrate
custom deployment types.  It is defined in Example.java:<programlisting><![CDATA[@Target( { TYPE, METHOD, FIELD })
@Retention(RUNTIME)
@Documented
@DeploymentType
public @interface Example
{
}]]></programlisting> and is activated in <literal>WEB-INF/beans.xml</literal>:
<programlisting><![CDATA[<Beans xmlns="urn:java:ee" xmlns:conversations="urn:java:org.jboss.webbeans.examples.conversations">
    <Deploy>
        <Standard />
        <Production />
        <conversations:Example />
    </Deploy>
</Beans>]]></programlisting></para></listitem>
<listitem><para>The <literal>Data</literal> class is our conversational component that stores a
single string:<programlisting><![CDATA[@ConversationScoped
@Named
public class Data implements Serializable
{
    private String data;

    public String getData()
    {
        return data;
    }
    
    public void setData(String data)
    {
        this.data = data;
    }
}]]></programlisting></para></listitem>
<listitem><para>The <literal>HomePage</literal> class is where
the brunt of the work takes place.  It injects the WebBeans-provided <literal>ConversationManager</literal>
component in order to access the list of long-running conversations, injects the current <literal>Conversation</literal>
in order to allow control over whether that conversation is long-running, and injects the <literal>Data</literal>
component to allow its manipulation by the textfield:<programlisting><![CDATA[/**
* These are injections for displaying information about existing conversations to the user
*/
@Current ConversationManager conversationManager;
@Current Conversation currentConversation;
 
/**
* This is our conversational data component, to illustrate how data is used in conversations and
* exists per-conversation.
*/
@Current Data data;
]]></programlisting>The data component is referenced by the wicket TextField using a 
<literal>PropertyModel</literal>:<programlisting><![CDATA[form.add(new TextField("dataField", new PropertyModel(this, "data.data")));]]></programlisting>
This means that for each page, the text field is referring to the "data" property of the "Data" bean that is specific to 
the conversation that is active for the request, whether that be a transient conversation that is created for the request 
or a long-running conversation associated with the page.  If one types data into the text field 
and clicks <literal>Change Value</literal>
when a long-running conversation is not started, and then clicks <literal>noop</literal>, the
value in the text field disappears, because it was associated with a transient conversation, and 
upon redirect, the new conversation had a different Data object, which had the default (empty) value.</para>
<para>As you can see by the other code in this example, conversations are started and ended programmatically, 
and no WebBeans-specific code is necessary to propagate the conversation.  The only exception to this
is in the code to <emphasis>switch</emphasis> conversations, which is not a typical operation in real scenarios.
In this case, a conversation id (<literal>cid</literal>) request parameter is passed to the <literal>setResponsePage</literal>
invocation, and this explicit conversation id will override the id that the wicket/webbeans integration
code would normally generate in order to propagate the current conversation, and hence the specified
conversation will be active upon redirect.</para>
</listitem>
</itemizedlist>
  
</section>
</section>
</section>
</section>
<section>
  <title>The dependent pseudo-scope</title>

  <para>In addition to the four built-in scopes, Web Beans features the so-called 
  <emphasis>dependent pseudo-scope</emphasis>. This is the default scope for a Web Bean
  which does not explicitly declare a scope type.</para>

  <para>For example, this Web Bean has the scope type <literal>@Dependent</literal>:</para>

<programlisting role="JAVA"><![CDATA[public class Calculator { ... }]]></programlisting>

  <para>When an injection point of a Web Bean resolves to a dependent Web Bean,
  a new instance of the dependent Web Bean is created every time the first
  Web Bean is instantiated. Instances of dependent Web Beans are never shared
  between different Web Beans or different injection points. They are
  <emphasis>dependent objects</emphasis> of some other Web Bean instance.</para>
  
  <para>Dependent Web Bean instances are destroyed when the instance they
  depend upon is destroyed.</para>
  
  <!--  
  <para>Different clients always see different instances of a dependent Web Bean, no 
  matter what context they execute in.</para>
  -->
  
  <para>Web Beans makes it easy to obtain a dependent instance of a Java class
  or EJB bean, even if the class or EJB bean is already declared as a Web Bean
  with some other scope type.</para>

<section>
  <title>The <literal>@New</literal> annotation</title>

<para>The built-in <literal>@New</literal> binding annotation allows 
<emphasis>implicit</emphasis> definition of a dependent Web Bean at an injection point. 
Suppose we declare the following injected field:</para>

<programlisting role="JAVA"><![CDATA[@New Calculator calculator;]]></programlisting>

<para>Then a Web Bean with scope <literal>@Dependent</literal>, binding type 
<literal>@New</literal>, API type <literal>Calculator</literal>, implementation class 
<literal>Calculator</literal> and deployment type <literal>@Standard</literal> is 
implicitly defined.</para>

<para>This is true even if <literal>Calculator</literal> is <emphasis>already</emphasis> 
declared with a different scope type, for example:</para>

<programlisting role="JAVA"><![CDATA[@ConversationScoped
public class Calculator { ... }]]></programlisting>

<para>So the following injected attributes each get a different instance of 
<literal>Calculator</literal>:</para>

<programlisting role="JAVA"><![CDATA[public class PaymentCalc {

    @Current Calculator calculator;
    @New Calculator newCalculator;

}]]></programlisting>

<para>The <literal>calculator</literal> field has a conversation-scoped instance 
of <literal>Calculator</literal> injected. The <literal>newCalculator</literal> 
field has a new instance of <literal>Calculator</literal> injected, with a lifecycle 
that is bound to the owning <literal>PaymentCalc</literal>.</para>

<para>This feature is particularly useful with producer methods, as we'll see in
the next chapter.</para>

</section>

</section>

</chapter>