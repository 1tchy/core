<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.3//EN" "http://www.oasis-open.org/docbook/xml/4.3/docbookx.dtd"  [ ]>

<chapter id="scopescontexts">
  <title>Scopes and contexts</title>

<para>So far, we've seen a few examples of <emphasis>scope type annotations</emphasis>. 
The scope of a Web Bean determines the lifecycle of instances of the Web Bean. The 
scope also determines which clients refer to which instances of the Web Bean. 
According to the Web Beans specification, a scope determines:</para>

<blockquote>
<itemizedlist>
  <listitem>
    <para>When a new instance of any Web Bean with that scope is created</para>
  </listitem>
  <listitem>
    <para>When an existing instance of any Web Bean with that scope is destroyed</para>
  </listitem>
  <listitem>
    <para>Which injected references refer to any instance of a Web Bean with that scope</para>
  </listitem>
</itemizedlist>
</blockquote>

<para>For example, if we have a session scoped Web Bean, <literal>CurrentUser</literal>, 
all Web Beans that are called in the context of the same <literal>HttpSession</literal> 
will see the same instance of <literal>CurrentUser</literal>. This instance will be 
automatically created the first time a <literal>CurrentUser</literal> is needed in that 
session, and automatically destroyed when the session ends.</para>

<section>
  <title>Scope types</title>

<para>Web Beans features an <emphasis>extensible context model</emphasis>. It is possible 
to define new scopes by creating a new scope type annotation:</para>

<programlisting role="JAVA"><![CDATA[@Retention(RUNTIME)
@Target({TYPE, METHOD})
@ScopeType
public @interface ClusterScoped {}]]></programlisting>

<para>Of course, that's the easy part of the job. For this scope type to be useful, we 
will also need to define a <literal>Context</literal> object that implements the scope! 
Implementing a <literal>Context</literal> is usually a very technical task, intended for 
framework development only.</para>

<para>We can apply a scope type annotation to a Web Bean implementation class to specify 
the scope of the Web Bean:</para>

<programlisting role="JAVA"><![CDATA[@ClusterScoped
public class SecondLevelCache { ... }]]></programlisting>

<!--  

<para>We can even use the scope type to obtain an instance of the <literal>Context</literal> 
object for the scope:</para>

<programlisting><![CDATA[Bean<SecondLevelCache> cacheBean = manager.resolveByType(SecondLevelCache.class);
SecondLevelCache cache = manager.getContext(ClusterScoped.class).get(cacheBean);]]></programlisting>

-->

<para>Usually, you'll use one of Web Beans' built-in scopes.</para>

</section>

<section>
  <title>Built-in scopes</title>

<para>Web Beans defines four built-in scopes:</para>

<itemizedlist>
  <listitem>
    <para><literal>@RequestScoped</literal></para>
  </listitem>
  <listitem>
    <para><literal>@SessionScoped</literal></para>
  </listitem>
  <listitem>
    <para><literal>@ApplicationScoped</literal></para>
  </listitem>
  <listitem>
    <para><literal>@ConversationScoped</literal></para>
  </listitem>
</itemizedlist>

<para>For a web application that uses Web Beans:</para>

<itemizedlist>
  <listitem>
    <para>any servlet request has access to active request, session and application 
    scopes, and, additionally</para>
  </listitem>
  <listitem>
    <para>any JSF request has access to an active conversation scope.</para>
  </listitem>
</itemizedlist>

<para>The request and application scopes are also active:</para>

<itemizedlist>
  <listitem>
    <para>during invocations of EJB remote methods,</para>
  </listitem>
  <listitem>
    <para>during EJB timeouts,</para>
  </listitem>
  <listitem>
    <para>during message delivery to a message-driven bean, and</para>
  </listitem>
  <listitem>
    <para>during web service invocations.</para>
  </listitem>
</itemizedlist>

<para>If the application tries to invoke a Web Bean with a scope that does not have 
an active context, a <literal>ContextNotActiveException</literal> is thrown by the 
Web Bean manager at runtime.</para>

<para>Three of the four built-in scopes should be extremely familiar to every Java EE
developer, so let's not waste time discussing them here. One of the scopes, however,
is new.</para>

</section>

<section>
  <title>The conversation scope</title>
  
  <para>The Web Beans conversation scope is a bit like the traditional session scope
  in that it holds state associated with a user of the system, and spans multiple
  requests to the server. However, unlike the session scope, the conversation scope:</para>
  
  <itemizedlist>
    <listitem>
      <para>is demarcated explicitly by the application, and</para>
    </listitem>
    <listitem>
      <para>holds state associated with a particular web browser tab in a JSF 
      application.</para>
    </listitem>
  </itemizedlist>
  
  <para>A conversation represents a task, a unit of work from the point of view
  of the user. The conversation context holds state associated with what the user
  is currently working on. If the user is doing multiple things at the same time,
  there are multiple conversations.</para>
  
  <para>The conversation context is active during any JSF request. However, most
  conversations are destroyed at the end of the request. If a conversation should
  hold state across multiple requests, it must be explicitly promoted to a
  <emphasis>long-running conversation</emphasis>.</para>
  
  <section>
    <title>Conversation demarcation</title>
  
  <para>Web Beans provides a built-in Web Bean for controlling the lifecyle of
  conversations in a JSF application. This Web Bean may be obtained by injection:</para>
  
  <programlisting role="JAVA">@Current Conversation conversation;</programlisting>
  
  <para>To promote the conversation associated with the current request to a 
  long-running conversation, call the <literal>begin()</literal> method from
  application code. To schedule the current long-running conversation context 
  for destruction at the end of the current request, call <literal>end()</literal>.</para>

  <para>In the following example, a conversation-scoped Web Bean controls the
  conversation with which it is associated:</para>
  
<programlisting role="JAVA">@ConversationScoped @Stateful
public class OrderBuilder {

    private Order order;
    private @Current Conversation conversation;
    private @PersistenceContext(type=EXTENDED) EntityManager em;
    
    @Produces public Order getOrder() {
        return order;
    }

    public Order createOrder() {
        order = new Order();
        conversation.begin();
        return order;
    }
    
    public void addLineItem(Product product, int quantity) {
        order.add( new LineItem(product, quantity) );
    }

    public void saveOrder(Order order) {
        em.persist(order);
        conversation.end();
    }
    
    @Remove
    public void destroy() {}
    
}</programlisting>

  <para>This Web Bean is able to control its own lifecycle through use of the
  <literal>Conversation</literal> API. But some other Web Beans have a lifecycle
  which depends completely upon another object.</para>

  </section>
  
  <section>
    <title>Conversation propagation</title>
    
    <para>The conversation context automatically propagates with any JSF faces 
    request (JSF form submission). It does not automatically propagate with 
    non-faces requests, for example, navigation via a link.</para>
    
    <para>We can force the conversation to propagate with a non-faces request
    by including the unique identifier of the conversation as a request 
    parameter. The Web Beans specification reserves the request parameter named
    <literal>cid</literal> for this use. The unique identifier of the conversation
    may be obtained from the <literal>Conversation</literal> object, which has
    the Web Beans name <literal>conversation</literal>.</para>
    
    <para>Therefore, the following link propagates the conversation:</para>
    
    <programlisting role="HTML"><![CDATA[<a href="/addProduct.jsp?cid=#{conversation.id}">Add Product</a>]]></programlisting>
    
    <para>The Web Bean manager is also required to propagate conversations
    across any redirect, even if the conversation is not marked long-running.
    This makes it very easy to implement the common POST-then-redirect pattern,
    without resort to fragile constructs such as a "flash" object. In this case,
    the Web Bean manager automatically adds a request parameter to the redirect
    URL.</para>
        
  </section>
  
  <section>
    <title>Conversation timeout</title>
    
    <para>The Web Bean manager is permitted to destroy a conversation and all state
    held in its context at any time in order to preserve resources. A Web Bean 
    manager implementation will normally do this on the basis of some kind of 
    timeout &#151; though this is not required by the Web Beans specification.
    The timeout is the period of inactivity before the conversation is destroyed.</para>
    
    <para>The <literal>Conversation</literal> object provides a method to set
    the timeout. This is a hint to the Web Bean manager, which is free to ignore
    the setting.</para>
    
    <programlisting role="JAVA">conversation.setTimeout(timeoutInMillis);</programlisting>
    
  </section>
  
</section>

<section>
  <title>The dependent pseudo-scope</title>

  <para>In addition to the four built-in scopes, Web Beans features the so-called 
  <emphasis>dependent pseudo-scope</emphasis>. This is the default scope for a Web Bean
  which does not explicitly declare a scope type.</para>

  <para>For example, this Web Bean has the scope type <literal>@Dependent</literal>:</para>

<programlisting role="JAVA"><![CDATA[public class Calculator { ... }]]></programlisting>

  <para>When an injection point of a Web Bean resolves to a dependent Web Bean,
  a new instance of the dependent Web Bean is created every time the first
  Web Bean is instantiated. Instances of dependent Web Beans are never shared
  between different Web Beans or different injection points. They are
  <emphasis>dependent objects</emphasis> of some other Web Bean instance.</para>
  
  <para>Dependent Web Bean instances are destroyed when the instance they
  depend upon is destroyed.</para>
  
  <!--  
  <para>Different clients always see different instances of a dependent Web Bean, no 
  matter what context they execute in.</para>
  -->
  
  <para>Web Beans makes it easy to obtain a dependent instance of a Java class
  or EJB bean, even if the class or EJB bean is already declared as a Web Bean
  with some other scope type.</para>

<section>
  <title>The <literal>@New</literal> annotation</title>

<para>The built-in <literal>@New</literal> binding annotation allows 
<emphasis>implicit</emphasis> definition of a dependent Web Bean at an injection point. 
Suppose we declare the following injected field:</para>

<programlisting role="JAVA"><![CDATA[@New Calculator calculator;]]></programlisting>

<para>Then a Web Bean with scope <literal>@Dependent</literal>, binding type 
<literal>@New</literal>, API type <literal>Calculator</literal>, implementation class 
<literal>Calculator</literal> and deployment type <literal>@Standard</literal> is 
implicitly defined.</para>

<para>This is true even if <literal>Calculator</literal> is <emphasis>already</emphasis> 
declared with a different scope type, for example:</para>

<programlisting role="JAVA"><![CDATA[@ConversationScoped
public class Calculator { ... }]]></programlisting>

<para>So the following injected attributes each get a different instance of 
<literal>Calculator</literal>:</para>

<programlisting role="JAVA"><![CDATA[public class PaymentCalc {

    @Current Calculator calculator;
    @New Calculator newCalculator;

}]]></programlisting>

<para>The <literal>calculator</literal> field has a conversation-scoped instance 
of <literal>Calculator</literal> injected. The <literal>newCalculator</literal> 
field has a new instance of <literal>Calculator</literal> injected, with a lifecycle 
that is bound to the owning <literal>PaymentCalc</literal>.</para>

<para>This feature is particularly useful with producer methods, as we'll see in
the next chapter.</para>

</section>

</section>

</chapter>