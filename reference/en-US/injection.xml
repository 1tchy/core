<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.3//EN"
   "http://www.oasis-open.org/docbook/xml/4.3/docbookx.dtd"  [ ]>
<chapter id="injection">
   <title>Dependency injection and programmatic lookup</title>

   <para>
      One of the most significant features of CDI, certainly the most recognized, is dependency injection. But not just
      dependency injection; type-safe dependency injection. In this chapter, you'll learn how CDI is able to leverage
      the Java type system and annotations to build a dependency injection strategy that is both strongly typed and
      keeps the implementation hidden from the client.
   </para>

   <section>
      <title>Where you can @Inject</title>

      <para>
         Injections are declared using the JSR-330 annotation, <literal>@Inject</literal>, along with an optional set of
         qualifiers annotations. CDI supports three primary mechanisms for dependency injection during bean
         construction:
      </para>
      
      <para>
         <emphasis>Bean constructor</emphasis> parameter injection:
      </para>

      <programlisting role="JAVA"><![CDATA[public class Checkout {
        
   private final ShoppingCart cart;
    
   @Inject
   public Checkout(ShoppingCart cart) {
      this.cart = cart;
   }

}]]></programlisting>

      <note>
         <para>
            A bean can only have one injectable constructor.
         </para>
      </note>

      <para>
         <emphasis>Initializer</emphasis> method parameter injection:
      </para>

      <programlisting role="JAVA"><![CDATA[public class Checkout {
        
   private ShoppingCart cart;

   @Inject
   void setShoppingCart(ShoppingCart cart) {
      this.cart = cart;
   }
    
}]]></programlisting>

      <note>
         <para>
            A bean can have multiple initializer methods. If the bean is a session bean, the initializer method is not
            required to be a business method of the session bean.
         </para>
      </note>

      <para>
         And direct field injection:
      </para>

      <programlisting role="JAVA"><![CDATA[public class Checkout {

   private @Inject ShoppingCart cart;
    
}]]></programlisting>

      <note>
         <para>
            Getter and setter methods are not required for field injection to work (unlike with JSF managed beans).
         </para>
      </note>

      <para>
         Dependency injection always occurs when the bean instance is first instantiated by the container.
      </para>

      <itemizedlist>
         <listitem>
            <para>
               First, the container calls the bean constructor (the default constructor or the one annotated @Inject), to
               obtain an instance of the bean.
            </para>
         </listitem>
         <listitem>
            <para>
               Next, the container initializes the values of all injected fields of the bean.
            </para>
         </listitem>
         <listitem>
            <para>
               Next, the container calls all initializer methods of bean (the call order is not portable, don't rely on
               it).
            </para>
         </listitem>
         <listitem>
            <para>
               Finally, the <literal>@PostConstruct</literal> method of the bean is called, if defined.
            </para>
         </listitem>
      </itemizedlist>

      <tip>
         <para>
            One major advantage of using constructor injection is that the bean can be made immutable.
         </para>
      </tip>

      <para>
         Bean constructors, initializer methods and injected fields must be annotated <emphasis>@Inject</emphasis>. The
         parameters of bean constructors and initializers are injection points, which means the container will search out
         beans matching the bean type and qualifier and pass them in as arguments.         
      </para>

      <para>
         If a parameter of bean constructors and initializer methods is not explicitly annotated with a qualifier, the
         default qualifier, <literal>@Default</literal>, is applied. The same is goes for an injected field.
      </para>

      <para>
         CDI also supports parameter injection on methods that are invoked by the container. For instance, parameter
         injection is supported for producer methods:
      </para>

      <programlisting role="JAVA"><![CDATA[@Produces Checkout createCheckout(ShoppingCart cart) {
    return new Checkout(cart);
}]]></programlisting>

      <para>
        This is one of the cases where the <literal>@Inject</literal> annotation <emphasis>is not</emphasis> required at
        an injection point. Other cases include observer methods (which we'll meet in <xref linkend="events"/>) and
        disposal methods, which also support parameter injection.
      </para>
   </section>

   <section>
      <title>What gets injected</title>

      <para>
         The CDI specification defines a procedure, called the <emphasis>typesafe resolution algorithm</emphasis>, that
         the container follows when identifying the bean to inject to an injection point.  This algorithm looks complex
         at first, but once you understand it, it's really quite intuitive. Typesafe resolution is performed at system
         initialization time, which means that the container will inform the developer immediately if a bean's
         dependencies cannot be satisfied, by throwing a <literal>UnsatisfiedDependencyException</literal> or
         <literal>AmbiguousDependencyException</literal>.
      </para>

      <para>
         The purpose of this algorithm is to allow multiple beans to implement the same bean type and either:
      </para>

      <itemizedlist>
         <listitem>
            <para>
               allow the client to select which implementation it requires using <emphasis>qualifier</emphasis> or
            </para>
        </listitem>
        <listitem>
            <para>
               allow the application deployer to select which implementation is appropriate for a particular deployment,
               without changes to the client, by enabling or disabling an <emphasis>alternative</emphasis>, or
            </para>
        </listitem>
      </itemizedlist>

      <para>
         Obviously, if you have exactly one bean of a given type, and an injection point with that same type, then bean A is
         going to go into slot A. That's the simplest possible scenario. When you first start your application, you'll
         likely have lots of those.
      </para>
      
      <para>
         But then, things start to get complicated. Let's explore how the container determines which bean to inject in
         those not-so-obvious cases by taking a look at qualifiers and how they help your beans fit into the right
         picture.
      </para>

   </section>

   <section>
      <title>Qualifier annotations</title>

      <para>
         If we have more than one bean that implements a particular bean type, the injection point can specify exactly
         which bean should be injected using a qualifier annotation. For example, there might be two implementations of
         <literal>PaymentProcessor</literal>:
      </para>

      <programlisting role="JAVA"><![CDATA[@Synchronous
public class SynchronousPaymentProcessor implements PaymentProcessor {
   public void process(Payment payment) { ... }
}]]></programlisting>      

      <programlisting role="JAVA"><![CDATA[@Asynchronous
public class AsynchronousPaymentProcessor implements PaymentProcessor {
   public void process(Payment payment) { ... }
}]]></programlisting>

      <para>
         Where <literal>@Synchronous</literal> and <literal>@Asynchronous</literal> are qualifier annotations:
      </para>

      <programlisting role="JAVA"><![CDATA[@Qualifier
@Retention(RUNTIME)
@Target({TYPE, METHOD, FIELD, PARAMETER})
public @interface Synchronous {}]]></programlisting>

<programlisting role="JAVA"><![CDATA[@Qualifier
@Retention(RUNTIME)
@Target({TYPE, METHOD, FIELD, PARAMETER})
public @interface Asynchronous {}]]></programlisting>

      <para>
         A client bean developer uses the qualifier annotation to specify exactly which bean should be injected.
      </para>

      <para>Using field injection:</para>

      <programlisting role="JAVA"><![CDATA[@Inject @Synchronous PaymentProcessor syncPaymentProcessor;
@Inject @Asynchronous PaymentProcessor asyncPaymentProcessor;]]></programlisting>

      <para>Using initializer method injection:</para>

      <programlisting role="JAVA"><![CDATA[@Inject
public void setPaymentProcessors(@Synchronous PaymentProcessor syncPaymentProcessor, 
                                 @Asynchronous PaymentProcessor asyncPaymentProcessor) {
   this.syncPaymentProcessor = syncPaymentProcessor;
   this.asyncPaymentProcessor = asyncPaymentProcessor;
}]]></programlisting>

      <para>Using using constructor injection:</para>

     <programlisting role="JAVA"><![CDATA[@Inject
public Checkout(@Synchronous PaymentProcessor syncPaymentProcessor, 
                @Asynchronous PaymentProcessor asyncPaymentProcessor) {
   this.syncPaymentProcessor = syncPaymentProcessor;
   this.asyncPaymentProcessor = asyncPaymentProcessor;
}]]></programlisting>

      <para>
         Qualifier annotations can also qualify method arguments of producer, disposer and observer methods. Combining
         qualified arguments with producer methods is a good way to have an implementation of a bean type at runtime
         selected at runtime based on the state of the system:
      </para>

      <programlisting role="JAVA"><![CDATA[@Produces
PaymentProcessor getPaymentProcessor(@Synchronous PaymentProcessor syncPaymentProcessor,
                                     @Asynchronous PaymentProcessor asyncPaymentProcessor) {
   return isSynchronous() ? syncPaymentProcessor : asyncPaymentProcessor;
}]]></programlisting> 
   
      <para>
         Now, you may be thinking, <emphasis>"What's the different between using a qualifier and just specifying the
         exact implementation class you want?"</emphasis> It's important to understand that a qualifier is like an
         extension of the interface. You could potentially implement the asynchronous payment processor differently over
         the age of the application. However, if you use qualifier annotations to hook injection points with the bean
         implementing that functionality, the server implementation can vary without affecting the client code.  Plus,
         you get all the benefits of using the bean's interface because you don't have a hard dependency on the
         implementation.
      </para>

      <para>
         Qualifiers will likely replace use of the factory pattern as well. The container becomes your factory and
         the switch between implementations is dictated by the qualifier.
      </para>

      <section>
         <title>Qualifiers with members</title>

         <para>
            Annotations can have members (i.e., fields) just like regular classes. You can use these fields to furthur
            discriminate the qualifier. This simply prevents an explosion of annotations that you have to introduce.
            For instance, if you wanted to create several qualifiers representing different payment methods, you could
            aggregate them under a single annotation using a member:
         </para>

         <programlisting role="JAVA"><![CDATA[@Qualifier
@Retention(RUNTIME)
@Target({METHOD, FIELD, PARAMETER, TYPE})
public @interface PayBy {
   PaymentMethod value();
}]]></programlisting> 
   
         <para>
            Then you select one of the possible values when you use the qualifier:
         </para>

         <programlisting role="JAVA"><![CDATA[private @Inject @PayBy(CHECK) CheckPayment checkPayment;]]></programlisting> 

         <para>
            You can tell the container to ignore a member of a qualifier type by annotating the member @NonBinding.
         </para>

         <programlisting role="JAVA"><![CDATA[@Qualifier
@Retention(RUNTIME)
@Target({METHOD, FIELD, PARAMETER, TYPE})
public @interface PayBy {
   PaymentMethod value();
   @NonBinding String comment;
}]]></programlisting> 

      </section>

      <section>
         <title>Combining qualifiers</title>

         <para>
            Both a bean and an injection point may specify multiple qualifiers:
         </para>

         <programlisting role="JAVA"><![CDATA[@Synchronous @Reliable
public class SynchronousReliablePaymentProcessor implements PaymentProcessor {
   public void process(Payment payment) { ... }
}]]></programlisting>      

         <programlisting role="JAVA"><![CDATA[@Inject @Synchronous @Reliable PaymentProcessor syncPaymentProcessor;]]></programlisting>

         <para>
            In this case, only a bean which has <emphasis>both</emphasis> qualifier annotations would be eligible for
            injection.
         </para>

      </section>

      <section>
         <title>Qualifiers on producer methods</title>

         <para>
            Even producer methods may specify qualifier annotations:
         </para>

         <programlisting role="JAVA"><![CDATA[@Produces @Asynchronous PaymentProcessor getPaymentProcessor() { ... }]]></programlisting>

         <para>
            This producer might create an asynchronous implementation powered by third party library such as Quartz
            (though definitely check out the new scheduler support in EJB 3.1!).
         </para>

      </section>

      <section>
         <title>The default qualifier</title>
  
         <para>
            CDI defines the qualifier annotation <literal>@Default</literal> that is the default qualifier type for any
            injection point or bean that does not explicitly specify a qualifier.
         </para>
  
         <para>
            <!-- this is a really vague point -->
            The most common circumstance when it's necessary to explicitly specify <literal>@Default</literal> is on a bean
            which has another qualifier in addition to the default one.
         </para>
  
      </section>
  
   </section>

   <section>
      <title>Fixing unsatisfied dependencies</title>
  
      <para>
         The typesafe resolution algorithm fails when, after considering the qualifier annotations on all beans that
         implement the bean type of an injection point and filtering out disabled beans (<literal>@Alternative</literal>
         beans which are not explicitly enabled), the container is unable to identify exactly one bean to inject. The
         container will either throw an <literal>UnsatisfiedDependencyException</literal> or
         <literal>AmbiguousDependencyException</literal>, depending on the circumstance.
      </para>
  
      <para>
         During the course of your development, your going to encounter these errors. Let's learn how to resolve them.
         It's usually pretty easy, and a decent IDE can really help out here.
      </para>
  
      <para>
         To fix an <literal>UnsatisfiedDependencyException</literal>, simply provide a bean which implements the bean
         type and has all the qualifier types of the injection point &#151; or explicitly enable an
         <literal>@Alternative</literal> bean that implements the bean type and has the appropriate qualifier types.
      </para>
  
      <para>
         To fix an <literal>AmbiguousDependencyException</literal>, introduce a qualifier to distinguish between the two
         implementations of the bean type, or disable one of two <literal>@Alternative</literal> beans that are trying
         to occupy the same space.  An <literal>AmbiguousDependencyException</literal> can only occur if two enabled
         beans share the same qualifier types (and one bean does not specialize the other, which we'll get into
         specialization in <xref linkend="specialization"/>).
      </para>
      
      <tip>
         <para>Just remember: "There can be only one."</para>
      </tip>
  
      <para>
         There's one more issue you need to be aware of when using dependency injection in beans: client proxies.
      </para>

   </section>

   <section>
      <title>Client proxies</title>
  
      <para>
         Clients of an injected bean do not usually hold a direct reference to a bean instance, unless the bean is
         dependent-scoped&#8212;in that case, the instance belongs to the bean.
      </para> 
  
      <para>
         Imagine that a bean bound to the application scope held a direct reference to a bean bound to the request
         scope. The application-scoped bean is shared between many different requests. However, each request should see
         a different instance of the request scoped bean&#8212;the current one!
      </para>
  
      <para>
         Now imagine that a bean bound to the session scope holds a direct reference to a bean bound to the application
         scope. From time to time, the session context is serialized to disk in order to use memory more efficiently.
         However, the application scoped bean instance should not be serialized along with the session scoped bean!  It
         can get that reference any time. No need to hoard it!
      </para>
  
      <para>
         Therefore, unless a bean has the default scope <literal>@Dependent</literal>, the container must indirect all
         injected references to the bean through a proxy object. This <emphasis>client proxy</emphasis> is responsible
         for ensuring that the bean instance that receives a method invocation is the instance that is associated with
         the current context. The client proxy also allows beans bound to contexts such as the session context to be
         serialized to disk without recursively serializing other injected beans.
      </para>

      <note>
         <para>
            If you recall, Seam also boasted the ability to reference the current instance of a component. However, Seam
            went about it differently. In Seam, the references are established prior to the method call and cleared
            afterword using an interceptor&#8212;a process known as bijection. This model was not very friendly to multiple
            threads sharing instances and thefore the client proxy approach was adopted in CDI instead.
         </para>
      </note>
  
      <para>
         Unfortunately, due to limitations of the Java language, some Java types cannot be proxied by the container.  If
         one of these types declares any scope other than <literal>@Dependent</literal>, the container throws an
         <literal>UnproxyableDependencyException</literal> when processing its use as an injection point.
      </para>
  
      <para>The following Java types cannot be proxied by the container:</para>
  
      <itemizedlist>
         <listitem>
            <para>classes which don't have a non-private constructor with no parameters, and</para>
         </listitem>
         <listitem>
            <para>
               classes which are declared <literal>final</literal> or have a <literal>final</literal> method,
            </para>
         </listitem>
         <listitem>
            <para>arrays and primitive types.</para>
         </listitem>
      </itemizedlist>
  
      <para>
         It's usually very easy to fix an <literal>UnproxyableDependencyException</literal>.  Simply add a constructor
         with no parameters to the injected class, introduce an interface, or, if all else fails, change the scope of
         the injected bean to <literal>@Dependent</literal>.
      </para>
  
   </section>

   <section>

      <title>Obtaining a contextual instance by programmatic lookup</title>

      <para>
         In certain situations, injection is not the most convenient way to obtain a contextual reference. For example,
         it may not be used when:
      </para>

      <itemizedlist>
         <listitem>
            <para>
               the bean type or qualifiers vary dynamically at runtime, or
            </para>
         </listitem>
         <listitem>
            <para>
               depending upon the deployment, there may be no bean which satisfies the type and qualifiers, or
            </para>
         </listitem>
         <listitem>
            <para>
               we would like to iterate over all beans of a certain type.
            </para>
         </listitem>
      </itemizedlist>

      <para>
         In these situations, the application may obtain an instance of the interface <literal>Instance</literal> 
         parameterized for the bean type by injection:
      </para>
  
      <programlisting role="JAVA"><![CDATA[@Inject Instance<PaymentProcessor> paymentProcessorSource;]]></programlisting>
  
      <para>
         The <literal>get()</literal> method on <literal>Instance</literal> can be used to produce a contextual instance
         of the bean programmatically.
      </para>
  
      <programlisting role="JAVA"><![CDATA[PaymentProcessor p = paymentProcessorSource.get()]]></programlisting>

      <para>
         Of course, qualifiers can be specified at the injection point, as with a bean injection:
      </para>

      <programlisting role="JAVA"><![CDATA[@Inject @Asynchronous Instance<PaymentProcessor> paymentProcessorSource;]]></programlisting>
  
      <para>
         You can also select a bean dynamically from the <literal>Instance</literal> based on the bean's qualifier.
         First, you need to add the <literal>@Any</literal> annotation at the injection point:
      </para>

      <programlisting role="JAVA"><![CDATA[@Inject @Any Instance<PaymentProcessor> paymentProcessorSource;]]></programlisting>
      
      <para>
         Then you specify which bean you want, based on its qualifier, using the <literal>select()</literal> method on
         <literal>Instance</literal>. You represent a qualifier annotation in code by subclassing the helper class
         <literal>AnnotationLiteral</literal>, since it's otherwise difficult to instantiate an annotation type in Java.
      </para>
  
      <programlisting role="JAVA"><![CDATA[PaymentProcessor p = paymentProcessorSource
   .select(new AnnotationLiteral<Asynchronous>() {});]]></programlisting>

      <para>
         You can choose to create a concreate type for all of your annotation literals, such as:
      </para>

      <programlisting role="JAVA"><![CDATA[abstract class AsynchronousQualifier
extends AnnotationLiteral<Asynchronous> implements Asynchronous {}]]></programlisting>

      <note>
         <para>
            The concrete is required if your qualifier has members, since an anonymous subclass cannot define members.
         </para>
      </note>

      <para>
         Again, like with annotation definitions, the <literal>AnnotationLiteral</literal> definition may seem a bit
         foreign at first, but it will soon become second nature as you will see it often in CDI applications.
      </para>

      <para>
         Here's how you might make use the dynamic selection:
      </para>

      <programlisting><![CDATA[Annotation qualifier = synchronously ?
new SynchronousQualifier() : new AsynchronousQualifier();
PaymentProcessor p = anyPaymentProcessor.select(qualifier).get().process(payment);]]></programlisting> 

   </section>

   <section>
      <title>Bean names and EL lookup</title>

      <para>
         You won't always be able to take advantage of the type safety that CDI provides. One of those places is the JSF
         view. To accomodate that environment, CDI must learn to speak the binding language that view templates
         understand. That language is the Unified EL.
      </para>

      <para>
         In order to participate in the Unified EL, a bean must have a name. The old way of assigning a name to a
         managed bean was in the faces-config.xml descriptor. This use of XML completely contradicts the approach
         to metadata that's in CDI. Given that one of the primary goals of JSR-299 is to get JSF talking
         with session beans (and, in turn, the rest of the Java EE platform), CDI needed to find a compromise. 
         It did in the form of the <literal>@Named</literal>.
      </para>

      <para>
         The <literal>@Named</literal> annotation, when added to a bean class, producer method or producer field,
         gives an alternate way for that bean to be referenced&#8212;by a string-based name.
      </para>

      <programlisting role="JAVA"><![CDATA[public @Named("cart") @SessionScoped class ShoppingCart {
 ...
}]]></programlisting> 
      <programlisting role="JAVA"><![CDATA[public @Produces @Named("items") List<Item> getItems() { ... }]]></programlisting> 
      <programlisting role="JAVA"><![CDATA[private @Produces @Named("currentUser") User user;]]></programlisting> 

      <para>
         Of course, you don't want to use this string-based name in your Java code, but you can use it your JSF views to
         invoke or read state from a bean. Since a bean could be an session bean, now you can hook your JSF view
         directly to your business component without any middle man and still keep the layers loosely coupled. Loosely
         coupled? Yes, because names can be associated with the deployment time and runtime polymorphism that CDI
         provides.
      </para>

      <para>
         Although JSF 2 still includes a managed bean facility, it's expected that you are now going to prefer CDI and
         EJB as your bean container, since they provides all that JSF managed beans have and much, much more. Plus, your
         business tier isn't tied to JSF in any way.
      </para>

   </section>

   <section>
      <title>Lifecycle callbacks and resource injections</title>

      <para>
         As part of the managed bean contract, all CDI beans support the lifecycle callback methods,
         <literal>@PostConstruct</literal> and <literal>@PreDestroy</literal> which are called after the bean is
         initialized (and after injections take place) and before it is destroyed (when the context to which it is bound
         ends), respectively.
      </para>

      <para>
         Of course, session beans also support callback methods introduced by the EJB specification, such as
         <literal>@PrePassivate</literal> and <literal>@PostActivate</literal>.
      </para>

      <para>
         Managed beans also support Java EE 5-style resource injections, declared using the <literal>@Resource</literal>
         annotation on a field. CDI beans can also inject session beans with the <literal>@EJB</literal> annotation.
      </para>

      <para>
         However, as you learned in a previous section, these injections are not fully type-safe, nor do they have the
         semantics that CDI provides. Therefore, it's the use of <literal>@Inject</literal> for injection is preferred.
         Relegate the resource injections to a bean that uses producer fields to mold these container-managed objects
         into injectable beans.
      </para>

   </section>

<!--
vim:et:ts=3:sw=3:tw=120
-->
</chapter>
