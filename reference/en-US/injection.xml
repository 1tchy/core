<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.3//EN"
   "http://www.oasis-open.org/docbook/xml/4.3/docbookx.dtd"  [ ]>
<chapter id="injection">
   <title>Dependency injection and programmatic lookup</title>

   <para>
      One of the most significant features of CDI, certainly the most recognized, is dependency injection; but not just
      dependency injection&#8212;<emphasis>typesafe</emphasis> dependency injection. In this chapter, you'll learn how 
      CDI is able to leverage the Java type system and annotations into a dependency injection strategy that is both
      strongly typed and keeps the bean implementation hidden from its clients.
   </para>

   <section>
      <title>Injection points</title>

      <para>
         The <literal>@Inject</literal> annotation lets us define an injection point that is injected during bean 
         instantiation. Injection can occur via three different mechanisms.
      </para>
      
      <para>
         <emphasis>Bean constructor</emphasis> parameter injection:
      </para>

      <programlisting role="JAVA"><![CDATA[public class Checkout {
        
   private final ShoppingCart cart;
    
   @Inject
   public Checkout(ShoppingCart cart) {
      this.cart = cart;
   }

}]]></programlisting>

      <note>
         <para>
            A bean can only have one injectable constructor.
         </para>
      </note>

      <para>
         <emphasis>Initializer method</emphasis> parameter injection:
      </para>

      <programlisting role="JAVA"><![CDATA[public class Checkout {
        
   private ShoppingCart cart;

   @Inject
   void setShoppingCart(ShoppingCart cart) {
      this.cart = cart;
   }
    
}]]></programlisting>

      <note>
         <para>
            A bean can have multiple initializer methods. If the bean is a session bean, the initializer method 
            is not required to be a business method of the session bean.
         </para>
      </note>

      <para>
         And direct field injection:
      </para>

      <programlisting role="JAVA"><![CDATA[public class Checkout {

   private @Inject ShoppingCart cart;
    
}]]></programlisting>

      <note>
         <para>
            Getter and setter methods are not required for field injection to work (unlike with JSF managed beans).
         </para>
      </note>

      <para>
         Dependency injection always occurs when the bean instance is first instantiated by the container.
         Simplifying just a little, things happen in this order:
      </para>

      <itemizedlist>
         <listitem>
            <para>
               First, the container calls the bean constructor (the default constructor or the one annotated
               <literal>@Inject</literal>), to obtain an instance of the bean.
            </para>
         </listitem>
         <listitem>
            <para>
               Next, the container initializes the values of all injected fields of the bean.
            </para>
         </listitem>
         <listitem>
            <para>
               Next, the container calls all initializer methods of bean (the call order is not portable, don't 
               rely on it).
            </para>
         </listitem>
         <listitem>
            <para>
               Finally, the <literal>@PostConstruct</literal> method of the bean is called, if defined.
            </para>
         </listitem>
      </itemizedlist>
      
      <para>(The only complication is that the container might call initializer methods declared by a superclass 
      before initializing injected fields declared by a subclass.)</para>

      <tip>
         <para>
            One major advantage of constructor injection is that it allows the bean to be immutable.
         </para>
      </tip>
      
      <para>
         CDI also supports parameter injection for some other methods that are invoked by the container. For instance, 
         parameter injection is supported for producer methods:
      </para>

      <programlisting role="JAVA"><![CDATA[@Produces Checkout createCheckout(ShoppingCart cart) {
    return new Checkout(cart);
}]]></programlisting>

      <para>
        This is a case where the <literal>@Inject</literal> annotation <emphasis>is not</emphasis> required at the
        injection point. The same is true for observer methods (which we'll meet in <xref linkend="events"/>) and
        disposer methods.
      </para>
   </section>

   <section>
      <title>What gets injected</title>

      <para>
         The CDI specification defines a procedure, called <emphasis>typesafe resolution</emphasis>, that the container 
         follows when identifying the bean to inject to an injection point.  This algorithm looks complex at first, but 
         once you understand it, it's really quite intuitive. Typesafe resolution is performed at system initialization 
         time, which means that the container will inform the developer immediately if a bean's
         dependencies cannot be satisfied.
      </para>

      <para>
         The purpose of this algorithm is to allow multiple beans to implement the same bean type and either:
      </para>

      <itemizedlist>
         <listitem>
            <para>
               allow the client to select which implementation it requires using a <emphasis>qualifier</emphasis> or
            </para>
        </listitem>
        <listitem>
            <para>
               allow the application deployer to select which implementation is appropriate for a particular deployment,
               without changes to the client, by enabling or disabling an <emphasis>alternative</emphasis>, or
            </para>
        </listitem>
        <listitem>
            <para>
               allow the beans to be isolated into separate modules.
            </para>
        </listitem>
      </itemizedlist>

      <para>
         Obviously, if you have exactly one bean of a given type, and an injection point with that same type, then bean A is
         going to go into slot A. That's the simplest possible scenario. When you first start your application, you'll
         likely have lots of those.
      </para>
      
      <para>
         But then, things start to get complicated. Let's explore how the container determines which bean to inject in
         more advanced cases. We'll start by taking a closer look at qualifiers.
      </para>

   </section>

   <section>
      <title>Qualifier annotations</title>

      <para>
         If we have more than one bean that implements a particular bean type, the injection point can specify exactly
         which bean should be injected using a qualifier annotation. For example, there might be two implementations of
         <literal>PaymentProcessor</literal>:
      </para>

      <programlisting role="JAVA"><![CDATA[@Synchronous
public class SynchronousPaymentProcessor implements PaymentProcessor {
   public void process(Payment payment) { ... }
}]]></programlisting>      

      <programlisting role="JAVA"><![CDATA[@Asynchronous
public class AsynchronousPaymentProcessor implements PaymentProcessor {
   public void process(Payment payment) { ... }
}]]></programlisting>

      <para>
         Where <literal>@Synchronous</literal> and <literal>@Asynchronous</literal> are qualifier annotations:
      </para>

      <programlisting role="JAVA"><![CDATA[@Qualifier
@Retention(RUNTIME)
@Target({TYPE, METHOD, FIELD, PARAMETER})
public @interface Synchronous {}]]></programlisting>

<programlisting role="JAVA"><![CDATA[@Qualifier
@Retention(RUNTIME)
@Target({TYPE, METHOD, FIELD, PARAMETER})
public @interface Asynchronous {}]]></programlisting>

      <para>
         A client bean developer uses the qualifier annotation to specify exactly which bean should be injected.
      </para>

      <para>Using field injection:</para>

      <programlisting role="JAVA"><![CDATA[@Inject @Synchronous PaymentProcessor syncPaymentProcessor;
@Inject @Asynchronous PaymentProcessor asyncPaymentProcessor;]]></programlisting>

      <para>Using initializer method injection:</para>

      <programlisting role="JAVA"><![CDATA[@Inject
public void setPaymentProcessors(@Synchronous PaymentProcessor syncPaymentProcessor, 
                                 @Asynchronous PaymentProcessor asyncPaymentProcessor) {
   this.syncPaymentProcessor = syncPaymentProcessor;
   this.asyncPaymentProcessor = asyncPaymentProcessor;
}]]></programlisting>

      <para>Using constructor injection:</para>

     <programlisting role="JAVA"><![CDATA[@Inject
public Checkout(@Synchronous PaymentProcessor syncPaymentProcessor, 
                @Asynchronous PaymentProcessor asyncPaymentProcessor) {
   this.syncPaymentProcessor = syncPaymentProcessor;
   this.asyncPaymentProcessor = asyncPaymentProcessor;
}]]></programlisting>

      <para>
         Qualifier annotations can also qualify method arguments of producer, disposer and observer methods. Combining
         qualified arguments with producer methods is a good way to have an implementation of a bean type
         selected at runtime based on the state of the system:
      </para>

      <programlisting role="JAVA"><![CDATA[@Produces
PaymentProcessor getPaymentProcessor(@Synchronous PaymentProcessor syncPaymentProcessor,
                                     @Asynchronous PaymentProcessor asyncPaymentProcessor) {
   return isSynchronous() ? syncPaymentProcessor : asyncPaymentProcessor;
}]]></programlisting> 
   
      <para>
         If an injected field or a parameter of a bean constructor or initializer method is not explicitly annotated 
         with a qualifier, the default qualifier, <literal>@Default</literal>, is assumed.
      </para>

      <para>
         Now, you may be thinking, <emphasis>"What's the different between using a qualifier and just specifying the
         exact implementation class you want?"</emphasis> It's important to understand that a qualifier is like an
         extension of the interface. It does not create a direct dependency to any particular implementation. There 
         may be multiple alterative implementations of <literal>@Asynchronous PaymentProcessor</literal>!
      </para>

      <section>
         <title>Qualifiers with members</title>

         <para>
            Java annotations can have members. We can use annotation members to further discriminate a qualifier. This 
            prevents a potential explosion of new annotations. For example, instead of creating several qualifiers 
            representing different payment methods, we could aggregate them into a single annotation with a member:
         </para>

         <programlisting role="JAVA"><![CDATA[@Qualifier
@Retention(RUNTIME)
@Target({METHOD, FIELD, PARAMETER, TYPE})
public @interface PayBy {
   PaymentMethod value();
}]]></programlisting> 
   
         <para>
            Then we select one of the possible member values when appling the qualifier:
         </para>

         <programlisting role="JAVA"><![CDATA[private @Inject @PayBy(CHECK) CheckPayment checkPayment;]]></programlisting> 

         <para>
            We can force the container to ignore a member of a qualifier type by annotating the member <literal>@NonBinding</literal>.
         </para>

         <programlisting role="JAVA"><![CDATA[@Qualifier
@Retention(RUNTIME)
@Target({METHOD, FIELD, PARAMETER, TYPE})
public @interface PayBy {
   PaymentMethod value();
   @NonBinding String comment() default "";
}]]></programlisting> 

      </section>

      <section>
         <title>Combining qualifiers</title>

         <para>
            An injection point may specify multiple qualifiers:
         </para>

         <programlisting role="JAVA"><![CDATA[@Inject @Synchronous @Reliable PaymentProcessor syncPaymentProcessor;]]></programlisting>

         <para>
            Then a bean which has <emphasis>both</emphasis> qualifier annotations would be eligible for
            injection.
         </para>

         <programlisting role="JAVA"><![CDATA[@Synchronous @Reliable
public class SynchronousReliablePaymentProcessor implements PaymentProcessor {
   public void process(Payment payment) { ... }
}]]></programlisting>      

      </section>

      <section>
         <title>Qualifiers on producer methods</title>

         <para>
            Even producer methods may specify qualifiers:
         </para>

         <programlisting role="JAVA"><![CDATA[@Produces @Asynchronous PaymentProcessor getPaymentProcessor() { ... }]]></programlisting>

         <tip>
            <para>
               If we really need to create beans with asynchronous semantics, EJB 3.1 asynchronous methods are an
               excellent solution.
            </para>
         </tip>

      </section>

      <section>
         <title>The default qualifier</title>
  
         <para>
            CDI defines the qualifier annotation <literal>@Default</literal> that is the default qualifier type for any
            injection point or bean that does not explicitly specify a qualifier.
         </para>
  
         <para>
            <!-- this is a really vague point -->
            The most common circumstance when it's necessary to explicitly specify <literal>@Default</literal> is on a bean
            which has another qualifier in addition to the default one.
         </para>
  
      </section>
  
   </section>

   <section>
      <title>Fixing unsatisfied dependencies</title>
  
      <para>
         The typesafe resolution algorithm fails when, after considering the qualifier annotations on all beans that
         implement the bean type of an injection point and filtering out disabled beans (<literal>@Alternative</literal>
         beans which are not explicitly enabled), the container is unable to identify exactly one bean to inject. The
         container will either throw an <literal>UnsatisfiedDependencyException</literal> or
         <literal>AmbiguousDependencyException</literal>, depending on the circumstance.
      </para>
  
      <para>
         During the course of your development, you're going to encounter these errors. Let's learn how to resolve them.
         It's usually pretty easy, and a decent IDE can really help out here.
      </para>
  
      <para>
         To fix an <literal>UnsatisfiedDependencyException</literal>, either: 
      </para>
         
      <itemizedlist>
         <listitem>      
            <para>
            create a bean which implements the bean type and has all the qualifier types of the injection point,
            </para>
         </listitem> 
         <listitem>
            <para>
            make sure that the bean you already have is in the classpath of the module with the injection point, or
            </para>
         </listitem> 
         <listitem> 
            <para>
            explicitly enable an <literal>@Alternative</literal> bean that implements the bean type and has the 
            appropriate qualifier types, using <literal>beans.xml</literal>.
            </para>
         </listitem> 
      </itemizedlist>
      
      <para>
         To fix an <literal>AmbiguousDependencyException</literal>, either: 
      </para>

      <itemizedlist>
         <listitem>      
            <para>
               introduce a qualifier to distinguish between the two implementations of the bean type, 
            </para>
         </listitem> 
         <listitem>      
            <para>
               disable one of the beans by annotating it <literal>@Alternative</literal>, 
            </para>
         </listitem> 
         <listitem>
            <para>
               move one of the implementations to a module that is not in the classpath of the module with the 
               injection point, or
            </para>
         </listitem> 
         <listitem> 
            <para>
               disable one of two <literal>@Alternative</literal> beans that are trying to occupy the same space, 
               using <literal>beans.xml</literal>.  
            </para>
         </listitem> 
      </itemizedlist>
               
      <para>
         An <literal>AmbiguousDependencyException</literal> can only occur if two enabled beans share the same 
         qualifier types.
      </para>
      
      <tip>
         <para>Just remember: "There can be only one."</para>
      </tip>
      
      <para>
         On the other hand, if you really do have an optional or multivalued injection point, you should change
         the type of your injection point to <literal>Instance</literal>, as we'll see in <xref linkend="lookup"/>.
      </para>
  
      <para>
         There's one more issue you need to be aware of when using the dependency injection service: client proxies.
      </para>

   </section>

   <section>
      <title>Client proxies</title>
  
      <para>
         Clients of an injected bean do not usually hold a direct reference to a bean instance, unless the bean is
         a dependent object (scope <literal>@Dependent</literal>).
      </para> 
  
      <para>
         Imagine that a bean bound to the application scope held a direct reference to a bean bound to the request
         scope. The application-scoped bean is shared between many different requests. However, each request should see
         a different instance of the request scoped bean&#8212;the current one!
      </para>
  
      <para>
         Now imagine that a bean bound to the session scope holds a direct reference to a bean bound to the application
         scope. From time to time, the session context is serialized to disk in order to use memory more efficiently.
         However, the application scoped bean instance should not be serialized along with the session scoped bean!  It
         can get that reference any time. No need to hoard it!
      </para>
  
      <para>
         Therefore, unless a bean has the default scope <literal>@Dependent</literal>, the container must indirect all
         injected references to the bean through a proxy object. This <emphasis>client proxy</emphasis> is responsible
         for ensuring that the bean instance that receives a method invocation is the instance that is associated with
         the current context. The client proxy also allows beans bound to contexts such as the session context to be
         serialized to disk without recursively serializing other injected beans.
      </para>

      <note>
         <para>
            If you recall, Seam also boasted the ability to reference the current instance of a component. However, Seam
            went about it differently. In Seam, the references are established prior to the method call and cleared
            afterword using an interceptor&#8212;a process known as bijection. This model was not very friendly to multiple
            threads sharing instances and therefore the client proxy approach was adopted in CDI instead.
         </para>
      </note>
  
      <para>
         Unfortunately, due to limitations of the Java language, some Java types cannot be proxied by the container. If
         an inection point declared with one of these types resolves to a bean with any scope other than 
         <literal>@Dependent</literal>, the container throws an <literal>UnproxyableDependencyException</literal> at
         system initialization time.
      </para>
  
      <para>The following Java types cannot be proxied by the container:</para>
  
      <itemizedlist>
         <listitem>
            <para>classes which don't have a non-private constructor with no parameters, and</para>
         </listitem>
         <listitem>
            <para>
               classes which are declared <literal>final</literal> or have a <literal>final</literal> method,
            </para>
         </listitem>
         <listitem>
            <para>arrays and primitive types.</para>
         </listitem>
      </itemizedlist>
  
      <para>
         It's usually very easy to fix an <literal>UnproxyableDependencyException</literal>. Simply add a constructor
         with no parameters to the injected class, introduce an interface, or, if all else fails, change the scope of
         the injected bean to <literal>@Dependent</literal>. 
      </para>
      
      <note>
      <para>
         A future release of Weld will likely support a non-standard workaround for this limitation, using
         non-portable JVM APIs:
      </para>

      <itemizedlist>
         <listitem>
            <para>
               Sun, IcedTea, Mac: <literal>Unsafe.allocateInstance()</literal> (The most efficient)
            </para>
         </listitem>
         <listitem>
            <para>
               IBM, JRockit: <literal>ReflectionFactory.newConstructorForSerialization()</literal>
            </para>
         </listitem>
      </itemizedlist>
      
      <para>
         But we didn't get around to implementing this yet.
      </para>
      </note>
  
   </section>

   <section id="lookup">

      <title>Obtaining a contextual instance by programmatic lookup</title>

      <para>
         In certain situations, injection is not the most convenient way to obtain a contextual reference. For example,
         it may not be used when:
      </para>

      <itemizedlist>
         <listitem>
            <para>
               the bean type or qualifiers vary dynamically at runtime, or
            </para>
         </listitem>
         <listitem>
            <para>
               depending upon the deployment, there may be no bean which satisfies the type and qualifiers, or
            </para>
         </listitem>
         <listitem>
            <para>
               we would like to iterate over all beans of a certain type.
            </para>
         </listitem>
      </itemizedlist>

      <para>
         In these situations, the application may obtain an instance of the interface <literal>Instance</literal> 
         parameterized for the bean type by injection:
      </para>
  
      <programlisting role="JAVA"><![CDATA[@Inject Instance<PaymentProcessor> paymentProcessorSource;]]></programlisting>
  
      <para>
         The <literal>get()</literal> method on <literal>Instance</literal> can be used to produce a contextual instance
         of the bean programmatically.
      </para>
  
      <programlisting role="JAVA"><![CDATA[PaymentProcessor p = paymentProcessorSource.get();]]></programlisting>

      <para>
         Of course, qualifiers can be specified at the injection point, as with a bean injection:
      </para>

      <programlisting role="JAVA"><![CDATA[@Inject @Asynchronous Instance<PaymentProcessor> paymentProcessorSource;]]></programlisting>
  
      <para>
         You can also select a bean dynamically from the <literal>Instance</literal> by passing the bean's qualifier.
         First, you need to add the <literal>@Any</literal> annotation at the injection point:
      </para>

      <programlisting role="JAVA"><![CDATA[@Inject @Any Instance<PaymentProcessor> paymentProcessorSource;]]></programlisting>
      
      <para>
         Then you specify which bean you want, by passing  its qualifier to the <literal>select()</literal> method of
         <literal>Instance</literal>. You represent a qualifier annotation in code by subclassing the helper class
         <literal>AnnotationLiteral</literal>, since it's otherwise difficult to instantiate an annotation type in Java.
      </para>
  
      <programlisting role="JAVA"><![CDATA[PaymentProcessor p = paymentProcessorSource
   .select(new AnnotationLiteral<Asynchronous>() {});]]></programlisting>

      <para>
         You can choose to create a concrete type for all of your annotation literals, such as:
      </para>

      <programlisting role="JAVA"><![CDATA[abstract class AsynchronousQualifier
extends AnnotationLiteral<Asynchronous> implements Asynchronous {}]]></programlisting>

      <note>
         <para>
            The concrete type is required if your qualifier has members, since an anonymous subclass cannot define members.
         </para>
      </note>

      <para>
         Again, like with annotation definitions, the <literal>AnnotationLiteral</literal> definition may seem a bit
         foreign at first, but it will soon become second nature as you will see it often in CDI applications.
      </para>

      <para>
         Here's how you might make use of dynamic selection:
      </para>

      <programlisting><![CDATA[Annotation qualifier = synchronously ?
new SynchronousQualifier() : new AsynchronousQualifier();
PaymentProcessor p = anyPaymentProcessor.select(qualifier).get().process(payment);]]></programlisting> 

   </section>

   <section>
      <title>Bean names and EL lookup</title>

      <para>
         You won't always be able to take advantage of the typesafety that CDI provides. Sometimes your Java
         code needs to be called from some other language that doesn't support the Java type system. For example,
         to bind your beans to a JSF view or JSP page, you need to be able to refer to them in a Unified EL
         expression.
      </para>

      <para>
         Theres only one way to identity a bean in Unified EL: with a name. The old way of assigning a name to a
         managed bean was the <literal>faces-config.xml</literal> descriptor. This use of XML completely 
         contradicts the approach to metadata that's used in CDI. Given that one of the goals of JSR-299 was to get 
         JSF talking with session beans (and, in turn, the rest of the Java EE platform), CDI needed to find a 
         different approach. The <literal>@Named</literal> annotation assigns a string-based EL name to a bean.
      </para>

      <programlisting role="JAVA"><![CDATA[public @Named("cart") @SessionScoped 
class ShoppingCart implements Serializable {
 ...
}]]></programlisting> 
      <programlisting role="JAVA"><![CDATA[public @Produces @Named("items") List<Item> getItems() { ... }]]></programlisting> 
      <programlisting role="JAVA"><![CDATA[private @Produces @Named("currentUser") User user;]]></programlisting> 

      <para>
         Of course, you don't want to use this string-based name in your Java code, but you can use it your JSF views to
         invoke or read state from a bean. Since a bean could be an session bean, now you can hook your JSF view
         directly to your business component without any middle man and still keep the layers loosely coupled. Loosely
         coupled? Yes, because names can be associated with the deployment time and runtime polymorphism that CDI
         provides.
      </para>

      <para>
         Although JSF 2 still includes a managed bean facility, it's expected that you are now going to prefer CDI and
         EJB as your bean container, since they provides all that JSF managed beans have and much, much more. Plus, your
         business tier isn't tied to JSF in any way.
      </para>

   </section>

   <section>
      <title>Lifecycle callbacks and resource injections</title>

      <para>
         As part of the managed bean contract, all CDI beans support the lifecycle callback methods,
         <literal>@PostConstruct</literal> and <literal>@PreDestroy</literal> which are called after the bean is
         initialized (and after injections take place) and before it is destroyed (when the context to which it is bound
         ends), respectively.
      </para>

      <para>
         Of course, session beans also support callback methods introduced by the EJB specification, such as
         <literal>@PrePassivate</literal> and <literal>@PostActivate</literal>.
      </para>

      <para>
         Managed beans also support Java EE 5-style resource injections, declared using the <literal>@Resource</literal>
         annotation on a field. CDI beans can also inject session beans with the <literal>@EJB</literal> annotation.
      </para>

      <para>
         However, as you learned in a previous section, these injections are not fully type-safe, nor do they have the
         semantics that CDI provides. Therefore, it's the use of <literal>@Inject</literal> for injection is preferred.
         Relegate the resource injections to a bean that uses producer fields to mold these container-managed objects
         into injectable beans.
      </para>

   </section>

<!--
vim:et:ts=3:sw=3:tw=120
-->
</chapter>
