<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.3//EN"
   "http://www.oasis-open.org/docbook/xml/4.3/docbookx.dtd"  [ ]>
<!-- This chapter needs *major* filling in; specifically, give an overview of how an extension plugins in -->
<chapter id="extend">
   <title>Portable extensions</title>
  
   <para>
      CDI is intended to be a foundation for frameworks, extensions and integration with other technologies. Therefore,
      CDI exposes a set of SPIs for the use of developers of portable extensions to CDI. For example, the following
      kinds of extensions were envisaged by the designers of CDI:
   </para>
  
   <itemizedlist>
      <listitem>
         <para>integration with Business Process Management engines,</para>
      </listitem>
      <listitem>
         <para>
            integration with third-party frameworks such as Spring, Seam, GWT or Wicket, and
         </para>
      </listitem>
      <listitem>
         <para>new technology based upon the CDI programming model.</para>
      </listitem>
   </itemizedlist>

   <para>
      More formally, according to the spec:
   </para>

   <blockquote>
      <para>A portable extension may integrate with the container by:</para>
      <itemizedlist>
         <listitem>
            <para>
               Providing its own beans, interceptors and decorators to the container
            </para>
          </listitem>
          <listitem>
            <para>
               Injecting dependencies into its own objects using the dependency injection service
            </para>
          </listitem>
          <listitem>
            <para>
               Providing a context implementation for a custom scope
            </para>
          </listitem>
          <listitem>
            <para>
               Augmenting or overriding the annotation-based metadata with metadata from some other source
            </para>
         </listitem>
      </itemizedlist>
   </blockquote>
   
   <section>
      <title>Creating an <literal>Extension</literal></title>
      
      <para>
         The first step in creating a portable extension is to write a class that implements 
         <literal>Extension</literal>. This marker interface does not define any methods, but
         it's needed to satisfy the requirements of Java SE's service provider architecture.
      </para>
      
      <programlisting role="JAVA">class MyExtension implements Extension { ... }</programlisting>
      
      <para>
         Next, we need to register our extension as a service provider by creating a file named
         <literal>META-INF/services/javax.enterprise.inject.spi.Extension</literal>, which contains
         the name of our extension class:
      </para>
      
      <programlisting>org.mydomain.extension.MyExtension</programlisting>
      
      <para>
         An extension is not a bean, exactly, since it is instantiated by the container during the 
         initialization process, before any beans or contexts exist. However, it can be injected
         into other beans once the initialization process is complete.
      </para>
      
      <para>
         And, like beans, extensions can have observer methods. Usually, the observer methods
         observe <emphasis>container lifecycle events</emphasis>.
      </para>
      
   </section>
   
   <section>
      <title>Container lifecycle events</title>
      
      <para>
         During the initialization process, the container fires a series of events, including:
      </para>
      
      <itemizedlist>
         <listitem>
            <para>
               <literal>BeforeBeanDiscovery</literal>
            </para>
         </listitem>
         <listitem>
            <para>
               <literal>ProcessAnnotatedType</literal>
            </para>
         </listitem>
         <listitem>
            <para>
               <literal>ProcessInjectionTarget</literal> and <literal>ProcessProducer</literal>
            </para>
         </listitem>
         <listitem>
            <para>
               <literal>ProcessBean</literal> and <literal>ProcessObserverMethod</literal>
            </para>
         </listitem>
         <listitem>
            <para>
               <literal>AfterBeanDiscovery</literal>
            </para>
         </listitem>
         <listitem>
            <para>
               <literal>AfterDeploymentValidation</literal>
            </para>
         </listitem>
      </itemizedlist>
      
      <para>
         Extensions may observe these events:
      </para>
   
      <programlisting role="JAVA"><![CDATA[class MyExtension implements Extension {
      
   void beforeBeanDiscovery(BeforeBeanDiscovery bbd) {
      Logger.global.debug("beginning the scanning process");
   }
      
   <T> void processAnnotatedType(ProcessAnnotatedType<T> pat) {
      Logger.global.debug("scanning type: " + pat.getAnnotatedType().getJavaClass().getName());
   } 

   void afterBeanDiscovery(AfterBeanDiscovery abd) {
      Logger.global.debug("finished the scanning process");
   }
   
}]]></programlisting>

      <para>
         In fact, the extension can do a lot more than just observe. The extension is permitted to 
         modify the container's metamodel and more. Here's a very simple example:
      </para>
      
      <programlisting role="JAVA"><![CDATA[class MyExtension implements Extension {
      
   <T> void processAnnotatedType(ProcessAnnotatedType<T> pat) {
      //tell the container to ignore the type if it is annotated @Ignore
      if ( pat.getAnnotatedType().isAnnotionPresent(Ignore.class) ) pat.veto();   
   } 
   
}]]></programlisting>

      <para>
         The observer method may inject a <literal>BeanManager</literal>
      </para>

      <programlisting role="JAVA"><![CDATA[class MyExtension implements Extension {
      
   <T> void processAnnotatedType(ProcessAnnotatedType<T> pat, BeanManager beanManager) { ... }
   
}]]></programlisting>

   </section>
  
   <section>
      <title>The <literal>BeanManager</literal> object</title>
    
      <para>
         The nerve center for extending CDI is the <literal>BeanManager</literal> object. The 
         <literal>BeanManager</literal> interface lets us obtain beans, interceptors, decorators,
         observers and contexts programmatically.
      </para>
    
<programlisting role="JAVA"><![CDATA[public interface Manager {
   public Object getReference(Bean<?> bean, Type beanType, CreationalContext<?> ctx);
   public Object getInjectableReference(InjectionPoint ij, CreationalContext<?> ctx);
   public <T> CreationalContext<T> createCreationalContext(Contextual<T> contextual);
   public Set<Bean<?>> getBeans(Type beanType, Annotation... bindings);
   public Set<Bean<?>> getBeans(String name);
   public <X> Bean<? extends X> getMostSpecializedBean(Bean<X> bean);
   public Bean<?> getPassivationCapableBean(String id);
   public <X> Bean<? extends X> resolve(Set<Bean<? extends X>> beans);
   public void validate(InjectionPoint injectionPoint);
   public void fireEvent(Object event, Annotation... bindings);
   public <T> Set<ObserverMethod<?, T>> resolveObserverMethods(T event, Annotation... bindings);
   public List<Decorator<?>> resolveDecorators(Set<Type> types, Annotation... bindings);
   public List<Interceptor<?>> resolveInterceptors(InterceptionType type, Annotation... interceptorBindings);
   public boolean isScope(Class<? extends Annotation> annotationType);
   public boolean isNormalScope(Class<? extends Annotation> annotationType);
   public boolean isPassivatingScope(Class<? extends Annotation> annotationType);
   public boolean isQualifier(Class<? extends Annotation> annotationType);
   public boolean isInterceptorBinding(Class<? extends Annotation> annotationType);
   public boolean isStereotype(Class<? extends Annotation> annotationType);
   public Set<Annotation> getInterceptorBindingDefinition(Class<? extends Annotation> bindingType);
   public Set<Annotation> getStereotypeDefinition(Class<? extends Annotation> stereotype);
   public Context getContext(Class<? extends Annotation> scopeType);
   public ELResolver getELResolver();
   public ExpressionFactory wrapExpressionFactory(ExpressionFactory expressionFactory);
   public <T> AnnotatedType<T> createAnnotatedType(Class<T> type);
   public <T> InjectionTarget<T> createInjectionTarget(AnnotatedType<T> type);
}]]></programlisting>

      <para>Any bean or other Java EE component which supports injection can obtain an instance of <literal>BeanManager</literal> 
      via injection:</para>
    
      <programlisting role="JAVA">@Inject BeanManager beanManager</programlisting>

      <para>
         Java EE components may obtain an instance of <literal>BeanManager</literal> from JNDI by looking up the name
         <literal>java:comp/BeanManager</literal>. Any operation of <literal>BeanManager</literal> may be called at any 
         time during the execution of the application.
      </para>

      <para>Let's study some of the interfaces exposed by the <literal>BeanManager</literal>.</para>
    
   </section>
  
   <section>
      <title>The <literal>Bean</literal> interface</title>
    
      <para>
         Instances of the interface <literal>Bean</literal> represent beans. There is an instance of
         <literal>Bean</literal> registered with the <literal>BeanManager</literal> object for every bean in the
         application.
      </para>
    
      <programlisting role="JAVA"><![CDATA[public interface Bean<T> extends Contextual<T> {
   public Set<Type> getTypes();
   public Set<Annotation> getQualifiers();
   public Class<? extends Annotation> getScope();
   public String getName();
   public Set<Class<? extends Annotation>> getStereotypes();
   public Class<?> getBeanClass();
   public boolean isAlternative();
   public boolean isNullable();
   public Set<InjectionPoint> getInjectionPoints();
}]]></programlisting>

      <para>
         It's possible to implement the <literal>Bean</literal> interface and register instances by observing the
         <literal>AfterBeanDiscovery</literal> container lifecycle event and calling <literal>AfterBeanDiscovery.addBean()</literal> 
         to provide support for new kinds of beans, beyond those defined by the CDI specification. For example, we could 
         use the <literal>Bean</literal> interface to allow objects managed by another framework to be injected into beans.
      </para>
    
      <para>
         There are two subinterfaces of <literal>Bean</literal> defined by the CDI specification:
         <literal>Interceptor</literal> and <literal>Decorator</literal>.
      </para>
    
   </section>

   <section>
      <title>The <literal>Context</literal> interface</title>
    
      <para>
         The <literal>Context</literal> interface supports addition of new scopes to CDI, or extension of the built-in
         scopes to new environments.
      </para>
    
<programlisting role="JAVA"><![CDATA[public interface Context {
   public Class<? extends Annotation> getScope();
   public <T> T get(Contextual<T> contextual, CreationalContext<T> creationalContext);
   public <T> T get(Contextual<T> contextual);
   boolean isActive();
}]]></programlisting>

      <para>
         For example, we might implement <literal>Context</literal> to add a business process scope to CDI, or to add
         support for the conversation scope to an application that uses Wicket.
      </para>
    
   </section>
   
   <section>
      <title>Wrapping an <literal>AnnotatedType</literal></title>
      
      <para>TODO</para>
      
   </section>

   <section>
      <title>Wrapping an <literal>InjectionTarget</literal></title>
      
      <para>TODO</para>
      
   </section>

  <!--
  TODO finish me!
  -->
  
<!--
vim:et:ts=3:sw=3:tw=120
-->
</chapter>
