<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.3//EN"
   "http://www.oasis-open.org/docbook/xml/4.3/docbookx.dtd"  [ ]>
<!-- This chapter needs *major* filling in; specifically, give an overview of how an extension plugins in -->
<chapter id="extend">
   <title>Extending CDI through portable extensions</title>
  
   <para>
      CDI is intended to be a foundation for frameworks, extensions and integration with other technologies. Therefore,
      CDI exposes a set of SPIs for the use of developers of portable extensions to CDI. For example, the following
      kinds of extensions were envisaged by the designers of CDI:
   </para>
  
   <itemizedlist>
      <listitem>
         <para>integration with Business Process Management engines,</para>
      </listitem>
      <listitem>
         <para>
            integration with third-party frameworks such as Spring, Seam, GWT or Wicket, and
         </para>
      </listitem>
      <listitem>
         <para>new technology based upon the CDI programming model.</para>
      </listitem>
   </itemizedlist>

   <para>
      More formally, according to the spec:
   </para>

   <blockquote>
      <para>A portable extension may integrate with the container by:</para>
      <itemizedlist>
         <listitem>
            <para>
               Providing its own beans, interceptors and decorators to the container
            </para>
            <para>
            </para>
               Injecting dependencies into its own objects using the dependency injection service
            <para>
               Providing a context implementation for a custom scope
            </para>
            <para>
               Augmenting or overriding the annotation-based metadata with metadata from some other source
            </para>
         </listitem>
      </itemizedlist>
   </blockquote>

   <para>
      The nerve center for extending CDI is the <literal>BeanManager</literal> object.
   </para>
  
   <section>
      <title>The <literal>BeanManager</literal> object</title>
    
      <para>
         The <literal>BeanManager</literal> interface lets us register and obtain beans, interceptors, decorators,
         observers and contexts programmatically.
      </para>
    
<programlisting role="JAVA"><![CDATA[public interface Manager {
   public Object getReference(Bean<?> bean, Type beanType, CreationalContext<?> ctx);
   public Object getInjectableReference(InjectionPoint ij, CreationalContext<?> ctx);
   public <T> CreationalContext<T> createCreationalContext(Contextual<T> contextual);
   public Set<Bean<?>> getBeans(Type beanType, Annotation... bindings);
   public Set<Bean<?>> getBeans(String name);
   public <X> Bean<? extends X> getMostSpecializedBean(Bean<X> bean);
   public Bean<?> getPassivationCapableBean(String id);
   public <X> Bean<? extends X> resolve(Set<Bean<? extends X>> beans);
   public void validate(InjectionPoint injectionPoint);
   public void fireEvent(Object event, Annotation... bindings);
   public <T> Set<ObserverMethod<?, T>> resolveObserverMethods(T event, Annotation... bindings);
   public List<Decorator<?>> resolveDecorators(Set<Type> types, Annotation... bindings);
   public List<Interceptor<?>> resolveInterceptors(InterceptionType type, Annotation... interceptorBindings);
   public boolean isScope(Class<? extends Annotation> annotationType);
   public boolean isNormalScope(Class<? extends Annotation> annotationType);
   public boolean isPassivatingScope(Class<? extends Annotation> annotationType);
   public boolean isQualifier(Class<? extends Annotation> annotationType);
   public boolean isInterceptorBindingType(Class<? extends Annotation> annotationType);
   public boolean isStereotype(Class<? extends Annotation> annotationType);
   public Set<Annotation> getInterceptorBindingTypeDefinition(Class<? extends Annotation> bindingType);
   public Set<Annotation> getStereotypeDefinition(Class<? extends Annotation> stereotype);
   public Context getContext(Class<? extends Annotation> scopeType);
   public ELResolver getELResolver();
   public ExpressionFactory wrapExpressionFactory(ExpressionFactory expressionFactory);
   public <T> AnnotatedType<T> createAnnotatedType(Class<T> type);
   public <T> InjectionTarget<T> createInjectionTarget(AnnotatedType<T> type);
}]]></programlisting>

      <para>We can obtain an instance of <literal>BeanManager</literal> via injection:</para>
    
      <programlisting role="JAVA">@Inject BeanManager beanManager</programlisting>

      <para>
         Java EE components may obtain an instance of BeanManager from JNDI by looking up the name
         <literal>java:comp/BeanManager</literal>.  Any operation of BeanManager may be called at any time during the
         execution of the application.
      </para>

      <para>Let's study some of the interfaces exposed by the <literal>BeanManager</literal>.</para>
    
   </section>
  
   <section>
      <title>The <literal>Bean</literal> class</title>
    
      <para>
         Instances of the interface <literal>Bean</literal> represent beans. There is an instance of
         <literal>Bean</literal> registered with the <literal>BeanManager</literal> object for every bean in the
         application.
      </para>
    
      <programlisting role="JAVA"><![CDATA[public interface class Bean<T> extends Contextual<T> {
   public Set<Type> getTypes();
   public Set<Annotation> getQualifiers();
   public Class<? extends Annotation> getScope();
   public String getName();
   public Set<Class<? extends Annotation>> getStereotypes();
   public Class<?> getBeanClass();
   public boolean isAlternative();
   public boolean isNullable();
   public Set<InjectionPoint> getInjectionPoints();
}]]></programlisting>

      <para>
         It's possible to implement the <literal>Bean</literal> interface and register instances by calling
         <literal>AfterBeanDiscovery.addBean()</literal> (<literal>AfterBeanDiscovery</literal> is a built-in event type
         that an extension can observe) to provide support for new kinds of beans, beyond those defined by the CDI
         specification. For example, we could use the <literal>Bean</literal> interface to allow objects managed by
         another framework to be injected into beans.
      </para>
    
      <para>
         There are two subinterfaces of <literal>Bean</literal> defined by the CDI specification:
         <literal>Interceptor</literal> and <literal>Decorator</literal>.
      </para>
    
   </section>

   <section>
      <title>The <literal>Context</literal> interface</title>
    
      <para>
         The <literal>Context</literal> interface supports addition of new scopes to CDI, or extension of the built-in
         scopes to new environments.
      </para>
    
<programlisting role="JAVA"><![CDATA[public interface Context {
   public Class<? extends Annotation> getScope();
   public <T> T get(Contextual<T> contextual, CreationalContext<T> creationalContext);
   public <T> T get(Contextual<T> contextual);
   boolean isActive();
}]]></programlisting>

      <para>
         For example, we might implement <literal>Context</literal> to add a business process scope to CDI, or to add
         support for the conversation scope to an application that uses Wicket.
      </para>
    
   </section>

  <!--
  TODO finish me!
  -->
  
<!--
vim:et:ts=3:sw=3:tw=120
-->
</chapter>
