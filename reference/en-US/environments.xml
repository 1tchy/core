<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.3//EN"
   "http://www.oasis-open.org/docbook/xml/4.3/docbookx.dtd"  [ ]>
<chapter id="environments">
   <title>Application servers and environments supported by Weld</title>

   <section>
      <title>Using Weld with JBoss AS</title>
      
      <para>
         If you are using JBoss AS 5.2, no additional configuration is required to use Weld (or CDI for that matter).
         All you need to do is make your application a bean bean archive by adding <literal>META-INF/beans.xml</literal>
         to the classpath or <literal>WEB-INF/beans.xml</literal> to the web root!
      </para>
      
      <para>
         If you aren't on JBoss AS 5.2 yet, you can still use Weld with a JBoss AS 5.1 installation. Read on to learn
         how to install Weld as an add-on to JBoss AS 5.1 or upgrade the built-in support on JBoss AS 5.2.
      </para>
         
      <para>
         Installing Weld as an add-on is easy. The Weld distribution has a build that can take care of this task for you
         in a single command. You can also use this script to update the version of Weld deployed to JBoss AS (even if
         you already have JBoss AS 5.2).
      </para>
      
      <para>
         First, we need to tell Weld where JBoss AS is located. Create a new file named
         <literal>local.build.properties</literal> in the examples directory of the Weld distribution and assign the
         path of your JBoss AS installation to the property key <literal>jboss.home</literal>, as follows:
      </para>

      <programlisting><![CDATA[jboss.home=/path/to/jboss-as-5.x]]></programlisting>

      <para>
         Now we can install the Weld deployer from the <literal>jboss-as</literal> directory of the Weld distribution:
      </para>
      
      <programlisting>$> cd jboss-as
$> ant update</programlisting>

      <note>
         <para>
            A new deployer, <literal>weld.deployer</literal> is added to JBoss AS. This adds supports for JSR-299
            deployments to JBoss AS, and allows Weld to query the EJB 3 container and discover which EJBs are installed
            in your application. It also performs a necessary upgrade of the Javassist library.
         </para>
      </note>

   </section>
   
   <section>
      <title>GlassFish</title>
      
      <para>
         Weld is also built into GlassFish from V3 onwards. Since GlassFish V3 is the Java EE 6 reference
         implementation, it must support all features of CDI. What better way for it to support these features than to
         use Weld, the JSR-299 reference implementation? Just package up your CDI application and deploy.
      </para>
   </section>
   
   <section>
      <title>Servlet containers (such as Tomcat or Jetty)</title>
      
      <para>
         While JSR-299 does not require support for servlet environments, Weld can be used in any servlet container,
         such as Tomcat 6.0 or Jetty 6.1.
      </para>
      
      <note>
         <para>
            There is a major limitation to using a servlet container. Weld doesn't support deploying session beans,
            injection using <literal>@EJB</literal> or <literal>@PersistenceContext</literal>, or using transactional
            events in servlet containers. For enterprise features such as these, you should really be looking at a Java
            EE application server.
         </para>
      </note>
      
      <para>
         Weld should be used as a web application library in a servlet container. You should place
         <literal>weld-servlet.jar</literal> in <literal>WEB-INF/lib</literal> in the web root.
         <literal>weld-servlet.jar</literal> is an "uber-jar", meaning it bundles all the bits of Weld and CDI required
         for running in a servlet container, provided for your convenience. Alternatively, you could use its component
         jars: 
      </para>
      
      <!-- TODO check for accuracy in 1.0 release -->
      <itemizedlist>
         <listitem>
            <para>
               <literal>jsr299-api.jar</literal>
            </para>
         </listitem>
         <listitem>
            <para>
               <literal>weld-api.jar</literal>
            </para>
         </listitem>
         <listitem>
            <para>
               <literal>weld-spi.jar</literal>
            </para>
         </listitem>
         <listitem>
            <para>
               <literal>weld-core.jar</literal>
            </para>
         </listitem>
         <listitem>
            <para>
               <literal>weld-logging.jar</literal>
            </para>
         </listitem>
         <listitem>
            <para>
               <literal>weld-servlet-int.jar</literal>
            </para>
         </listitem>
         <listitem>
            <para>
               <literal>javassist.jar</literal>
            </para>
         </listitem>
         <listitem>
            <para>
               <literal>dom4j.jar</literal>
            </para>
         </listitem>
         <listitem>
            <para>
               <literal>google-collections.jar</literal>
            </para>
         </listitem>
      </itemizedlist>
      
      <para>
         You also need to explicitly specify the servlet listener (used to boot Weld, and control its interaction
         with requests) in <literal>WEB-INF/web.xml</literal> in the web root:
      </para>
         
      <programlisting role="XML"><![CDATA[<listener>
   <listener-class>org.jboss.weld.environment.servlet.Listener</listener-class>
</listener>]]></programlisting>

      <section>
         <title>Tomcat</title>

         <para>
            Tomcat has a read-only JNDI, so Weld can't automatically bind the BeanManager extension SPI. To bind
            the BeanManager into JNDI, you should populate <literal>META-INF/context.xml</literal> in the web root with
            the following contents:
         </para>
      
         <programlisting role="XML"><![CDATA[<Context>
   <Resource name="BeanManager" 
      auth="Container"
      type="javax.enterprise.inject.spi.BeanManager"
      factory="org.jboss.weld.resources.ManagerObjectFactory"/>
</Context>]]></programlisting>

         <para>
            and make it available to your deployment by adding this to the bottom of <literal>web.xml</literal>:
         </para>
      
         <programlisting role="XML"><![CDATA[<resource-env-ref>
   <resource-env-ref-name>BeanManager</resource-env-ref-name>
   <resource-env-ref-type>
      javax.enterprise.inject.spi.BeanManager
   </resource-env-ref-type>
</resource-env-ref>]]></programlisting>

         <para>
            Tomcat only allows you to bind entries to <literal>java:comp/env</literal>, so the BeanManager will be
            available at <literal>java:comp/env/BeanManager</literal>
         </para>
      
         <para>
            Weld also supports Servlet injection in Tomcat. To enable this, place the
            <literal>weld-tomcat-support.jar</literal> in <literal>$TOMCAT_HOME/lib</literal>, and add the following to
            <literal>META-INF/context.xml</literal>:
         </para>
      
         <programlisting role="XML"><![CDATA[<Listener className="org.jboss.weld.environment.tomcat.WeldLifecycleListener"/>]]></programlisting>
         
      </section>

      <section>
         <title>Jetty</title>

         <para>
            Like Tomcat, Jetty has a read-only JNDI, so Weld can't automatically bind the Manager. To bind the Manager
            to JNDI, you should populate <literal>WEB-INF/jetty-env.xml</literal> with the following contents:
         </para>
      
         <programlisting role="XML"><![CDATA[<!DOCTYPE Configure PUBLIC "-//Mort Bay Consulting//DTD Configure//EN"
   "http://jetty.mortbay.org/configure.dtd">
<Configure id="webAppCtx" class="org.mortbay.jetty.webapp.WebAppContext">
   <New id="BeanManager" class="org.mortbay.jetty.plus.naming.Resource">
      <Arg><Ref id="webAppCtx"/></Arg> 
      <Arg>BeanManager</Arg>
      <Arg>
         <New class="javax.naming.Reference">
            <Arg>javax.enterprise.inject.spi.BeanManager</Arg> 
            <Arg>org.jboss.weld.resources.ManagerObjectFactory</Arg>
            <Arg/>
         </New>
      </Arg>
   </New>
</Configure>]]></programlisting>

         <para>
            Notice that Jetty doesn't not have built-in support for an <literal>javax.naming.spi.ObjectFactory</literal>
            like Tomcat, so it's necessary to manually create the <literal>javax.naming.Reference</literal> to wrap
            around it.
         </para>

         <para>
            Jetty only allows you to bind entries to <literal>java:comp/env</literal>, so the BeanManager will be
            available at <literal>java:comp/env/BeanManager</literal>
         </para>

         <para>
            Weld does not currently support Servlet injection in Jetty.
         </para>

      </section>

   </section>
   
   <section>
      <title>Java SE</title>
      
      <para>
         In addition to improved integration of the Enterprise Java stack, the "Contexts and Dependency Injection for
         the Java EE platform" specification also defines a state of the art typesafe, stateful dependency injection
         framework, which can prove useful in a wide range of application types. To help developers take advantage of
         this, Weld provides a simple means for being executed in the Java Standard Edition (SE) environment
         independently of any Java EE APIs.
      </para>

      <para>
         When executing in the SE environment the following features of Weld are available:
      </para>

      <itemizedlist>
         <listitem>
            <para>
               <literal>POJOs (no EJBs)</literal>
            </para>
         </listitem>
         <listitem>
            <para>
               <literal>Typesafe Dependency Injection</literal>
            </para>
         </listitem>
         <listitem>
            <para>
               <literal>Application and Dependent Contexts</literal>
            </para>
         </listitem>
         <listitem>
            <para>
               <literal>Qualifiers</literal>
            </para>
         </listitem>
         <listitem>
            <para>
               <literal>Stereotypes</literal>
            </para>
         </listitem>
         <listitem>
            <para>
               <literal>Typesafe Event Model</literal>
            </para>
         </listitem>
      </itemizedlist>

      <section id="weld-se">
         <title>CDI SE Module</title>

         <para>
            Weld provides an extension which will boot a CDI bean manager in Java SE, automatically registering all
            simple beans found on the classpath. Application developers need not write any bootstrapping code. The entry
            point for application code is a simple bean which observes the special
            <literal>ContainerInitialized</literal> event provided by this extension. The command line parameters can be
            injected using either of the following:
         </para>
         <programlisting role="JAVA"><![CDATA[@Inject @Parameters List<String> params;
@Inject @Parameters String[] paramsArray; // useful for compatability with existing classes]]></programlisting>

         <para>
            Here's an example of a simple CDI SE application:
         </para>

         <programlisting role="JAVA"><![CDATA[@ApplicationScoped
public class HelloWorld
{
   @Inject @Parameters List<String> parameters;

   public void printHello(@Observes ContainerInitialized event) {
       System.out.println("Hello " + parameters.get(0));
   }
}]]></programlisting>

         <para>
            CDI SE applications can be bootstrapped by running the StartMain class like so:
         </para>

         <programlisting role="JAVA"><![CDATA[java org.jboss.weld.environments.se.StartMain <args>]]></programlisting>

         <para>
            If you need to do any custom initialization of the CDI bean manager, for example registering custom contexts
            or initializing resources for your beans you can do so in response to the
            <literal>AfterBeanDiscovery</literal> or <literal>AfterDeploymentValidation</literal> events. The following
            example registers a custom context:
         </para>
          
         <programlisting role="JAVA"><![CDATA[public class PerformSetup {
   public void setup(@Observes AfterBeanDiscovery event) {
      event.addContext( ThreadContext.INSTANCE );
   }
}]]></programlisting>

         <note>
            <para>
               The command line parameters do not become available for injection until the
               <literal>ContainerInitialized</literal> event is fired. If you need access to the parameters during
               initialization you can do so via the <literal>public static String[] getParameters()</literal> method in
               <literal>StartMain</literal>.
            </para>
         </note>

      </section>

   </section>

<!--
vim:et:ts=3:sw=3:tw=120
-->
</chapter>
