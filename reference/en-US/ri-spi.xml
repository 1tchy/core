<!DOCTYPE appendix PUBLIC "-//OASIS//DTD DocBook XML V4.3//EN" "http://www.oasis-open.org/docbook/xml/4.3/docbookx.dtd"  [ ]>

<appendix id="ri-spi">
   <title>Integrating the Web Beans RI into other environments</title>

    <para>
      Currently the Web Beans RI only runs in JBoss AS 5; integrating the RI 
      into other EE environments (for example another application server like
      Glassfish), into a servlet container (like Tomcat), or with an
      Embedded EJB3.1 implementation is fairly easy. In this Appendix we will
      briefly discuss the steps needed. 
    </para>
    
    <note>
      <para>
         It should be possible to run Web Beans in an SE environment, but 
         you'll to do more work, adding your own contexts and lifecycle. The
         Web Beans RI currently doesn't expose lifecycle extension points, so
         you would have to code directly against Web Beans RI classes.
      </para>
    </note>
    
    <section>
      <title>The Web Beans RI SPI</title>
      
      <para>
         The Web Beans SPI is located in <literal>webbeans-ri-spi</literal>
         module, and packaged as <literal>webbeans-ri-spi.jar</literal>. Some
         SPIs are optional, if you need to override the default behavior, 
         others are required.
      </para>
       
       <para>
         All interfaces in the SPI support the decorator pattern and provide a
         <literal>Forwarding</literal> class.
       </para>
      
      <section>
         <title>Web Bean Discovery</title>
      
         <programlisting role="JAVA"><![CDATA[public interface WebBeanDiscovery {
   /**
    * Gets list of all classes in classpath archives with web-beans.xml files
    * 
    * @return An iterable over the classes 
    */
   public Iterable<Class<?>> discoverWebBeanClasses();
   
   /**
    * Gets a list of all web-beans.xml files in the app classpath
    * 
    * @return An iterable over the web-beans.xml files 
    */
   public Iterable<URL> discoverWebBeansXml();
   
}]]></programlisting>

         <para>
            The discovery of Web Bean classes and <literal>web-bean.xml</literal> 
            files is self-explanatory (the algorithm is described in Section 11.1 
            of the JSR-299 specification, and isn't repeated here).
         </para>
         
      </section>
      
      <section>
         <title>EJB Discovery</title>
         
         <para>
            The Web Beans RI also delegates EJB3 bean discovery to the container
            so that it doesn't have to scan for EJB3 annotations or parse
            <literal>ejb-jar.xml</literal>. For each EJB in the application an
            EJBDescriptor should be discovered:
         </para>
         
         <programlisting role="JAVA"><![CDATA[public interface EjbDiscovery
{
   public static final String PROPERTY_NAME = EjbDiscovery.class.getName();
   
   /**
    * Gets a descriptor for each EJB in the application
    * 
    * @return The bean class to descriptor map 
    */
   public Iterable<EjbDescriptor<?>> discoverEjbs();
   
}]]></programlisting>
         
         <programlisting role="JAVA"><![CDATA[public interface EjbDescriptor<T> {
   
   /**
    * Gets the EJB type
    * 
    * @return The EJB Bean class
    */
   public Class<T> getType();

   /**
    * Gets the local business interfaces of the EJB
    * 
    * @return An iterator over the local business interfaces
    */
   public Iterable<BusinessInterfaceDescriptor<?>> getLocalBusinessInterfaces();
   
   /**
    * Gets the remote business interfaces of the EJB
    * 
    * @return An iterator over the remote business interfaces
    */
   public Iterable<BusinessInterfaceDescriptor<?>> getRemoteBusinessInterfaces();
   
   /**
    * Get the remove methods of the EJB
    * 
    * @return An iterator over the remove methods
    */
   public Iterable<Method> getRemoveMethods();

   /**
    * Indicates if the bean is stateless
    * 
    * @return True if stateless, false otherwise
    */
   public boolean isStateless();

   /**
    * Indicates if the bean is a EJB 3.1 Singleton
    * 
    * @return True if the bean is a singleton, false otherwise
    */
   public boolean isSingleton();

   /**
    * Indicates if the EJB is stateful
    * 
    * @return True if the bean is stateful, false otherwise
    */
   public boolean isStateful();

   /**
    * Indicates if the EJB is and MDB
    * 
    * @return True if the bean is an MDB, false otherwise
    */
   public boolean isMessageDriven();

   /**
    * Gets the EJB name
    * 
    * @return The name
    */
   public String getEjbName();
   
   
}]]></programlisting>
      
          <para>
             The <literal>EjbDescriptor</literal> is fairly self-explanatory,
             and should return the relevant metadata as defined in the EJB 
             specification. In addition to these two interfaces, there is 
             <literal>BusinessInterfaceDescriptor</literal> which represents a 
             local business interface (encapsulating the interface class and 
             jndi name used to look up an instance of the EJB).
          </para>
       
       </section>
       
       <section>
         <title><literal>@EJB</literal>, <literal>@PersistenceContext</literal> and <literal>@Resource</literal> resolution</title>
         
         <para>
            The resolution of <literal>@EJB</literal>, 
            <literal>@PersistenceContext</literal> and 
            <literal>@Resource</literal> is delegated to the container. You must
            provide an implementation of 
            <literal>org.jboss.webbeans.ejb.spi.EjbResolver</literal> which 
            provides these operations. Web Beans passes in the 
            <literal>javax.inject.manager.InjectionPoint</literal> the 
            resolution is for, as well as the <literal>NamingContext</literal> 
            in use for each resolution request.
         </para>
         
       </section>
       
       <section>
         <title>The application context</title>
         
         <para>
            Web Beans expects the Application Server or other container to 
            provide the storage for each application's context. The
            <literal>org.jboss.webbeans.context.api.BeanStore</literal> should 
            be implemented to provide an application scoped storage. You may
            find 
            <literal>org.jboss.webbeans.context.api.helpers.ConcurrentHashMapBeanStore</literal>
            useful.
         </para>
         
       </section>
       
       <section>
         <title>Bootstrap and shutdown</title>
         <para>
            The <literal>org.jboss.webbeans.bootstrap.api.Bootstrap</literal>
            interface defines the bootstrap for Web Beans. To boot Web Beans, 
            you must obtain an instance of 
            <literal>org.jboss.webbeans.bootstrap.WebBeansBootstrap</literal>
            (which implements <literal>Boostrap</literal>), tell it about the
            SPIs in use, and then request the container start.
         </para>
         
         <para>
            The bootstrap is split into phases, bootstrap initialization and 
            bootstrap. Initialization will create a manager, and add the 
            standard (specification defined) contexts. Bootstrap will discover
            EJBs, classes and XML; add beans defined using annotations; add
            beans defined using XML; and validate all beans.
         </para>
         
         <para>
            To initialize the bootstrap you call 
            <literal>Bootstrap.initialize()</literal>. Before calling 
            <literal>initialize()</literal> you must have called 
            <literal>Bootstrap.setEjbResolver()</literal>. If you are not using 
            the built in <literal>DefaultNamingContext</literal> or the built in
            <literal>DefaultResourceLoader</literal> you must set these before
            calling <literal>initialize()</literal>.
         </para>
         
         <para>
            Having called <literal>initialize()</literal>, the 
            <literal>Manager</literal> can be obtained by calling 
            <literal>Bootstrap.getManager()</literal>.
         </para>
         
         <para>
            To boot the container you call <literal>Bootstrap.boot()</literal>.
            Before calling <literal>boot()</literal> you must have called 
            <literal>Bootstrap.setWebBeanDiscovery()</literal>, 
            <literal>Bootstrap.setEjbDiscovery()</literal> and 
            <literal>Bootstrap.setApplicationContext()</literal>. 
         </para>
         
         <para>
            To shutdown the container you call 
            <literal>Bootstrap.shutdown()</literal>. This allows the container 
            to perform any cleanup operations needed.
         </para>
         
       </section>
       
       <section>
         <title>JNDI</title>
         
         <para>
            The Web Beans RI implements JNDI binding and lookup according to
            standards, however you may want to alter the binding and lookup (for
            example in an environment where JNDI isn't available). To do this,
            implement 
            <literal>org.jboss.webbeans.resources.spi.NamingContext</literal>:
         </para>
         
         <programlisting role="JAVA"><![CDATA[public interface NamingContext extends Serializable {
   
   /**
    * Typed JNDI lookup
    * 
    * @param <T> The type
    * @param name The JNDI name
    * @param expectedType The expected type
    * @return The object
    */
   public <T> T lookup(String name, Class<? extends T> expectedType);

   /**
    * Binds an item to JNDI
    * 
    * @param name The key to bind under
    * @param value The item to bind
    */
   public void bind(String name, Object value);
   
}]]></programlisting>

       </section>
       
       <section>
         <title>Resource loading</title>
         
         <para>
            The Web Beans RI needs to load classes and resources from the 
            classpath at various times. By default, they are loaded from the 
            same classloader that was used to load the RI, however this may not
            be correct for some environments. If this is case, you can implement
            <literal>org.jboss.webbeans.spi.ResourceLoader</literal>:
         </para>
         
         <programlisting role="JAVA"><![CDATA[
         public interface ResourceLoader {
    
   /**
    * Creates a class from a given FQCN
    * 
    * @param name The name of the clsas
    * @return The class
    */
   public Class<?> classForName(String name);
   
   /**
    * Gets a resource as a URL by name
    * 
    * @param name The name of the resource
    * @return An URL to the resource
    */
   public URL getResource(String name);
   
   /**
    * Gets resources as URLs by name
    * 
    * @param name The name of the resource
    * @return An iterable reference to the URLS
    */
   public Iterable<URL> getResources(String name);
   
}
         ]]></programlisting>

       </section>
   
    </section>
    
    <section>
      <title>The contract with the container</title>
      
      <para>
         There are a number of requirements that the Web Beans RI places on the
         container for correct functioning that fall outside implementation of
         APIs
      </para>
      
      <variablelist>
         <varlistentry>
            <term>
               Classloader isolation
            </term>
            <listitem>
               <para>
                  If you are integrating the Web Beans RI into an environment 
                  that supports deployment of multiple applications, you must 
                  enable, automatically, or through user configuation, 
                  classloader isolation for each Web Beans application.
               </para>
            </listitem>
         </varlistentry>
         <varlistentry>
            <term>
               Servlet listener
            </term>
            <listitem>
               <para>
                  If you are integrating the Web Beans into a Servlet 
                  environment you must register 
                  <literal>org.jboss.webbeans.servlet.WebBeansListener</literal>
                  as a Servlet listener, either automatically, or through user
                  configuration, for each Web Beans application which uses 
                  Servlet.
               </para>
            </listitem>
         </varlistentry>
         <varlistentry>
            <term>
               Session Bean Interceptor
            </term>
            <listitem>
               <para>
                  If you are integrating the Web Beans into an EJB 
                  environment you must register 
                  <literal>org.jboss.webbeans.ejb.SessionBeanInterceptor</literal>
                  as a EJB interceptor for all EJBs in the application, either 
                  automatically, or through user configuration, for each Web 
                  Beans application which uses enterprise beans.
               </para>
            </listitem>
         </varlistentry>
         <varlistentry>
            <term>
               The <literal>webbeans-ri.jar</literal>
            </term>
            <listitem>
               <para>
                  If you are integrating the Web Beans into an environment that
                  supports deployment of applications, you must insert the
                  <literal>webbeans-ri.jar</literal> into the applications
                  isolated classloader. It cannot be loaded from a shared 
                  classloader.
               </para>
            </listitem>
         </varlistentry>
      </variablelist>
    </section>

</appendix>