<!DOCTYPE appendix PUBLIC "-//OASIS//DTD DocBook XML V4.3//EN" "http://www.oasis-open.org/docbook/xml/4.3/docbookx.dtd"  [ ]>

<appendix id="ri-spi">
   <title>Integrating the Web Beans RI into other environments</title>

    <para>
      Currently the Web Beans RI only runs in JBoss AS 5; integrating the RI 
      into other EE environments (for example another application server like
      Glassfish), into a servlet container (like Tomcat), or with an
      Embedded EJB3.1 implementation is fairly easy. In this Appendix we will
      briefly discuss the steps needed. 
    </para>
    
    <note>
      <para>
         It should be possible to run Web Beans in an SE environment, but 
         you'll to do more work, adding your own contexts and lifecycle. The
         Web Beans RI currently doesn't expose lifecycle extension points, so
         you would have to code directly against Web Beans RI classes.
      </para>
    </note>
    
    <section>
      <title>The Web Beans RI SPI</title>
      
      <para>
         The Web Beans SPI is located in <literal>webbeans-ri-spi</literal>
         module, and packaged as <literal>webbeans-ri-spi.jar</literal>. Some
         SPIs are optional, if you need to override the default behavior, 
         others are required.
      </para>
       
       <para>
         All interfaces in the SPI support the decorator pattern and provide a
         <literal>Forwarding</literal> class.
       </para>
      
      <section>
         <title>Web Bean Discovery</title>
      
         <programlisting role="JAVA"><![CDATA[public interface WebBeanDiscovery {
   /**
    * Gets list of all classes in classpath archives with web-beans.xml files
    * 
    * @return An iterable over the classes 
    */
   public Iterable<Class<?>> discoverWebBeanClasses();
   
   /**
    * Gets a list of all web-beans.xml files in the app classpath
    * 
    * @return An iterable over the web-beans.xml files 
    */
   public Iterable<URL> discoverWebBeansXml();
   
}]]></programlisting>

         <para>
            The discovery of Web Bean classes and <literal>web-bean.xml</literal> 
            files is self-explanatory (the algorithm is described in Section 11.1 
            of the JSR-299 specification, and isn't repeated here).
         </para>
         
      </section>
       
       <section>
         <title>EJB services</title>
         
         <para>
            The Web Beans RI also delegates EJB3 bean discovery to the container
            so that it doesn't have to scan for EJB3 annotations or parse
            <literal>ejb-jar.xml</literal>. For each EJB in the application an
            EJBDescriptor should be discovered:
         </para>
         
         <programlisting role="JAVA"><![CDATA[public interface EjbServices
{
   
   /**
    * Gets a descriptor for each EJB in the application
    * 
    * @return The bean class to descriptor map 
    */
   public Iterable<EjbDescriptor<?>> discoverEjbs();]]></programlisting>
         
         <programlisting role="JAVA"><![CDATA[public interface EjbDescriptor<T> {
   
   /**
    * Gets the EJB type
    * 
    * @return The EJB Bean class
    */
   public Class<T> getType();

   /**
    * Gets the local business interfaces of the EJB
    * 
    * @return An iterator over the local business interfaces
    */
   public Iterable<BusinessInterfaceDescriptor<?>> getLocalBusinessInterfaces();
   
   /**
    * Gets the remote business interfaces of the EJB
    * 
    * @return An iterator over the remote business interfaces
    */
   public Iterable<BusinessInterfaceDescriptor<?>> getRemoteBusinessInterfaces();
   
   /**
    * Get the remove methods of the EJB
    * 
    * @return An iterator over the remove methods
    */
   public Iterable<Method> getRemoveMethods();

   /**
    * Indicates if the bean is stateless
    * 
    * @return True if stateless, false otherwise
    */
   public boolean isStateless();

   /**
    * Indicates if the bean is a EJB 3.1 Singleton
    * 
    * @return True if the bean is a singleton, false otherwise
    */
   public boolean isSingleton();

   /**
    * Indicates if the EJB is stateful
    * 
    * @return True if the bean is stateful, false otherwise
    */
   public boolean isStateful();

   /**
    * Indicates if the EJB is and MDB
    * 
    * @return True if the bean is an MDB, false otherwise
    */
   public boolean isMessageDriven();

   /**
    * Gets the EJB name
    * 
    * @return The name
    */
   public String getEjbName();
   
   
}]]></programlisting>
      
          <para>
             The <literal>EjbDescriptor</literal> is fairly self-explanatory,
             and should return the relevant metadata as defined in the EJB 
             specification. In addition to these two interfaces, there is 
             <literal>BusinessInterfaceDescriptor</literal> which represents a 
             local business interface (encapsulating the interface class and 
             jndi name used to look up an instance of the EJB).
          </para>
         
         <para>
            The resolution of <literal>@EJB</literal> and
            <literal>@Resource</literal> is delegated to the container. You must
            provide an implementation of 
            <literal>org.jboss.webbeans.ejb.spi.EjbServices</literal> which 
            provides these operations. Web Beans passes in the 
            <literal>javax.inject.manager.InjectionPoint</literal> the 
            resolution is for, as well as the <literal>NamingContext</literal> 
            in use for each resolution request.
         </para>
         
<!--         <para>-->
<!--            JSR-299 also requires that when the <literal>Bean.destroy()</literal>-->
<!--            is called on a session bean that the container removes the stateful-->
<!--            session bean. As there is no specified way of doing this, the-->
<!--            <literal>EjbResolver.removeEjb()</literal> method is used by Web -->
<!--            Beans to request the EJB container remove a stateful session bean.-->
<!--            Web Beans assumes that the EJB container will invoke any-->
<!--            <literal>@PreDestroy</literal> lifecycle callbacks.-->
<!--         </para>-->
         
      </section>
       
      <section>
         <title>JPA services</title>
         
         <para>
            Just as resolution of <literal>@EJB</literal> is delegated to the
            container, so is resolution of 
            <literal>@PersistenceContext</literal>.
         </para>
         
         <para>
             OPEN ISSUE: Web Beans also requires the container to provide a list
             of entities in the deployment, so that they aren't discovered as
             simple beans.
         </para>
      </section>
       
      <section>
         <title>Transaction Services</title>
         
         <para>
            The Web Beans RI must delegate JTA activities to the container.
            The SPI provides a couple hooks to easily achieve this with the
            <literal>TransactionServices</literal> interface.
         </para>
         
         <programlisting role="JAVA"><![CDATA[public interface TransactionServices
{
   /**
    * Possible status conditions for a transaction. This can be used by SPI
    * providers to keep track for which status an observer is used.
    */
   public static enum Status
   {
      ALL, SUCCESS, FAILURE
   }

   /**
    * Registers a synchronization object with the currently executing
    * transaction.
    * 
    * @see javax.transaction.Synchronization
    * @param synchronizedObserver
    */
   public void registerSynchronization(Synchronization synchronizedObserver);

   /**
    * Queries the status of the current execution to see if a transaction is
    * currently active.
    * 
    * @return true if a transaction is active
    */
   public boolean isTransactionActive();
}]]></programlisting>
         
      <para>
        The enumeration <literal>Status</literal> is a convenience for implementors
        to be able to keep track of whether a synchronization is supposed to notify
        an observer only when the transaction is successful, or after a failure, or
        regardless of the status of the transaction.
      </para>
      
      <para>
      	Any <literal>javax.transaction.Synchronization</literal> implementation
      	may be passed to the <literal>registerSynchronization()</literal> method
      	and the SPI implementation should immediately register the synchronization
      	with the JTA transaction manager used for the EJBs.
      </para>
      
      <para>
      	To make it easier to determine whether or not a transaction is currently
      	active for the requesting thread, the <literal>isTransactionActive()</literal>
      	method can be used.  The SPI implementation should query the same
      	JTA transaction manager used for the EJBs.
      </para>
    </section>
    
       <section>
         <title>The application context</title>
         
         <para>
            Web Beans expects the Application Server or other container to 
            provide the storage for each application's context. The
            <literal>org.jboss.webbeans.context.api.BeanStore</literal> should 
            be implemented to provide an application scoped storage. You may
            find 
            <literal>org.jboss.webbeans.context.api.helpers.ConcurrentHashMapBeanStore</literal>
            useful.
         </para>
         
       </section>
       
       <section>
         <title>Bootstrap and shutdown</title>
         <para>
            The <literal>org.jboss.webbeans.bootstrap.api.Bootstrap</literal>
            interface defines the bootstrap for Web Beans. To boot Web Beans, 
            you must obtain an instance of 
            <literal>org.jboss.webbeans.bootstrap.WebBeansBootstrap</literal>
            (which implements <literal>Boostrap</literal>), tell it about the
            SPIs in use, and then request the container start.
         </para>
         
         <para>
            The bootstrap is split into phases, bootstrap initialization and 
            boot and shutdown. Initialization will create a manager, and add the 
            standard (specification defined) contexts. Bootstrap will discover
            EJBs, classes and XML; add beans defined using annotations; add
            beans defined using XML; and validate all beans.
         </para>
         
         <para>
            The bootstrap supports multiple environments. Different environments
            require different services to be present (for example servlet 
            doesn't require transaction, EJB or JPA services). By default an
            EE environment is assumed, but you can adjust the environment by 
            calling <literal>bootstrap.setEnvironment()</literal>.
         </para>
         
         <para>
            To initialize the bootstrap you call 
            <literal>Bootstrap.initialize()</literal>. Before calling 
            <literal>initialize()</literal>, you must register any services
            required by your environment. You can do this by calling
            <literal>bootstrap.getServices().add(JpaServices.class, new MyJpaServices())</literal>.
            You must also provide the application context bean store.
         </para>
         
         <para>
            Having called <literal>initialize()</literal>, the 
            <literal>Manager</literal> can be obtained by calling 
            <literal>Bootstrap.getManager()</literal>.
         </para>
         
         <para>
            To boot the container you call <literal>Bootstrap.boot()</literal>.
         </para>
         
         <para>
            To shutdown the container you call 
            <literal>Bootstrap.shutdown()</literal>. This allows the container 
            to perform any cleanup operations needed.
         </para>
         
       </section>
       
       <section>
         <title>JNDI</title>
         
         <para>
            The Web Beans RI implements JNDI binding and lookup according to
            standards, however you may want to alter the binding and lookup (for
            example in an environment where JNDI isn't available). To do this,
            implement 
            <literal>org.jboss.webbeans.resources.spi.NamingContext</literal>:
         </para>
         
         <programlisting role="JAVA"><![CDATA[public interface NamingContext extends Serializable {
   
   /**
    * Typed JNDI lookup
    * 
    * @param <T> The type
    * @param name The JNDI name
    * @param expectedType The expected type
    * @return The object
    */
   public <T> T lookup(String name, Class<? extends T> expectedType);

   /**
    * Binds an item to JNDI
    * 
    * @param name The key to bind under
    * @param value The item to bind
    */
   public void bind(String name, Object value);
   
}]]></programlisting>

       </section>
       
       <section>
         <title>Resource loading</title>
         
         <para>
            The Web Beans RI needs to load classes and resources from the 
            classpath at various times. By default, they are loaded from the 
            same classloader that was used to load the RI, however this may not
            be correct for some environments. If this is case, you can implement
            <literal>org.jboss.webbeans.spi.ResourceLoader</literal>:
         </para>
         
         <programlisting role="JAVA"><![CDATA[
         public interface ResourceLoader {
    
   /**
    * Creates a class from a given FQCN
    * 
    * @param name The name of the clsas
    * @return The class
    */
   public Class<?> classForName(String name);
   
   /**
    * Gets a resource as a URL by name
    * 
    * @param name The name of the resource
    * @return An URL to the resource
    */
   public URL getResource(String name);
   
   /**
    * Gets resources as URLs by name
    * 
    * @param name The name of the resource
    * @return An iterable reference to the URLS
    */
   public Iterable<URL> getResources(String name);
   
}
         ]]></programlisting>

       </section>
       
       <section>
         <title>Servlet injection</title>
         
         <para>
            Java EE / Servlet does not provide any hooks which can be used to 
            provide injection into Servlets, so Web Beans provides an API to 
            allow the container to request JSR-299 injection for a Servlet.
         </para>
         
         <para>
            To be compliant with JSR-299, the container should request servlet
            injection for each newly instantiated servlet after the constructor
            returns and before the servlet is placed into service.
         </para>
         
         <para>
            To perform injection on a servlet call 
            <literal>WebBeansManager.injectServlet()</literal>. The manager
            can be obtained from <literal>Bootstrap.getManager()</literal>.
         </para>
         
       </section>
   
    </section>
    
    <section>
      <title>The contract with the container</title>
      
      <para>
         There are a number of requirements that the Web Beans RI places on the
         container for correct functioning that fall outside implementation of
         APIs
      </para>
      
      <variablelist>
         <varlistentry>
            <term>
               Classloader isolation
            </term>
            <listitem>
               <para>
                  If you are integrating the Web Beans RI into an environment 
                  that supports deployment of multiple applications, you must 
                  enable, automatically, or through user configuation, 
                  classloader isolation for each Web Beans application.
               </para>
            </listitem>
         </varlistentry>
         <varlistentry>
            <term>
               Servlet listener and filters
            </term>
            <listitem>
               <para>
                  If you are integrating the Web Beans into a Servlet 
                  environment you must register 
                  <literal>org.jboss.webbeans.servlet.WebBeansListener</literal>
                  as a Servlet listener, either automatically, or through user
                  configuration, for each Web Beans application which uses 
                  Servlet.
               </para>
               
               <para>
                  If you are integrating the Web Beans into a JSF environment 
                  you must register 
                  <literal>org.jboss.webbeans.servlet.ConversationPropagationFilter</literal>
                  as a Servlet listener, either automatically, or through user
                  configuration, for each Web Beans application which uses 
                  JSF. This filter can be registered for all Servlet deployment
                  safely.
               </para>
            </listitem>
         </varlistentry>
         <varlistentry>
            <term>
               Session Bean Interceptor
            </term>
            <listitem>
               <para>
                  If you are integrating the Web Beans into an EJB 
                  environment you must register 
                  <literal>org.jboss.webbeans.ejb.SessionBeanInterceptor</literal>
                  as a EJB interceptor for all EJBs in the application, either 
                  automatically, or through user configuration, for each Web 
                  Beans application which uses enterprise beans.
               </para>
               
               <important>
                  <para>
                     You must register the <literal>SessionBeanInterceptor</literal>
                     as the inner most interceptor in the stack for all EJBs. 
                  </para>
               </important>
            </listitem>
         </varlistentry>
         <varlistentry>
            <term>
               The <literal>webbeans-core.jar</literal>
            </term>
            <listitem>
               <para>
                  If you are integrating the Web Beans into an environment that
                  supports deployment of applications, you must insert the
                  <literal>webbeans-core.jar</literal> into the applications
                  isolated classloader. It cannot be loaded from a shared 
                  classloader.
               </para>
            </listitem>
         </varlistentry>
      </variablelist>
    </section>

</appendix>