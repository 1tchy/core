<!DOCTYPE appendix PUBLIC "-//OASIS//DTD DocBook XML V4.3//EN" "http://www.oasis-open.org/docbook/xml/4.3/docbookx.dtd"  [ ]>

<appendix id="ri-spi">
   <title>Integrating Web Beans into other environments</title>

    <para>
      Currently Web Beans only runs in JBoss AS 5; integrating the RI 
      into other EE environments (for example another application server like
      Glassfish), into a servlet container (like Tomcat), or with an
      Embedded EJB3.1 implementation is fairly easy. In this Appendix we will
      briefly discuss the steps needed. 
    </para>
    
    <section>
      <title>The Web Beans SPI</title>
      
      <para>
         The Web Beans SPI is located in the <literal>webbeans-spi</literal>
         module, and packaged as <literal>webbeans-spi.jar</literal>. Some
         SPIs are optional, if you need to override the default behavior, 
         others are required.
      </para>
       
       <para>
         All interfaces in the SPI support the decorator pattern and provide a
         <literal>Forwarding</literal> class located in the 
         <literal>helpers</literal> sub package. Additional, commonly used,
         utility classes, and standard implementations are also located in the
         <literal>helpers</literal> sub package.
       </para>
      
      <section>
         <title>Web Bean Discovery</title>
      
         <programlisting role="JAVA"><![CDATA[/**
    * Gets list of all classes in classpath archives with META-INF/beans.xml (or
    * for WARs WEB-INF/beans.xml) files
    * 
    * @return An iterable over the classes 
    */
   public Iterable<Class<?>> discoverWebBeanClasses();
   
   /**
    * Gets a list of all deployment descriptors in the app classpath
    * 
    * @return An iterable over the beans.xml files 
    */
   public Iterable<URL> discoverWebBeansXml();]]></programlisting>

         <para>
            The discovery of Web Bean classes and <literal>beans.xml</literal> 
            files is self-explanatory (the algorithm is described in Section 11.1 
            of the JSR-299 specification, and isn't repeated here).
         </para>
         
      </section>
       
       <section>
         <title>EJB services</title>
         
         <note>
         	<para>
         		Web Beans will run without an EJB container; in this case you 
         		don't need to implement the EJB SPI.
         	</para>
         </note>
         
         <para>
            Web Beans also delegates EJB3 bean discovery to the container
            so that it doesn't have to scan for EJB3 annotations or parse
            <literal>ejb-jar.xml</literal>. For each EJB in the application an
            EJBDescriptor should be discovered:
         </para>
         
         <programlisting role="JAVA"><![CDATA[public interface EjbDescriptor<T>
{
   
   /**
    * Gets the EJB type
    * 
    * @return The EJB Bean class
    */
   public Class<T> getType();

   /**
    * Gets the local business interfaces of the EJB
    * 
    * @return An iterator over the local business interfaces
    */
   public Iterable<BusinessInterfaceDescriptor<?>> getLocalBusinessInterfaces();
   
   /**
    * Gets the remote business interfaces of the EJB
    * 
    * @return An iterator over the remote business interfaces
    */
   public Iterable<BusinessInterfaceDescriptor<?>> getRemoteBusinessInterfaces();
   
   /**
    * Get the remove methods of the EJB
    * 
    * @return An iterator over the remove methods
    */
   public Iterable<Method> getRemoveMethods();

   /**
    * Indicates if the bean is stateless
    * 
    * @return True if stateless, false otherwise
    */
   public boolean isStateless();

   /**
    * Indicates if the bean is a EJB 3.1 Singleton
    * 
    * @return True if the bean is a singleton, false otherwise
    */
   public boolean isSingleton();

   /**
    * Indicates if the EJB is stateful
    * 
    * @return True if the bean is stateful, false otherwise
    */
   public boolean isStateful();

   /**
    * Indicates if the EJB is and MDB
    * 
    * @return True if the bean is an MDB, false otherwise
    */
   public boolean isMessageDriven();

   /**
    * Gets the EJB name
    * 
    * @return The name
    */
   public String getEjbName();]]></programlisting>
      
          <para>
             The <literal>EjbDescriptor</literal> is fairly self-explanatory,
             and should return the relevant metadata as defined in the EJB 
             specification. In addition to these two interfaces, there is 
             <literal>BusinessInterfaceDescriptor</literal> which represents a 
             local business interface (encapsulating the interface class and 
             jndi name used to look up an instance of the EJB).
          </para>
         
         <para>
            The resolution of <literal>@EJB</literal> (for injection into simple
            beans), the resolution of local EJBs (for backing session beans) and
            remote EJBs (for injection as a Java EE resource) is delegated to 
            the container. You must provide an implementation of 
            <literal>org.jboss.webbeans.ejb.spi.EjbServices</literal> which 
            provides these operations. For resolving the <literal>@EJB</literal>
            injection point, Web Beans will provide the 
            <literal>InjectionPoint</literal>; for resolving local EJBs, the
            <literal>EjbDescriptor</literal> will be provided, and for remote
            EJBs the <literal>jndiName</literal>, <literal>mappedName</literal>,
            or <literal>ejbLink</literal> will be provided.
         </para>
         
         <para>
	        When resolving local EJBs (used to back session beans) a wrapper
	        (<literal>SessionObjectReference</literal>) around the EJB reference
	        is returned. This wrapper allows Web Beans to request a reference 
	        that implements the given business interface, and, in the case of 
	        SFSBs, request the removal of the EJB from the container.
         </para>
         
      </section>
       
      <section>
         <title>JPA services</title>
         
         <para>
            Just as EJB resolution is delegated to the container, resolution of
            <literal>@PersistenceContext</literal> for injection into simple 
            beans (with the <literal>InjectionPoint</literal> provided),
            and resolution of persistence contexts and persistence units (with 
            the <literal>unitName</literal> provided) for injection as a Java EE
            resource is delegated to the container.
         </para>
         
         <para>
            To allow JPA integration, the <literal>JpaServices</literal> 
            interface should be implemented.
         </para>
         
         <para>
            Web Beans also needs to know what entities are in a deployment (so
            that they aren't managed by Web Beans). An implementation that 
            detects entities through <literal>@Entity</literal> and
            <literal>orm.xml</literal> is provided by default. If you want to
            provide support for a entities defined by a JPA provider (such as
            Hibernate's <literal>.hbm.xml</literal> you can wrap or replace the
            default implementation.
         </para>
         
         <programlisting><![CDATA[EntityDiscovery delegate = bootstrap.getServices().get(EntityDiscovery.class);]]></programlisting>
         
      </section>
       
      <section>
         <title>Transaction Services</title>
         
         <para>
            Web Beans must delegate JTA activities to the container. The SPI 
            provides a couple hooks to easily achieve this with the 
            <literal>TransactionServices</literal> interface.
         </para>
         
         <programlisting role="JAVA"><![CDATA[public interface TransactionServices
{
   /**
    * Possible status conditions for a transaction. This can be used by SPI
    * providers to keep track for which status an observer is used.
    */
   public static enum Status
   {
      ALL, SUCCESS, FAILURE
   }

   /**
    * Registers a synchronization object with the currently executing
    * transaction.
    * 
    * @see javax.transaction.Synchronization
    * @param synchronizedObserver
    */
   public void registerSynchronization(Synchronization synchronizedObserver);

   /**
    * Queries the status of the current execution to see if a transaction is
    * currently active.
    * 
    * @return true if a transaction is active
    */
   public boolean isTransactionActive();
}]]></programlisting>
         
         <para>
            The enumeration <literal>Status</literal> is a convenience for 
            implementors to be able to keep track of whether a synchronization 
            is supposed to notify an observer only when the transaction is 
            successful, or after a failure, or regardless of the status of the 
            transaction.
         </para>
      
         <para>
      	   Any <literal>javax.transaction.Synchronization</literal> 
      	   implementation may be passed to the 
      	   <literal>registerSynchronization()</literal> method and the SPI 
      	   implementation should immediately register the synchronization with 
      	   the JTA transaction manager used for the EJBs.
         </para>
      
         <para>
      	   To make it easier to determine whether or not a transaction is 
      	   currently active for the requesting thread, the 
      	   <literal>isTransactionActive()</literal> method can be used. The SPI
      	   implementation should query the same JTA transaction manager used 
      	   for the EJBs.
         </para>
      </section>
      
      <section>
         <title>JMS services</title>
         
         <para>
            A number of JMS operations are not container specific, and so should
            be provided via the SPI <literal>JmsServices</literal>.
            JMS does not specify how to obtain a 
            <literal>ConnectionFactory</literal> so the SPI provides a method
            which should be used to look up a factory. Web Beans also delegates
            <literal>Destination</literal> lookup to the container via the SPI.
         </para>
      </section>
      
      <section>
         <title>Resource Services</title>
           
         <para>
            The resolution of <literal>@Resource</literal> (for injection into simple
            beans) and the resolution of resources (for injection as a Java EE 
            resource) is delegated to the container. You must provide an 
            implementation of <literal>ResourceServices</literal> which 
            provides these operations. For resolving the 
            <literal>@Resource</literal> injection, Web Beans will provide the 
            <literal>InjectionPoint</literal>; and for Java EE resources, the 
            <literal>jndiName</literal> or <literal>mappedName</literal> will be
            provided.
         </para>
      </section>
      
      <section>
         <title>Web Services</title>
           
         <para>
            The resolution of web service references (for injection as a Java EE 
            resource) is delegated to the container. You must provide an 
            implementation of <literal>WebServices</literal> whichprovides this 
            operation. For resolving the Java EE resource, the 
            <literal>jndiName</literal> or <literal>mappedName</literal> will be
            provided.
         </para>
      </section>
      
      <section>
         <title>The bean store</title>
         
         <para>
            Web Beans uses a map like structure to store bean instances -
            <literal>org.jboss.webbeans.context.api.BeanStore</literal>. You may
            find 
            <literal>org.jboss.webbeans.context.api.helpers.ConcurrentHashMapBeanStore</literal>
            useful.
         </para>
      </section>
    
      <section>
         <title>The application context</title>
         
         <para>
            Web Beans expects the Application Server or other container to 
            provide the storage for each application's context. The
            <literal>org.jboss.webbeans.context.api.BeanStore</literal> should 
            be implemented to provide an application scoped storage.
         </para>
         
      </section>
       
      <section>
         <title>Bootstrap and shutdown</title>
         <para>
            The <literal>org.jboss.webbeans.bootstrap.api.Bootstrap</literal>
            interface defines the bootstrap for Web Beans. To boot Web Beans, 
            you must obtain an instance of 
            <literal>org.jboss.webbeans.bootstrap.WebBeansBootstrap</literal>
            (which implements <literal>Boostrap</literal>), tell it about the
            SPIs in use, and then request the container start.
         </para>
         
         <para>
            The bootstrap is split into phases, bootstrap initialization and 
            boot and shutdown. Initialization will create a manager, and add the 
            standard (specification defined) contexts. Bootstrap will discover
            EJBs, classes and XML; add beans defined using annotations; add
            beans defined using XML; and validate all beans.
         </para>
         
         <para>
            The bootstrap supports multiple environments. An environment is 
            defined by an implementation of the <literal>Environment</literal>
            interface. A number of standard envrionments are built in as the
            enumeration <literal>Environments</literal>. Different environments 
            require different services to be present (for example servlet 
            doesn't require transaction, EJB or JPA services). By default an
            EE environment is assumed, but you can adjust the environment by 
            calling <literal>bootstrap.setEnvironment()</literal>.
         </para>
         
         <para>
            Web Beans uses a generic-typed service registry to allow services to
            be registered. All services implement the <literal>Service</literal>
            interface. The service registry allows services to be added and
            retrieved.
         </para>
         
         <para>
            To initialize the bootstrap you call 
            <literal>Bootstrap.initialize()</literal>. Before calling 
            <literal>initialize()</literal>, you must register any services
            required by your environment. You can do this by calling
            <literal>bootstrap.getServices().add(JpaServices.class, new MyJpaServices())</literal>.
            You must also provide the application context bean store.
         </para>
         
         <para>
            Having called <literal>initialize()</literal>, the 
            <literal>Manager</literal> can be obtained by calling 
            <literal>Bootstrap.getManager()</literal>.
         </para>
         
         <para>
            To boot the container you call <literal>Bootstrap.boot()</literal>.
         </para>
         
         <para>
            To shutdown the container you call 
            <literal>Bootstrap.shutdown()</literal> or
            <literal>webBeansManager.shutdown()</literal>. This allows the 
            container to perform any cleanup operations needed.
         </para>
         
       </section>
       
       <section>
         <title>JNDI</title>
         
         <para>
            Web Beans delegates all JNDI operations to the container through the
            SPI.
         </para>
         
         <note>
            <para>
               A number of the SPI interface require JNDI lookup, and the class
               <literal>AbstractResourceServices</literal> provides JNDI/Java EE
               spec compliant lookup methods. 
            </para>
         </note>
         

       </section>
       
       <section>
         <title>Resource loading</title>
         
         <para>
            Web Beans needs to load classes and resources from the classpath at 
            various times. By default, they are loaded from the Thread Context
            ClassLoader if available, if not the same classloader that was used 
            to load Web Beans, however this may not be correct for some 
            environments. If this is case, you can implement
            <literal>org.jboss.webbeans.spi.ResourceLoader</literal>:
         </para>
         
         <programlisting role="JAVA"><![CDATA[
         public interface ResourceLoader {
    
   /**
    * Creates a class from a given FQCN
    * 
    * @param name The name of the clsas
    * @return The class
    */
   public Class<?> classForName(String name);
   
   /**
    * Gets a resource as a URL by name
    * 
    * @param name The name of the resource
    * @return An URL to the resource
    */
   public URL getResource(String name);
   
   /**
    * Gets resources as URLs by name
    * 
    * @param name The name of the resource
    * @return An iterable reference to the URLS
    */
   public Iterable<URL> getResources(String name);
   
}
         ]]></programlisting>

       </section>
       
       <section>
         <title>Servlet injection</title>
         
         <para>
            Java EE / Servlet does not provide any hooks which can be used to 
            provide injection into Servlets, so Web Beans provides an API to 
            allow the container to request JSR-299 injection for a Servlet.
         </para>
         
         <para>
            To be compliant with JSR-299, the container should request servlet
            injection for each newly instantiated servlet after the constructor
            returns and before the servlet is placed into service.
         </para>
         
         <para>
            To perform injection on a servlet call 
            <literal>WebBeansManager.injectServlet()</literal>. The manager
            can be obtained from <literal>Bootstrap.getManager()</literal>.
         </para>
         
       </section>
   
    </section>
    
    <section>
      <title>The contract with the container</title>
      
      <para>
         There are a number of requirements that the Web Beans RI places on the
         container for correct functioning that fall outside implementation of
         APIs
      </para>
      
      <variablelist>
         <varlistentry>
            <term>
               Classloader isolation
            </term>
            <listitem>
               <para>
                  If you are integrating the Web Beans RI into an environment 
                  that supports deployment of multiple applications, you must 
                  enable, automatically, or through user configuation, 
                  classloader isolation for each Web Beans application.
               </para>
            </listitem>
         </varlistentry>
         <varlistentry>
            <term>
               Servlet
            </term>
            <listitem>
               <para>
                  If you are integrating the Web Beans into a Servlet 
                  environment you must register 
                  <literal>org.jboss.webbeans.servlet.WebBeansListener</literal>
                  as a Servlet listener, either automatically, or through user
                  configuration, for each Web Beans application which uses 
                  Servlet.
               </para>
            </listitem>
         </varlistentry>
         <varlistentry>
            <term>
               JSF
            </term>
            <listitem>
            
               <para>
                  If you are integrating the Web Beans into a JSF 
                  environment you must register 
                  <literal>org.jboss.webbeans.jsf.WebBeansPhaseListener</literal>
                  as a phase listener, and
                  <literal>org.jboss.webbeans.el.WebBeansELREsolver</literal> as
                  an EL resolver, either automatically, or through user
                  configuration, for each Web Beans application which uses 
                  JSF.
               </para>
               
               <para>
                  If you are integrating the Web Beans into a JSF environment 
                  you must register 
                  <literal>org.jboss.webbeans.servlet.ConversationPropagationFilter</literal>
                  as a Servlet listener, either automatically, or through user
                  configuration, for each Web Beans application which uses 
                  JSF. This filter can be registered for all Servlet deployment
                  safely.
               </para>
               
               <note>
                  <para>
                     Web Beans only supports JSF 1.2 and above.
                  </para>
               </note>
            </listitem>
         </varlistentry>
         <varlistentry>
            <term>
               Session Bean Interceptor
            </term>
            <listitem>
               <para>
                  If you are integrating the Web Beans into an EJB 
                  environment you must register 
                  <literal>org.jboss.webbeans.ejb.SessionBeanInterceptor</literal>
                  as a EJB interceptor for all EJBs in the application, either 
                  automatically, or through user configuration, for each Web 
                  Beans application which uses enterprise beans.
               </para>
               
               <important>
                  <para>
                     You must register the <literal>SessionBeanInterceptor</literal>
                     as the inner most interceptor in the stack for all EJBs. 
                  </para>
               </important>
            </listitem>
         </varlistentry>
         <varlistentry>
            <term>
               The <literal>webbeans-core.jar</literal>
            </term>
            <listitem>
               <para>
                  If you are integrating the Web Beans into an environment that
                  supports deployment of applications, you must insert the
                  <literal>webbeans-core.jar</literal> into the applications
                  isolated classloader. It cannot be loaded from a shared 
                  classloader.
               </para>
            </listitem>
         </varlistentry>
      </variablelist>
    </section>

</appendix>