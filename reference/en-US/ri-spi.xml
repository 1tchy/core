<!DOCTYPE appendix PUBLIC "-//OASIS//DTD DocBook XML V4.3//EN" "http://www.oasis-open.org/docbook/xml/4.3/docbookx.dtd"  [ ]>

<appendix id="ri-spi">
   <title>Integrating Web Beans into other environments</title>

   <para>
      If you want to use Web Beans in another environment, you will need to
      provide certain information to Web Beans via the integration SPI. In this 
      Appendix we will briefly discuss the steps needed. 
   </para>
   
   <tip>
      <title>Enterprise Services</title>
      <para>
         If you just want to use managed beans, and not take advantage of 
         enterprise services (EE resource injection, CDI injection into EE
         component classes, transactional events, support for CDI services in 
         EJBs) and non-flat deployments, then the generic servlet support 
         provided by the "Web Beans: Servlets" extension will be sufficient,
         and will work in any container supporting the Servlet API.
      </para>
   </tip>
    
   <para>
      All SPIs and APIs described have extensive JavaDoc, which spell out the
      detailed contract between the container and Web Beans.
   </para>
    
   <section>
      <title>The Web Beans SPI</title>
      
      <para>
         The Web Beans SPI is located in the <literal>webbeans-spi</literal>
         module, and packaged as <literal>webbeans-spi.jar</literal>. Some
         SPIs are optional, and should only be implemented if you need to 
         override the default behavior; others are required.
      </para>
       
      <para>
         All interfaces in the SPI support the decorator pattern and provide a
         <literal>Forwarding</literal> class located in the 
         <literal>helpers</literal> sub package. Additional, commonly used,
         utility classes, and standard implementations are also located in the
         <literal>helpers</literal> sub package.
      </para>
       
                
      <para>
         Web Beans supports multiple environments. An environment is defined by 
         an implementation of the <literal>Environment</literal> interface. A 
         number of standard environments are built in, and described by the 
         <literal>Environments</literal> enumeration. Different environments 
         require different services to be present (for example a Servlet 
         container doesn't require transaction, EJB or JPA services). By default 
         an EE environment is assumed, but you can adjust the environment by 
         calling <literal>bootstrap.setEnvironment()</literal>.
      </para>
         
      <para>
         Web Beans uses a generic-typed service registry to allow services to be
         registered. All services implement the <literal>Service</literal>
         interface. The service registry allows services to be added and 
         retrieved.
      </para>
      
      <section>
         <title>Deployment structure</title>
      
         <para>
            An application is often comprised of a number of modules. For 
            example, a Java EE deployment may contain a number of EJB modules 
            (containing business logic) and WAR modules (containing the user 
            interface). A container may enforce certain 
            <emphasis>accessibility</emphasis> rules which limit the visibility 
            of classes between modules. Web Beans allows these same rules to 
            apply to bean and observer method resolution. As the accessibility 
            rules vary between containers, Web Beans requires the container to 
            <emphasis>describe</emphasis> the deployment structure, via the 
            <literal>Deployment</literal> SPI.
         </para>
         
         <para>
            The CDI specification discusses 
            <emphasis>Bean Deployment Archives</emphasis> (BDAs) &mdash; archives which
            are marked as containing beans which should be deployed to the CDI
            container, and made available for injection and resolution. Web 
            Beans reuses this description of 
            <emphasis>Bean Deployment Archives</emphasis> in its deployment
            structure SPI. Each deployment exposes the BDAs which it contains; 
            each BDA may also reference other which it can access. Together, the 
            transitive closure of this graph forms the beans which are deployed
            in the application.
         </para>
         
         <para>
            To describe the deployment structure to Web Beans, the container 
            should provide an implementation of <literal>Deployment</literal>.
            <literal>Deployment.getBeanDeploymentArchives()</literal> allows Web
            Beans to discover the modules which make up the application. The CDI
            specification also allows beans to be specified programmatically as
            part of the bean deployment. These beans may, or may not, be in an
            existing BDA. For this reason, Web Beans will call
            <literal>Deployment.loadBeanDeploymentArchive(Class clazz)</literal>
            for each programmatically described bean.
         </para>
         
         <para>
            As programmatically described beans may result in additional BDAs
            being added to the graph, Web Beans will discover the BDA structure
            every time an unknown BDA is returned by 
            <literal>Deployment.loadBeanDeploymentArchive</literal>.
         </para>
         
         <note>
            <title>Virtual BDAs</title>
            <para>
               In a strict container, each BDA might have to explicitly specify
               which other BDAs it can access. However many containers will 
               allow an easy mechanism to make BDAs bi-directionally accessible
               (such as a library directory). In this case, it is allowable (and
               reasonable) to describe all such archives as a single, 'virtual'
               <literal>BeanDeploymentArchive</literal>.  
            </para>
            
            <para>
               A container, might, for example, use a flat accessibility 
               structure for the application. In this case, a single 
               <literal>BeanDeploymentArchive</literal> would be attached to the
               <literal>Deployment</literal>.
            </para>
         </note>

         <para>
            <literal>BeanDeploymentArchive</literal> provides three methods 
            which allow it's contents to be discovered by Web Beans &mdash;
            <literal>BeanDeploymentArchive.getBeanClasses()</literal> must 
            return all the classes in the BDA, 
            <literal>BeanDeploymentArchive.getBeansXml()</literal> must return
            all the deployment descriptors in the archive, and
            <literal>BeanDeploymentArchive.getEjbs()</literal> must provide an
            EJB descriptor for every EJB in the BDA, or an empty list if it is
            not an EJB archive. 
         </para>
         
         <para>
            BDA X may also reference another BDA Y whose beans can be resolved 
            by, and injected into, any bean in BDA X. These are the accessible
            BDAs, and every BDA that is directly accessible by BDA X should be
            returned.  A BDA will also have BDAs which are accessible 
            transtivively, and the transitive closure of the sub-graph of BDA X 
            describes all the beans resolvable by BDA X.
         </para>
         
         <para>
            To specify the directly accessible BDAs, the container should 
            provide an implementation of 
            <literal>BeanDeploymentArchive.getBeanDeploymentArchives()</literal>.
         </para>
         
         <tip>
            <para>
               Web Beans allows the container to describe a circular graph, and
               will convert a graph to a tree as part of the deployment 
               process.
            </para>
         </tip>
         
         <para>
            Certain services are provided for the whole deployment, whilst some
            are provided per-BDA. BDA services are provided using
            <literal>BeanDeploymentArchive.getServices()</literal> and only
            apply to the BDA on which they are provided.
         </para>
         
      </section>
       
      <section>
         <title>EJB descriptors</title>
         
         <para>
            Web Beans delegates EJB3 bean discovery to the container so that it
            doesn't duplicate the work done by the EJB container, and respects
            any vendor-extensions to EJB definition,.
         </para>
               
         <para>
            The <literal>EjbDescriptor</literal> should return the relevant
            metadata as defined in the EJB specification. Each business 
            interface of a session bean should be described using a
            <literal>BusinessInterfaceDescriptor</literal>.
         </para>
         
       </section>
       
       <section>
         <title>EE resource injection and resolution services</title>
         
         <para>
            All the EE resource services are per-BDA services, and may be 
            provided using one of two methods. Which method to use is at the
            discretion of the integrator.
         </para>
         
         <para>
            The integrator may choose to provide all EE resource injection 
            services themselves, using another library or framework. In this 
            case the integrator should use the <literal>EE</literal> 
            environment, and implement the <xref linkend="injection.services" />
            SPI.
         </para>
         
         <para>
            Alternatively, the integrator may choose to use Web Beans to provide
            EE resource injection. In this case, the 
            <literal>EE_INJECT</literal> environment should be used, and the
            integrator should implement the <xref linkend="ejb.services.resolution"/>,
            <xref linkend="resource.services"/> and 
            <xref linkend="jpa.services"/>.
         </para>
         
         <important>
            <para>
               Web Beans only provides annotation-based EE resource injection;
               if you wish to provide deployment descriptor 
               (e.g. <literal>ejb-jar.xml</literal>) injection, you must use 
               <xref linkend="injection.services"/>.
            </para>
         </important>
          
         <tip>
            <para>
               If you use a non-EE environment then you may implement any of the
               EE service SPIs, and Web Beans will provide the associated
               functionality. There is no need to implement those services you
               don't need!
            </para>
         </tip>
         
      </section>
         
      <section id="ejb.services">
         <title>EJB services</title>
         
         <para>
            EJB services are split between two interfaces which are both 
            per-BDA.
         </para>
         
         <para>
           <literal>EJBServices</literal> is used to resolve local EJBs
           used to back session beans, and must always be provided in an EE
           environment. 
           <literal>EJBServices.resolveEjb(EjbDescriptor ejbDescriptor)</literal> 
           returns a wrapper &mdash; <literal>SessionObjectReference</literal> &mdash;
           around the EJB reference. This wrapper allows Web Beans to request a
           reference that implements the given business interface, and, in the 
           case of SFSBs, request the removal of the EJB from the container.
         </para>
         
         <para id="ejb.services.resolution">
            <literal>EJBResolutionServices.resolveEjb(InjectionPoint ij)</literal>
            allows the resolution of <literal>@EJB</literal> (for injection into
            managed beans). This service is not required if the implementation of 
            <xref linkend="injection.services"/> takes care of 
            <literal>@EJB</literal> injection.
         </para>
         
      </section>
       
      <section id="jpa.services">
         <title>JPA services</title>
         
         <para>
            Just as EJB resolution is delegated to the container, resolution of
            <literal>@PersistenceContext</literal> for injection into managed 
            beans (with the <literal>InjectionPoint</literal> provided), is 
            delegated to the container.
         </para>
         
         <para>
            To allow JPA integration, the <literal>JpaServices</literal> 
            interface should be implemented. This service is not required if the
            implementation of <xref linkend="injection.services"/> takes care of 
            <literal>@PersistenceContext</literal> injection.
         </para>
         
      </section>
       
      <section>
         <title>Transaction Services</title>
         
         <para>
            Web Beans delegates JTA activities to the container. The SPI 
            provides a couple hooks to easily achieve this with the 
            <literal>TransactionServices</literal> interface.
         </para>
      
         <para>
      	   Any <literal>javax.transaction.Synchronization</literal> 
      	   implementation may be passed to the 
      	   <literal>registerSynchronization()</literal> method and the SPI 
      	   implementation should immediately register the synchronization with 
      	   the JTA transaction manager used for the EJBs.
         </para>
      
         <para>
      	   To make it easier to determine whether or not a transaction is 
      	   currently active for the requesting thread, the 
      	   <literal>isTransactionActive()</literal> method can be used. The SPI
      	   implementation should query the same JTA transaction manager used 
      	   for the EJBs.
         </para>
      </section>
      
      <section id="resource.services">
         <title>Resource Services</title>
           
         <para>
            The resolution of <literal>@Resource</literal> (for injection into managed
            beans) is delegated to the container. You must provide an 
            implementation of <literal>ResourceServices</literal> which 
            provides these operations.  This service is not required if the
            implementation of <xref linkend="injection.services"/> takes care of 
            <literal>@Resource</literal> injection.
         </para>
      </section>
      
      <section id="injection.services">
         <title>Injection Services</title>
         
         <para>
            An integrator may wish to use <literal>InjectionServices</literal> 
            to provide additional field or method injection over-and-above that
            provided by Web Beans. An integration into a Java EE environment may
            use <literal>InjectionServices</literal> to provide EE resource
            injection for managed beans.
         </para>
         
         <para>
            <literal>InjectionServices</literal> provides a very simple
            contract, the 
            <literal>InjectionServices.preInject(Object instance);</literal>
            and
            <literal>InjectionServices.postInject(Object instance);</literal>
            callbacks will be called for every instance that Web Beans injects,
            whether it is a contextual instance, or a non-contexutal instance
            injected by <literal>InjectionTarget.inject()</literal>.
         </para>
         
      </section>
      
      <section>
         <title>Identifying the BDA being addressed</title>
         
         <para>
            When a client makes a request to an application which uses Web 
            Beans, the request may be addressed at any of the BDAs in the
            application deployment. To allow the Web Beans to correctly service
            the request, it needs to know which BDA the request is addressed at.
            Where possible, Web Beans will provide some context, but use of 
            these by the integrator is optional.
         </para>
         
         <tip>
            <para>
               Most Servlet contains use a classloader-per-WAR, this may provide
               a good way to identify the BDA in use for web requests.
            </para>
         </tip>
         
         <para>
            When Web Beans need to identify the BDA, it will use one of these
            services, depending on what is servicing the request:
         </para>
         
         <variablelist>
            <varlistentry>
               <term><literal>ServletServices.getBeanDeploymentArchive(ServletContext ctx)</literal></term>
               <listitem>
                  <para>
                     Identify the WAR in use. The 
                     <literal>ServletContext</literal> is provided for 
                     additional context.
                  </para>
               </listitem>
            </varlistentry>
            <varlistentry>
               <term><literal>JSFServices.getBeanDeploymentArchive(Application application)</literal></term>
               <listitem>
                  <para>
                     Identify the WAR in use. The 
                     <literal>Application</literal> is provided for 
                     additional context.
                  </para>
               </listitem>
            </varlistentry>
         </variablelist>
         
      </section>
      
      <section>
         <title>The bean store</title>
         
         <para>
            Web Beans uses a map like structure to store bean instances -
            <literal>org.jboss.webbeans.context.api.BeanStore</literal>. You may
            find 
            <literal>org.jboss.webbeans.context.api.helpers.ConcurrentHashMapBeanStore</literal>
            useful.
         </para>
      </section>
    
      <section>
         <title>The application context</title>
         
         <para>
            Web Beans expects the Application Server or other container to 
            provide the storage for each application's context. The
            <literal>org.jboss.webbeans.context.api.BeanStore</literal> should 
            be implemented to provide an application scoped storage.
         </para>
         
      </section>
       
      <section>
         <title>Initialization and shutdown</title>
         <para>
            The <literal>org.jboss.webbeans.bootstrap.api.Bootstrap</literal>
            interface defines the initialization for Web Beans, bean deployment
            and bean validation. To boot Web Beans, you must create an instance 
            of 
            <literal>org.jboss.webbeans.bootstrap.WebBeansBootstrap</literal>
            (which implements <literal>Boostrap</literal>), tell it about the
            services in use, and then request the container start.
         </para>
         
         <para>
            The bootstrap is split into phases, container initialization, bean 
            deployment, bean validation and shutdown. Initialization will create
            a manager, and add the built-in contexts, and examine the deployment
            structure. Bean deployment will deploy any beans (defined using
            annotations, programtically, or built in). Bean validation will
            validate all beans.
         </para>
         
         <para>
            To initialize the container, you call 
            <literal>Bootstrap.startInitialization()</literal>. Before calling 
            <literal>startInitialization()</literal>, you must register 
            any services required by the environment. You can do this by 
            calling, for example,
            <literal>bootstrap.getServices().add(JpaServices.class, new MyJpaServices())</literal>.
            You must also provide the application context bean store.
         </para>
         
         <para>
            Having called <literal>startInitialization()</literal>, the 
            <literal>Manager</literal> for each BDA can be obtained by calling 
            <literal>Bootstrap.getManager(BeanDeploymentArchive bda)</literal>.
         </para>
         
         <para>
            To deploy the discovered beans, call 
            <literal>Bootstrap.deployBeans()</literal>.
         </para>
         
         <para>
            To validate the deployed beans, call 
            <literal>Bootstrap.validateBeans()</literal>.
         </para>
         
         <para>
            To place the container into a state where it can service requests,
            call <literal>Bootstrap.endInitialization()</literal>
         </para>
         
         <para>
            To shutdown the container you call 
            <literal>Bootstrap.shutdown()</literal>. This allows the 
            container to perform any cleanup operations needed.
         </para>
         
       </section>
       
       <section>
         <title>Resource loading</title>
         
         <para>
            Web Beans needs to load classes and resources from the classpath at 
            various times. By default, they are loaded from the Thread Context
            ClassLoader if available, if not the same classloader that was used 
            to load Web Beans, however this may not be correct for some 
            environments. If this is case, you can implement
            <literal>org.jboss.webbeans.spi.ResourceLoader</literal>.
         </para>

       </section>
   
    </section>
    
    <section>
      <title>The contract with the container</title>
      
      <para>
         There are a number of requirements that the Web Beans RI places on the
         container for correct functioning that fall outside implementation of
         APIs
      </para>
      
      <variablelist>
         <varlistentry>
            <term>
               Classloader isolation
            </term>
            <listitem>
               <para>
                  If you are integrating the Web Beans RI into an environment 
                  that supports deployment of multiple applications, you must 
                  enable, automatically, or through user configuation, 
                  classloader isolation for each Web Beans application.
               </para>
            </listitem>
         </varlistentry>
         <varlistentry>
            <term>
               Servlet
            </term>
            <listitem>
               <para>
                  If you are integrating the Web Beans into a Servlet 
                  environment you must register 
                  <literal>org.jboss.webbeans.servlet.WebBeansListener</literal>
                  as a Servlet listener, either automatically, or through user
                  configuration, for each Web Beans application which uses 
                  Servlet.
               </para>
            </listitem>
         </varlistentry>
         <varlistentry>
            <term>
               JSF
            </term>
            <listitem>
            
               <para>
                  If you are integrating the Web Beans into a JSF 
                  environment you must register 
                  <literal>org.jboss.webbeans.jsf.WebBeansPhaseListener</literal>
                  as a phase listener.
               </para>
               
               <para>
                  If you are integrating the Web Beans into a JSF 
                  environment you must register 
                  <literal>org.jboss.webbeans.jsf.WebBeansApplicationFactory</literal>
                  as an (wrapping) factory for the <literal>Application</literal>.
               </para>
               
               <para>
                  If you are integrating the Web Beans into a JSF environment 
                  you must register 
                  <literal>org.jboss.webbeans.servlet.ConversationPropagationFilter</literal>
                  as a Servlet listener, either automatically, or through user
                  configuration, for each Web Beans application which uses 
                  JSF. This filter can be registered for all Servlet deployment
                  safely.
               </para>
               
               <note>
                  <para>
                     Web Beans only supports JSF 1.2 and above.
                  </para>
               </note>
            </listitem>
         </varlistentry>
         <varlistentry>
            <term>
               Session Bean Interceptor
            </term>
            <listitem>
               <para>
                  If you are integrating the Web Beans into an EJB 
                  environment you must register 
                  <literal>org.jboss.webbeans.ejb.SessionBeanInterceptor</literal>
                  as a EJB interceptor for all EJBs in the application, either 
                  automatically, or through user configuration, for each Web 
                  Beans application which uses enterprise beans.
               </para>
               
               <important>
                  <para>
                     You must register the <literal>SessionBeanInterceptor</literal>
                     as the inner most interceptor in the stack for all EJBs. 
                  </para>
               </important>
            </listitem>
         </varlistentry>
         <varlistentry>
            <term>
               The <literal>webbeans-core.jar</literal>
            </term>
            <listitem>
               <para>
                  Web Beans can reside on an isolated classloader, or on a
                  shared classloader. If you choose to use an isolated 
                  classloader, the default <literal>SingletonProvider</literal>,
                  <literal>IsolatedStaticSingletonProvider</literal>, can be 
                  used. If you choose to use a shared classloader, then you will
                  need to choose another strategy. 
               </para>   
               <para>
                  You can provide your own implementation of 
                  <literal>Singleton</literal> and 
                  <literal>SingletonProvider</literal> and register it for use
                  using <literal>SingletonProvider.initialize(SingletonProvider provider)</literal>.
               </para>
               <para>
                  Web Beans also provides an implementation of Thread Context
                  Classloader per application strategy, via the 
                  <literal>TCCLSingletonProvider</literal>.
               </para>
            </listitem>
         </varlistentry>
         <varlistentry>
            <term>
               Binding the manager in JNDI
            </term>
            <listitem>
               <para>
                  You should bind a <literal>Reference</literal> to the Manager 
                  <literal>ObjectFactory</literal> into JNDI at 
                  <literal>java:app/Manager</literal>. The type should be
                  <literal>javax.inject.manager.Manager</literal> and the 
                  factory class is 
                  <literal>org.jboss.webbeans.resources.ManagerObjectFactory</literal>
               </para>
            </listitem>
         </varlistentry>
         <varlistentry>
            <term>
               Performing CDI injection on Java EE component classes
            </term>
            <listitem>
               <para>
                  The CDI specification requires the container to provide 
                  injection into non-contextual resources for all Java EE
                  component classes. Web Beans delegates this responsibility to
                  the container. This can be achieved using the CDI defined
                  <literal>InjectionTarget</literal> SPI:
               </para>
               
               <programlisting><![CDATA[

// Create the injection target, once per class
InjectionTarget it = deploymentBeanManager.createInjectionTarget(clazz);

// Per instance required, create the creational context
CreationalContext<?> cc = deploymentBeanManager.createCreationalContext(null);

// Produce the instance, performing any constructor injection required
Object instance = it.produce();

// Perform injection and call initializer
it.inject(instance, cc);

// Call the post-construct callback
it.postConstruct(instance);

// Call the pre-destroy callback
it.preDestroy(instance);

// Clean up the instance
it.dispose();
cc.release();

]]></programlisting>
               <para>
                  The container may intersperse other operations between these
                  calls. Further, the integrator may choose to implement any of
                  these calls in another manner, assuming the contract is
                  fulfilled.
               </para>
            </listitem>
         </varlistentry>
      </variablelist>
    </section>

</appendix>