# translation of ee.po to Traditional Chinese
# Language zh-TW translations for Introduction_to_Web_Beans package.
#
# Automatically generated, 2009.
# Terry Chuang <tchuang@redhat.com>, 2009.
msgid ""
msgstr ""
"Project-Id-Version: ee\n"
"Report-Msgid-Bugs-To: http://bugs.kde.org\n"
"POT-Creation-Date: 2009-01-06 11:30+0000\n"
"PO-Revision-Date: 2009-01-12 17:24+1000\n"
"Last-Translator: Terry Chuang <tchuang@redhat.com>\n"
"Language-Team: Traditional Chinese <zh@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"X-Generator: KBabel 1.11.4\n"

#. Tag: title
#: ee.xml:4
#, no-c-format
msgid "Java EE integration"
msgstr "Java EE 整合"

#. Tag: para
#: ee.xml:6
#, no-c-format
msgid ""
"Web Beans is fully integrated into the Java EE environment. Web Beans have "
"access to Java EE resources and JPA persistence contexts. They may be used "
"in Unified EL expressions in JSF and JSP pages. They may even be injected "
"into some objects, such as Servlets and Message-Driven Beans, which are not "
"Web Beans."
msgstr "Web Bean 已完整整合入 Java EE 環境中。Web Bean 可存取 Java EE 資源以及 JPA persistence context。它們可能會被使用於 JSF 以及 JSP 網頁中的 Unified EL 表示式中。它們也可被注入一些物件中，例如 Servlets 以及訊息導向的 Bean 中（非 Web Beans）。"

#. Tag: title
#: ee.xml:12
#, no-c-format
msgid "Injecting Java EE resources into a Web Bean"
msgstr "將 Java EE 資源注入 Web Bean 中"

#. Tag: para
#: ee.xml:14
#, no-c-format
msgid ""
"All simple and enterprise Web Beans may take advantage of Java EE dependency "
"injection using <literal>@Resource</literal>, <literal>@EJB</literal> and "
"<literal>@PersistenceContext</literal>. We've already seen a couple of "
"examples of this, though we didn't pay much attention at the time:"
msgstr ""
"所有基本與企業的 Web Bean 都能透過 <literal>@Resource</literal>、<literal>@EJB</literal> 以及 "
"<literal>@PersistenceContext</literal> 來有效利用 Java EE 相依性注入。我們早已見過了這方面的範例，不過當時我們並未詳細討論到："

#. Tag: programlisting
#: ee.xml:19
#, no-c-format
msgid ""
"<![CDATA[@Transactional @Interceptor\n"
"public class TransactionInterceptor {\n"
"\n"
"    @Resource Transaction transaction;\n"
"\n"
"    @AroundInvoke public Object manageTransaction(InvocationContext ctx) "
"{ ... }\n"
"    \n"
"}]]>"
msgstr ""
"<![CDATA[@Transactional @Interceptor\n"
"public class TransactionInterceptor {\n"
"\n"
"    @Resource Transaction transaction;\n"
"\n"
"    @AroundInvoke public Object manageTransaction(InvocationContext ctx) "
"{ ... }\n"
"    \n"
"}]]>"

#. Tag: programlisting
#: ee.xml:21
#, no-c-format
msgid ""
"<![CDATA[@SessionScoped\n"
"public class Login {\n"
"\n"
"    @Current Credentials credentials;\n"
"    @PersistenceContext EntityManager userDatabase;\n"
"    \n"
"    ...\n"
"\n"
"}]]>"
msgstr ""
"<![CDATA[@SessionScoped\n"
"public class Login {\n"
"\n"
"    @Current Credentials credentials;\n"
"    @PersistenceContext EntityManager userDatabase;\n"
"    \n"
"    ...\n"
"\n"
"}]]>"

#. Tag: para
#: ee.xml:23
#, no-c-format
msgid ""
"The Java EE <literal>@PostConstruct</literal> and <literal>@PreDestroy</"
"literal> callbacks are also supported for all simple and enterprise Web "
"Beans. The <literal>@PostConstruct</literal> method is called after "
"<emphasis>all</emphasis> injection has been performed."
msgstr "所有基本與企業的 Web Bean 也都支援 Java EE <literal>@PostConstruct</literal> 和 <literal>@PreDestroy</literal> 的 callback。<literal>@PostConstruct</literal> 這個 method 會在<emphasis>所有</emphasis>注入被進行後才會被調用。"

#. Tag: para
#: ee.xml:28
#, no-c-format
msgid ""
"There is one restriction to be aware of here: <literal>@PersistenceContext"
"(type=EXTENDED)</literal> is not supported for simple Web Beans."
msgstr "在此有項需要注意的限制：基本的 Web Bean 並不支援 <literal>@PersistenceContext(type=EXTENDED)</literal>。"

#. Tag: title
#: ee.xml:35
#, no-c-format
msgid "Calling a Web Bean from a Servlet"
msgstr "透過一個 Servlet 來調用 Web Bean"

#. Tag: para
#: ee.xml:37
#, no-c-format
msgid ""
"It's easy to use a Web Bean from a Servlet in Java EE 6. Simply inject the "
"Web Bean using Web Beans field or initializer method injection."
msgstr "在 Java EE 6 中透過 Servlet 來使用 Web Bean 相當地簡單。只要使用 Web Bean 欄位或是 initializer method 注入來注入 Web Bean 即可。"

#. Tag: programlisting
#: ee.xml:40
#, no-c-format
msgid ""
"public class Login extends HttpServlet {\n"
"\n"
"    @Current Credentials credentials;\n"
"    @Current Login login;\n"
"\n"
"    @Override\n"
"    public void service(HttpServletRequest request, HttpServletResponse "
"response)\n"
"        throws ServletException, IOException {\n"
"        credentials.setUsername( request.getAttribute(\"username\") ):\n"
"        credentials.setPassword( request.getAttribute(\"password\") ):\n"
"        login.login();\n"
"        if ( login.isLoggedIn() ) {\n"
"            response.sendRedirect(\"/home.jsp\");\n"
"        }\n"
"        else {\n"
"            response.sendRedirect(\"/loginError.jsp\");\n"
"        }\n"
"    }\n"
"            \n"
"}"
msgstr ""
"public class Login extends HttpServlet {\n"
"\n"
"    @Current Credentials credentials;\n"
"    @Current Login login;\n"
"\n"
"    @Override\n"
"    public void service(HttpServletRequest request, HttpServletResponse "
"response)\n"
"        throws ServletException, IOException {\n"
"        credentials.setUsername( request.getAttribute(\"username\") ):\n"
"        credentials.setPassword( request.getAttribute(\"password\") ):\n"
"        login.login();\n"
"        if ( login.isLoggedIn() ) {\n"
"            response.sendRedirect(\"/home.jsp\");\n"
"        }\n"
"        else {\n"
"            response.sendRedirect(\"/loginError.jsp\");\n"
"        }\n"
"    }\n"
"            \n"
"}"

#. Tag: para
#: ee.xml:42
#, no-c-format
#, fuzzy
msgid ""
"The Web Beans client proxy takes care of routing method invocations from the "
"Servlet to the correct instances of <literal>Credentials</literal> and "
"<literal>Login</literal> for the current request and HTTP session."
msgstr "Web Bean 的客戶端 proxy 能處理路由"

#. Tag: title
#: ee.xml:49
#, no-c-format
msgid "Calling a Web Bean from a Message-Driven Bean"
msgstr "透過訊息導向的 Bean 來調用 Web Bean"

#. Tag: para
#: ee.xml:51
#, no-c-format
msgid ""
"Web Beans injection applies to all EJBs, even when they aren't under the "
"control of the Web Bean manager (if they were obtained by direct JNDI "
"lookup, or injection using <literal>@EJB</literal>, for example. In "
"particular, you can use Web Beans injection in Message-Driven Beans, which "
"are not considered Web Beans because you can't inject them."
msgstr "Web Bean 注入適用於所有 EJB，儘管它們不是由 Web Bean 管理員所控制（比方說若它們是透過直接的 JNDI 搜尋或是透過使用 <literal>@EJB</literal> 來被取得的情況下）。特別是，您可在訊息導向的 Bean 中使用 Web Bean 注入，不過這些 Bean 並不被視為是 Web Bean 因為您無法注入它們。"

#. Tag: para
#: ee.xml:57
#, no-c-format
msgid "You can even use Web Beans interceptor bindings for Message-Driven Beans."
msgstr "針對於訊息導向的 Bean，您甚至可使用 Web Bean 攔截器綁定。"

#. Tag: programlisting
#: ee.xml:59
#, no-c-format
msgid ""
"@Transactional @MessageDriven\n"
"public class ProcessOrder implements MessageListener {\n"
"\n"
"    @Current Inventory inventory;\n"
"    @PersistenceContext EntityManager em;\n"
"\n"
"    public void onMessage(Message message) {\n"
"        ...\n"
"    }\n"
"            \n"
"}"
msgstr ""
"@Transactional @MessageDriven\n"
"public class ProcessOrder implements MessageListener {\n"
"\n"
"    @Current Inventory inventory;\n"
"    @PersistenceContext EntityManager em;\n"
"\n"
"    public void onMessage(Message message) {\n"
"        ...\n"
"    }\n"
"            \n"
"}"

#. Tag: para
#: ee.xml:61
#, no-c-format
msgid ""
"Thus, receiving messages is super-easy in a Web Beans environment. But "
"beware that there is no session or conversation context available when a "
"message is delivered to a Message-Driven Bean. Only <literal>@RequestScoped</"
"literal> and <literal>@ApplicationScoped</literal> Web Beans are available."
msgstr "因此，在 Web Bean 環境下，取得訊息是相當地簡單的。不過請注意，當訊息提交至一個訊息導向的 Bean 時，不會有可用的 session 或是對話 context。只有 <literal>@RequestScoped</literal> 和 <literal>@ApplicationScoped</literal> Web Bean 可使用。"

#. Tag: para
#: ee.xml:66
#, no-c-format
msgid "It's also easy to send messages using Web Beans."
msgstr "透過使用 Web Bean 來傳送訊息也相當地簡單。"

#. Tag: title
#: ee.xml:71
#, no-c-format
msgid "JMS endpoints"
msgstr "JMS 端點"

#. Tag: para
#: ee.xml:73
#, no-c-format
msgid ""
"Sending messages using JMS can be quite complex, because of the number of "
"different objects you need to deal with. For queues we have <literal>Queue</"
"literal>, <literal>QueueConnectionFactory</literal>, "
"<literal>QueueConnection</literal>, <literal>QueueSession</literal> and "
"<literal>QueueSender</literal>. For topics we have <literal>Topic</literal>, "
"<literal>TopicConnectionFactory</literal>, <literal>TopicConnection</"
"literal>, <literal>TopicSession</literal> and <literal>TopicPublisher</"
"literal>. Each of these objects has its own lifecycle and threading model "
"that we need to worry about."
msgstr ""
"基於需要處理許多不同的物件，因此透過使用 JMS 來傳送訊息可能會相當複雜。針對於 queue，我們有 <literal>Queue</"
"literal>、<literal>QueueConnectionFactory</literal>、<literal>QueueConnection</literal>、<literal>QueueSession</literal> 以及 <literal>QueueSender</literal>。針對於 topic 我們有 <literal>Topic</literal>、<literal>TopicConnectionFactory</literal>、<literal>TopicConnection</"
"literal>、<literal>TopicSession</literal> 以及 <literal>TopicPublisher</literal>。針對於各個這些物件，我們都需要去顧及它們自己各別的生命週期和執行緒模型（threading model）。"

#. Tag: para
#: ee.xml:82
#, no-c-format
msgid ""
"Web Beans takes care of all this for us. All we need to do is declare the "
"queue or topic in <literal>web-beans.xml</literal>, specifying an associated "
"binding type and connection factory."
msgstr "Web Bean 會全部為我們處理。我們只需要在 <literal>web-beans.xml</literal> 中宣告 queue 或是 topic，指定關聯的綁定類型和連接因數（connection factory）。"

#. Tag: programlisting
#: ee.xml:86
#, no-c-format
msgid ""
"<![CDATA[<Queue>\n"
"    <destination>java:comp/env/jms/OrderQueue</destination>\n"
"    <connectionFactory>java:comp/env/jms/QueueConnectionFactory</"
"connectionFactory>\n"
"    <myapp:OrderProcessor/>    \n"
"</Queue>]]>"
msgstr ""
"<![CDATA[<Queue>\n"
"    <destination>java:comp/env/jms/OrderQueue</destination>\n"
"    <connectionFactory>java:comp/env/jms/QueueConnectionFactory</"
"connectionFactory>\n"
"    <myapp:OrderProcessor/>    \n"
"</Queue>]]>"

#. Tag: programlisting
#: ee.xml:88
#, no-c-format
msgid ""
"<![CDATA[<Topic>\n"
"    <destination>java:comp/env/jms/StockPrices</destination>\n"
"    <connectionFactory>java:comp/env/jms/TopicConnectionFactory</"
"connectionFactory>\n"
"    <myapp:StockPrices/>    \n"
"</Topic>]]>"
msgstr ""
"<![CDATA[<Topic>\n"
"    <destination>java:comp/env/jms/StockPrices</destination>\n"
"    <connectionFactory>java:comp/env/jms/TopicConnectionFactory</"
"connectionFactory>\n"
"    <myapp:StockPrices/>    \n"
"</Topic>]]>"

#. Tag: para
#: ee.xml:90
#, no-c-format
msgid ""
"Now we can just inject the <literal>Queue</literal>, "
"<literal>QueueConnection</literal>, <literal>QueueSession</literal> or "
"<literal>QueueSender</literal> for a queue, or the <literal>Topic</literal>, "
"<literal>TopicConnection</literal>, <literal>TopicSession</literal> or "
"<literal>TopicPublisher</literal> for a topic."
msgstr ""
"現在我們只要為 queue 注入 <literal>Queue</literal>、<literal>QueueConnection</literal>、<literal>QueueSession</literal> 或 "
"<literal>QueueSender</literal>，或是為 topic 注入 <literal>Topic</literal>、<literal>TopicConnection</literal>、<literal>TopicSession</literal> 或是 "
"<literal>TopicPublisher</literal> 即可。"

#. Tag: programlisting
#: ee.xml:96
#, no-c-format
msgid ""
"@OrderProcessor QueueSender orderSender;\n"
"@OrderProcessor QueueSession orderSession;\n"
"\n"
"public void sendMessage() {\n"
"    MapMessage msg = orderSession.createMapMessage();\n"
"    ...\n"
"    orderSender.send(msg);\n"
"}"
msgstr ""
"@OrderProcessor QueueSender orderSender;\n"
"@OrderProcessor QueueSession orderSession;\n"
"\n"
"public void sendMessage() {\n"
"    MapMessage msg = orderSession.createMapMessage();\n"
"    ...\n"
"    orderSender.send(msg);\n"
"}"

#. Tag: programlisting
#: ee.xml:98
#, no-c-format
msgid ""
"@StockPrices TopicPublisher pricePublisher;\n"
"@StockPrices TopicSession priceSession;\n"
"\n"
"public void sendMessage(String price) {\n"
"    pricePublisher.send( priceSession.createTextMessage(price) );\n"
"}"
msgstr ""
"@StockPrices TopicPublisher pricePublisher;\n"
"@StockPrices TopicSession priceSession;\n"
"\n"
"public void sendMessage(String price) {\n"
"    pricePublisher.send( priceSession.createTextMessage(price) );\n"
"}"

#. Tag: para
#: ee.xml:100
#, no-c-format
msgid ""
"The lifecycle of the injected JMS objects is completely controlled by the "
"Web Bean manager."
msgstr "被注入的 JMS 物件的生命週期完全由 Web Bean 管理員所控制。"

#. Tag: title
#: ee.xml:106
#, no-c-format
msgid "Packaging and deployment"
msgstr "封裝和建置"

#. Tag: para
#: ee.xml:108
#, no-c-format
msgid ""
"Web Beans doesn't define any special deployment archive. You can package Web "
"Beans in JARs, EJB-JARs or WARs&#151;any deployment location in the "
"application classpath. However, each archive that contains Web Beans must "
"include a file named <literal>web-beans.xml</literal> in the <literal>META-"
"INF</literal> or <literal>WEB-INF</literal> directory. The file may be "
"empty. Web Beans deployed in archives that do not have a <literal>web-beans."
"xml</literal> file will not be available for use in the application."
msgstr "Web Bean 不會定義任何特殊的建置 archive。您可將 Web Bean 封裝在 JARs、EJB-JARs 或是 WARs&#151; 中，應用程式 classpath 中的任何建置位置上。不過，各個包含著 Web Bean 的 archive 在 <literal>META-INF</literal> 或是 <literal>WEB-INF</literal> 目錄中都必須包含著一個稱為 <literal>web-beans.xml</literal> 的檔案。該檔案能是空的。建置於一個沒有 <literal>web-beans.xml</literal> 檔案的 archive 中的 Web Bean 將無法使用於應用程式中。"

#. Tag: para
#: ee.xml:116
#, no-c-format
msgid ""
"For Java SE execution, Web Beans may be deployed in any location in which "
"EJBs may be deployed for execution by the embeddable EJB Lite container. "
"Again, each location must contain a <literal>web-beans.xml</literal> file."
msgstr "對於 Java SE 的執行來說，Web Bean 可被建置於任何位置上，同時 EJB 亦可被建置來讓可崁入的 EJB Lite container 執行。再次強調，各個位置都必須包含著一個 <literal>web-beans.xml</literal> 檔案。"

